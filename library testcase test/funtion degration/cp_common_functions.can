/*@!Encoding:1250*/
//!****************************************************************************************
//! Copyright(c) - This program/software is the exclusive property of Robert Bosch
//! Gmbh. Without their consent it may not be reproduced or given to third parties.
//!****************************************************************************************

/*!
* \file cp_common_functions.can
* \brief	Contains all commonly used functions.
*
* \authors Test engineers of CC_DA/EAV2-Bp.
*
* \par Module description
* 	Implements the functions and test cases commonly used in the CC_DA/EAV2-Bp group for common project test automation.
*
* \note Rules of the function storing and briefing: \n
* 			[GLOBAL VARIABLES]: \n
*				//- -  \n
*				//! \brief  Description of the global variable usage  \n
*				//!  \n
*				//! \type Variable type description \n
*				//- -  \n
*				[VARIABLE TYPE] [VARIABLE NAME]; \n
*				Alphabetic ordering and below the [GLOBAL VARIABLES] chapter location needed. \n
*			[RETURN BYTE / DWORD / INT FUNCTIONS]: \n
*				//- ----------------------------------------------------------------------------------------------- \n
*				//! \brief  Description of the function usage \n
*				//! \n
*				//! \param  Description of the parameters (new line for each parameters) \n
*				//! \n
*				//! \return Description of the return value meaning / type \n
*				//! \n
*				//! \note 	Additional info about the function \n
*				//- ----------------------------------------------------------------------------------------------- \n
*				[RETURN TYPE] [FUNCTION NAME]; \n
*				Alphabetic ordering and below the [RETURN BYTE / DWORD / INT FUNCTIONS] chapter location needed. \n
*			[VOID FUNCTIONS]: \n
*				Same usage like [RETURN BYTE / DWORD / INT FUNCTIONS] without return value. \n
*				[FUNCTION NAME]; \n
*				Alphabetic ordering and below the [VOID FUNCTIONS] chapter location needed. \n
*			[TESTCASE / VOID FUNCTIONS]: \n
*				Same usage like [RETURN BYTE / DWORD / INT FUNCTIONS] without return value, but two attribute needed: \n
*				//! \teststep Test step to be added to DOORS \n
*				//! \testresponse Test Response to be added to DOORS \n
*				testcase [FUNCTION NAME]; \n
*				When the testcase calls only non testcase function, then this function should be stored after the testcase. \n
*				Same usage like [RETURN BYTE / DWORD / INT FUNCTIONS] with / without return value. \n
*				[FUNCTION NAME]Function; \n
*				Alphabetic ordering (as per testcase function name) and below the [TESTCASE / VOID FUNCTIONS] chapter location needed. \n
*			[OSEK FUNCTIONS]: \n
*				OSEK related functions.
*/

// ----------------------------------------------------[GLOBAL VARIABLES]----------------------------------------------------

///@cond
variables
{  ///@endcond
	
	//- - 
	//! \brief  Global variable stores the ASCII converted response in string variable
	//! 
	//! \type char array type variable
	//- -
	char 	AsciiData[8194];
	
	//- - 
	//! \brief  Global variable to store the binary form of a DINX signal
	//! 
	//! \type char array type variable
	//- - 
	char 	BinaryNumber[50];
	
	//- - 
	//! \brief  Global variable stores the arrived response bytes in string variable
	//! 
	//! \type char array type variable
	//- -
    char    byteString[8194];
	
	//- - 
	//! \brief  Global variable to store the escaped string
	//! 
	//! \type char array type variable
	//- -	
	char 	command_buffer[500];
	
	//- - 
	//! \brief  Stores the value of the needed signal
	//! 
	//! \type char array type variable
	//- - 
	char 	currValue[64];
	
	//- - 
	//! \brief  Global variable to get a line from the file
	//! 
	//! \type char array type variable
	//- - 
	char 	dinx_buffer[1000];
	
	//- - 
	//! \brief  Global variable to store the whole file
	//! 
	//! \type char array type variable
	//- - 
	char 	FileBuffer[10000];
	
	//- - 
	//! \brief  Global variable to display the actual Data block
	//! 
	//! \type char array type variable
	//- -		
    char 	g_TextEvent[12];
	
	//- - 
	//! \brief  Global variable to store MID names with their corresponding MID hex values
	//! 
	//! \type char array type variable
	//- - 
	char 	MIDArr[2000][100] = {{'0'}};
    
	//- - 
	//! \brief  Global variable to store the actual received message in string type
	//! 
	//! \type char array type variable
	//- -	
    char    RsRxStringData[8194];
	
	//- - 
	//! \brief  Global variable to store the actual transmitted message in string type
	//! 
	//! \type char array type variable
	//- -	
    char    RqTxStringData[8194];
	
	//- - 
	//! \brief  Global variable to save the previously received response
	//! 
	//! \type char array type variable
	//- -
	char    seedString[8194];
	
	//- - 
	//! \brief  Global variable to store the parameters from the TAC file (C:\TAC\TAC.conf) according to the desired flag
	//! 
	//! \type char array type variable
	//- -
	char TACString[1000];
	
	//- - 
	//! \brief  Global variable to store the parameter value from the TAC file (C:\TAC\TAC.conf) according to the desired ID
	//! 
	//! \type char array type variable
	//- -
	char TACStringParam[100];

	//- - 
	//! \brief  Global variable for the transmitted message
	//! 
	//! \type byte array type variable
	//- -		
    byte    RqTxData[8194];
	
	//- - 
	//! \brief  Global variable for the received message
	//! 
	//! \type byte array type variable
	//- -	
    byte    RsRxIntData[8194];
	
	//- - 
	//! \brief  Global variable to save the previously received response in byte format
	//! 
	//! \type byte array type variable
	//- -
    byte    seedData[8194];
	
	//- - 
	//! \brief  Global variable to store the TAC configuration from C:\TAC\TAC.conf file
	//! 
	//! \type dword type variable
	//- -
	dword TACConf;
	
	//- - 
	//! \brief  Global variable to store the bus context.
	//! 
	//! \type dword type variable
	//- -
    dword     StoredBuxContext;	
	
	//-
	//! \brief  Global variable to store a timestamp. \n
	//!			E.g., this is used in the <em> <b> TimeNowStart </b> </em> testcase.
	//! 
	//! \type Float type variable.
	//-
	float   tMesStart;
	
	//- - 
	//! \brief  Global variable to set bus context for correct CAN channel usage.
	//! 
	//! \type int type variable
	//- -
    int     g_debug = 0;
	
	//- - 
	//! \brief  Global variable stores the service ID of the diagnostic message
	//! 
	//! \type int type variable
	//- -	
    int     SID;

	//- - 
	//! \brief  Global variable to indicate if WaitDINXFunction runs out of time
	//! 
	//! \type int type variable
	//- -
	int 	timeOverrun = 0;	
	
	//- - 
	//! \brief  Global variable stores the size of the transmitted message
	//! 
	//! \type long type variable
	//- -
    long     ByteSize;
	
	//- - 
	//! \brief  Global variable to save the count of received message bytes
	//! 
	//! \type long type variable
	//- -	
	long    ResponseLength = 0;
    
	//- - 
	//! \brief  Global variable to handle to switch within the TP Rx routines
	//! 
	//! \type long type variable
	//- -		
    long 	routineHandle = 0;
	
	//- - 
	//! \brief  Global variable to store the value of a signal so it could be restored later.
	//! 
	//! \type long type variable
	//- -
    long     StoredSignalValue;
	
	//- - 
	//! \brief  Global variable timer to indicate overtime
	//! 
	//! \type msTimer type variable
	//- -
	msTimer 	OverTime;
	
	//- - 
	//! \brief  Global variable times some function below
	//! 
	//! \type msTimer type variable
	//- -
	msTimer 	WaitDINXFunctionTimer;

	///@cond
	msTimer t20ms;
    msTimer t10ms; ///@endcond
	
///@cond
}///@endcond

/// @cond
on timer t10ms
{
    TestSupplyTextEvent("Minimum time delay is reached!");
    //setTimer(t10ms,10); //set timer (t20ms) to 20ms   
}/// @endcond

/// @cond
on timer t20ms
{
    TestSupplyTextEvent("Minimum time delay is reached!");
    //setTimer(t10ms,10); //set timer (t20ms) to 20ms    
}/// @endcond

///@cond
on timer WaitDINXFunctionTimer{
  TestSupplyTextEvent("WaitDINXFunction-TIMER");  // supplyes this mesage to catch with "TestWaitForTextEvent"
}

on timer OverTime{
	timeOverrun = 1;
} ///@endcond

// /// @cond
// on sysvar Diag::PlainData
// {
//     int i = 0;
//     int byteLen = 4096;
//     char c1;
//     char c2;
//     int strIndex = 0;
 
//     for (i = 0; i < elcount(RqTxStringData); i++)
//     {
//         RqTxStringData[i] = 0;
//     }
//     SysGetVariableString(sysvar::Diag::PlainData, RqTxStringData, elcount(RqTxStringData));

//     ByteSize = 0;
//     for (i = 0; i < byteLen; i++)
//     {
//         strIndex = i * 2;
//         if (RqTxStringData[strIndex] != 0)
//         {
//             c1 = RqTxStringData[strIndex];
//             c2 = RqTxStringData[strIndex + 1];
//             RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);
//             ByteSize++;
//         }
//     }
//     SID = RqTxData[0];
// }/// @endcond

/// @cond
on envVar EnvTransmitDataODX
{
    routineHandle = getValue(this);
}/// @endcond

// ----------------------------------------------------[RETURN BYTE / DWORD / INT FUNCTIONS]----------------------------------------------------

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to convert characters to byte
//!
//! \param  char c is the character to be converted
//! \param  int factor identifies the nibble of the byte. For the first nibble, the factor should be 16, for the second it should be 1
//!
//! \return The characters in byte
//- -----------------------------------------------------------------------------------------------
byte char2byte (char c, int factor)
{
    switch(c){
		case 'F':
		case 'f': return 15 * factor;
		case 'E':
		case 'e': return 14 * factor;
		case 'D':
		case 'd': return 13 * factor;
		case 'C':
		case 'c': return 12 * factor;
		case 'B':
		case 'b': return 11 * factor;
		case 'A':
		case 'a': return 10 * factor;
		case '9': return 9 * factor;
		case '8': return 8 * factor;
		case '7': return 7 * factor;
		case '6': return 6 * factor;
		case '5': return 5 * factor;
		case '4': return 4 * factor;
		case '3': return 3 * factor;
		case '2': return 2 * factor;
		case '1': return 1 * factor;
    }
    return 0;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to convert characters to decimal number
//!
//! \param  char c is the character to be converted
//! \param  int factor identifies the nibble of the byte
//!
//! \return The characters in decimal number
//- -----------------------------------------------------------------------------------------------
dword char2dec (char c, int factor)
{
    switch(c){
    case 'F':
    case 'f': return 15 * factor;
    case 'E':
    case 'e': return 14 * factor;
    case 'D':
    case 'd': return 13 * factor;
    case 'C':
    case 'c': return 12 * factor;
    case 'B':
    case 'b': return 11 * factor;
    case 'A':
    case 'a': return 10 * factor;
    case '9': return 9 * factor;
    case '8': return 8 * factor;
    case '7': return 7 * factor;
    case '6': return 6 * factor;
    case '5': return 5 * factor;
    case '4': return 4 * factor;
    case '3': return 3 * factor;
    case '2': return 2 * factor;
    case '1': return 1 * factor;
    }
    return 0;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to convert characters to decimal number
//!
//! \param  char c is the character to be converted
//! \param  int factor identifies the nibble of the byte
//!
//! \return The characters in decimal number
//- -----------------------------------------------------------------------------------------------
int char2int (char c, int factor)
{
    switch(c){
    case 'F':
    case 'f': return 15 * factor;
    case 'E':
    case 'e': return 14 * factor;
    case 'D':
    case 'd': return 13 * factor;
    case 'C':
    case 'c': return 12 * factor;
    case 'B':
    case 'b': return 11 * factor;
    case 'A':
    case 'a': return 10 * factor;
    case '9': return 9 * factor;
    case '8': return 8 * factor;
    case '7': return 7 * factor;
    case '6': return 6 * factor;
    case '5': return 5 * factor;
    case '4': return 4 * factor;
    case '3': return 3 * factor;
    case '2': return 2 * factor;
    case '1': return 1 * factor;
    }
    return 0;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to compare the previously saved seed with the actual
//!
//! \return 0 or 1 \n
//!			0: Seeds are different \n
//!			1: Seeds are identical
//!
//! \note	Preconditions: \n
//!			1. Request seed \n
//!			2. Save response \n
//!			3. Request seed again	
//- -----------------------------------------------------------------------------------------------
int compareSeedAlgo()
{
    int i, equal;
    equal = 0;
    for (i=4; i<12; i++)
    { 
        if (seedString[i] != byteString[i])
        {
            equal++;
        }
    }
    if (equal == 0)
    {   
        return 1;
    }
    else
    {
        return 0;
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Check whether the C:\TAC\TAC.conf is available and contains the given environment parameter.
//!
//! \param  char[] flag is the desired environment parameter in [] sign
//!
//! \return If the file is unavailable (0), available but the flag is invalid (-1), correct (1)
//!
//! \note	If the status is correct (1), then the correct line will be saved
//- -----------------------------------------------------------------------------------------------
int getTACConfFile(char flag[])
{
	char stringFromFile[1000];
	int flagisvalid, position;
	flagisvalid = 0;
	TACConf = openFileRead("C:\\TAC\\TAC.conf", 0);
	if(TACConf == 0)
	{
		TestStep("TAC", "The TAC configuration file was not found.");
		return 0;
	}
	else
	{
		while(fileGetStringSZ(stringFromFile, elcount(stringFromFile), TACConf) != 0) 
        {
			if((position = strstr(stringFromFile,flag)) == 0)
			{
				strncpy(TACString, stringFromFile, elcount(stringFromFile)); //Save the correct line to the TACString global variable
				flagisvalid = 1;
			}
        }
		if(flagisvalid == 0)
		{
			TestStep("TAC", "The TAC configuration file does not contain information about the %s flag.", flag);
			return -1;
		}
		else
		{
			TestStep("TAC", "The TAC configuration file was found with correct flag: %s.", flag);
			return 1;
		}
	}
}

int getTACConfFileParam(char ID[])
{
	int IDposition, IDindex;
	IDposition = 0;
	clearArray(TACStringParam);
	IDposition = strstr(TACString, ID);
	if(IDposition == -1)
	{
		TestStep("TAC","The ID '%s' was not found in the TAC configuration file.", ID);
		return 0;
	}
	else
	{
		IDposition += elcount(ID) - 1;
		IDindex = 0;
		while((TACString[IDposition] != ';') || (IDposition > elcount(TACString)))
		{
			TACStringParam[IDindex] = TACString[IDposition];
			IDindex++;
			IDposition++;
		}
		return 1;
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Escapes character-sequence, the result stored in a global variable temporary
//!
//! \param  char path[] the path to escape
//!
//! \return int returns the number of escaped char
//- -----------------------------------------------------------------------------------------------
int pathEscape(char path[])
{
    int i;
    int ret;
    char escapedPath[500];
    
    ret = 0;
    clearArray(escapedPath); // clear char array
    clearArray(command_buffer); // clear char array
    
    // TestStep("escapedPath", escapedPath );
    // TestStep("command_buffer", command_buffer );
    
    for(i = 0; i<strlen(path)+1; i++)
    {
        if ( path[i] == '\\' ) 
        {
            escapedPath[strlen(escapedPath)] = '\\';
            ret = ret + 1;
        }
        escapedPath[strlen(escapedPath)] = path[i];
        escapedPath[strlen(escapedPath)] = '\0';
		//TestStep("escapedPath", escapedPath );
    }
    strncpy(command_buffer, escapedPath, 500);
    clearArray(path); // clear char array

    
    // TestStep("escapedPath", escapedPath );
    // TestStep("command_buffer", command_buffer );
    
    return ret;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Reads the file, then the corresponding value
//! 		The value, and the file itself are in global variable
//!
//! \param  char module[] the selected module of the DINX signal
//! \param  char name[] the name of the searched DINX signal
//!
//! \return Read current value was successful or not
//- -----------------------------------------------------------------------------------------------
int ReadCurrentValueIsSuccessful(char module[],char name[], int sync_state)
{
  //char nullStr[2] = ""; //empty string to set zero char arrays
  dword fileHandle;
  int state;
  int position;
  int i;
  int j;
  
  fileHandle = 0;
  state = 0;
  position = 0;
  i = 0;
  j = 0;
  
  //state = SyncIsSuccessful(module);
  
  //--------------------- If the sync was successful -------------------------//
  if ( sync_state == 1 )
  {
    setWritePath( "c:\\unilogger\\" );
    fileHandle = OpenFileWrite( "sync_state.txt", 0 ); //0: ASCII, 1:bin, 2:append ASCII, 3: append bin
    filePutString( "0", elcount("0"), fileHandle );
    fileClose ( fileHandle );
    
    // Clear the prev stored values
    clearArray(dinx_buffer);
    clearArray(FileBuffer);
    clearArray(currValue);

    // open the ADTF output file
	setFilePath( "c:\\unilogger\\", 0 );
    fileHandle = OpenFileRead( "adtf_out.csv", 0 ); //0:ASCII mode, 1:BIN mode
    if( fileHandle == 0)
    {
      write( "Cannot open file: adtf_out.csv" );
      state = -1;
    }
    else
    {
      //--------------------- Read the full file -------------------------//
	  state = 1;
      while (fileGetString(dinx_buffer,elcount(dinx_buffer),fileHandle)!=0)
      {
        strncat(FileBuffer, dinx_buffer, elcount(FileBuffer));
      }
	  fileClose ( fileHandle );
      snprintf(dinx_buffer, elcount(dinx_buffer), "");
      
      //--------------------- Get the value of the parameter -------------------------//
      //toLower(name,name,elcount(name));
      position=strstr(FileBuffer,name);
      //write("pos: %d",position);
      if (position == -1){  // ADDED 2016.09.19 15:00 There was a not handled exception
        testStepFail("ERROR","The requested DINX was NOT found!");
      }
      
      while(FileBuffer[position]!='\n' && position!= -1)
      {
        if(j==1)
        {
          currValue[i]=FileBuffer[position];
          i++;
        }
        if(FileBuffer[position]==';')j++;
        position++;
        //write("pos: %d",position);
      }
      //write("currVal:%s",currValue);
    }
	fileClose ( fileHandle );
  }
  else
  {
	state = 0;
    write("Sync error (state != 1)");
  }
  return state;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to check whether response received and the response match or not
//!	
//! \param  char CompareMode is the compare mode should be used to check the response
//! \param  char Response is the expected response
//! \param  int NumberRPs is the count of the arrived response pendings
//! \param  char MessageFormat identifies the response type. (Response or NRC)
//! \param  long Result identifies that response is received or not. (0 = not received, 1 = received)
//!
//! \return If the expected response is received, the function returns with 1 and test step passed state, otherwise with 0 and test step failed state
//!
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- NotEqual_Regexp: The received response substring is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//- -----------------------------------------------------------------------------------------------
int responseMatching(char CompareMode[], char Response[], int NumberRPs, char MessageFormat[], long Result)
{
	if(Result == 1)
	{
		TestStep("INFO","EXPECTED: %s", Response);
		TestStep("INFO","RECEIVED: %s", byteString);
		//Message received, Compare mode is equal
		if(0 == strncmp("Equal", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
			{
				TestStepPass("INFO","Expected %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is regexp
		else if(0 == strncmp("Regexp", CompareMode,strlen(CompareMode)))
		{   
			if(1 == str_match_regex(byteString, Response))
			{
				TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is not equal
		else if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)) || 0 == strncmp("NotEqual_Regexp", CompareMode, strlen(CompareMode)))
		{
			if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)))
			{
				if(0 != strncmp(byteString, Response, strlen(Response)) || strlen(byteString) != strlen(Response))
				{
					TestStepPass("INFO","Not equal %s received as expected!", MessageFormat);
					return 1;
				}
				else
				{      
					TestStepFail("INFO","Unexpected equal %s is received!", MessageFormat);
					return 0;
				}
			}
			else
			{
				if(0 == str_match_regex(byteString, Response))
				{
					TestStepPass("INFO","Wrong substring in %s received as expected!", MessageFormat);
					return 1;
				}
				else
				{
					TestStepFail("INFO","Unexpected %s with correct substring received!", MessageFormat);
					return 0;
				}
			}
		}
		//Message received, Compare mode is suppressed (equal or regexp)
		else if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp("response", MessageFormat,strlen(MessageFormat)))
			{
				if(NumberRPs > 0)
				{
					if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
					{
						if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
						{
							TestStepPass("INFO","Expected %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","Unexpected %s received after response pending!", MessageFormat);
							return 0;
						}
					}
					else
					{
						if(1 == str_match_regex(byteString, Response))
						{
							TestStepPass("INFO","Expected substring in %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","There is not expected substring after response pending in %s!", MessageFormat);
							return 0;
						}
					}
				}
				else
				{
					TestStepFail("INFO","Response received without response pending!");
					return 0;
				}
			}
			else
			{
				if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
				{
					if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
					{
						TestStepPass("INFO","Expected %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","Unexpected %s received!", MessageFormat);
						return 0;
					}
				}
				else
				{
					if(1 == str_match_regex(byteString, Response))
					{
						TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","There is not expected substring in %s!", MessageFormat);
						return 0;
					}
				}	
			}
		}
		//Message received, Compare mode is regexpNoFailed
		else if(0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode)))
		{   
			if(1 == str_match_regex(byteString, Response))
			{
				TestStep("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStep("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepFail("INFO","Response arrived but it was NOT expected!");
			return 0;
		}
	}
	else
	{
		//Message does not received, Compare mode is suppressed (equal or regexp)
		if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(NumberRPs == 0)
			{
				TestStepPass("INFO","No response pending and no response are received as expected!");
				return 1;
			}
			else
			{
				TestStepFail("INFO","No response is received after response pending!");
				return 0;
			}
		}
		//Message does not received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepPass("INFO","Response did not arrive as expected!");
			return 1;
		}
		//Message does not received, Compare mode is not supported here
		else
		{
			TestStepFail("INFO","Timeout while waiting for diag response");
			return 0;
		}
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Set the programmable voltage supply settings from TAC.conf file
//!
//! \return Successful (if the C:\TAC\TAC.conf is available = 1) or not (the file C:\TAC\TAC.conf is not found or incorrect = 0 and do nothing
//- -----------------------------------------------------------------------------------------------
int SetVoltageFromTAC()
{
	int TACload;
	TACload = getTACConfFile("[SUPPLY]");
	if((TACload == 0) || (TACload == -1))
	{
		return 0;
	}
	else
	{
		if(getTACConfFileParam("PORT=") == 1) //PORT
		{
			putValue(EnvVoltComPort, atol(TACStringParam));
		}
		else
		{
			TestStep("TAC","The supply port is missing from TAC: 'PORT=', therefore the default settings will be used.");
			return 0;
		}
		if(getTACConfFileParam("SUPPLYSELECTOR=") == 1) //SUPPLYSELECTOR
		{
			putValue(EnvVoltageSupplySelector, atol(TACStringParam));
		}
		else
		{
			TestStep("TAC","The supply selector is missing from TAC: 'SUPPLYSELECTOR=', therefore the default settings will be used.");
			return 0;
		}
		if(getTACConfFileParam("CHANNEL=") == 1) //CHANNEL
		{
			putValue(Env_VoltBKChannel, atol(TACStringParam));
		}
		else
		{
			TestStep("TAC","The supply channel is missing from TAC: 'CHANNEL=', therefore the default settings will be used.");
			return 0;
		}
		if(getTACConfFileParam("RELEASE=") == 1) //RELEASE
		{
			putValue(Env_VoltBKRelease, atol(TACStringParam));
		}
		else
		{
			TestStep("TAC","The supply release is missing from TAC: 'RELEASE=', therefore the default settings will be used.");
			return 0;
		}
		if(getTACConfFileParam("VOLTBKSTAT=") == 1) //VOLTBKSTAT
		{
			putValue(Env_VoltBKStat, atol(TACStringParam));
		}
		else
		{
			TestStep("TAC","The voltbkstat is missing from TAC: 'VOLTBKSTAT=', therefore the default settings will be used.");
			return 0;
		}
		if(getTACConfFileParam("VOLT=") == 1) //VOLT
		{
			putValue(Env_VoltBKSet, atol(TACStringParam));
		}
		else
		{
			TestStep("TAC","The supply voltage is missing from TAC: 'VOLT=', therefore the default settings will be used.");
			return 0;
		}
		return 1;
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Syncs with the corresponding files
//!
//! \param  char module[] contains the module needed for sync
//!
//! \return File SYNC was successful or not
//- -----------------------------------------------------------------------------------------------
int SyncIsSuccessful(char module[])
{
  dword fileHandle;
  int state;
  int i;
  int j;
  //char nullStr[2] = "";
  
  fileHandle = 0;
  state = 0;
  i = 0;
  j = 0;
  
  /*------------------------- write sync name -------------------------*/
  setWritePath( "c:\\unilogger\\" );
  if ( fileHandle == 0 )
  {
    for(i = 0; i < 5; i++)
    {
      //setTimer(t, 100); //set timer to 100ms
      TestWaitForTextEvent("Timer", 10); // wait for 10ms
      fileHandle = OpenFileWrite( "sync_name.txt", 0 );
      if ( fileHandle != 0 ) //break if the file is accessible
      {
        break;
      }
    }
  }

  if( i < 5 )
  {
    filePutString( module, elcount(module), fileHandle ); //write ID from function argument
    fileClose ( fileHandle );
  }
  else
  {
    write( "Cannot create file: sync_name.txt" );
  }

  //--------------------- wait for ADTF -------------------------//
  j = 0;
  i = 0;
  fileHandle = 0;
  while( (state == 0) && (j < 10) ) // j: number of cycle
  {
    TestWaitForTextEvent("Timer", 50); // wait for 50-100ms <- ez a sor esszencialis, ezzel varjuk meg, h az ADTF feldolgozzon!!! ("eleg idot hagyunk neki")

    //Try to open ATDF status file
	setFilePath( "c:\\unilogger\\", 2 );
    fileHandle = OpenFileRead( "sync_state.txt", 0 ); //0:ASCII, 1:bin
    if( fileHandle == 0 )
    {
      for(i = 0; i < 4; i++)
      {
        TestWaitForTextEvent("Timer", 10); // wait for 10ms
        fileHandle = OpenFileRead( "sync_state.txt", 0 ); //0:ASCII, 1:bin
        if ( fileHandle != 0 ) //break if the file is accessible
        {
          break;
        }
      }
    }

    //Read (ADTF) status
    if( i < 5 )
    {
      //set arrays to zero
      clearArray(FileBuffer);

      //read file
      fileGetString( FileBuffer, elcount( FileBuffer ), fileHandle );
      fileClose( fileHandle );

      //check status
      if( strncmp( "1", FileBuffer, elcount("1")) == 0 )
      {
        // write( "File SYNC was successful!" );
        state = 1;
        
        // set the sync state back
        /*setWritePath( "c:\\unilogger\\" );
        fileHandle = OpenFileWrite( "sync_state.txt", 0 ); //0: ASCII, 1:bin, 2:append ASCII, 3: append bin
        filePutString( "0", elcount("0"), fileHandle );
        fileClose ( fileHandle );*/
      }
      else
      {
        state = 0;
      }
    }
    else // This means the file could not opened
    {
      write( "Cannot open file: sync_state.txt" );
    }
    j++;
  }
  return state;
}

// ----------------------------------------------------[VOID FUNCTIONS]----------------------------------------------------

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to convert the response to ASCII format
//!
//! \param  data the byte array for the conversion
//! \param  startbyte the number of the byte which is the first byte to be converted in the data array
//! \param  endbyte the number of the byte which is the last byte to be converted in the data array
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
BytetoAscii(byte data[], int startbyte, int endbyte)
{
	int index;
	byte UsedData[8194];
	
	if(startbyte <= endbyte)
	{
		for(index = 0; index < (endbyte-startbyte); index++)
		{
			UsedData[index] = data[startbyte+index];
		}
		mostStringToAscii(UsedData, elcount(UsedData), AsciiData, elcount(AsciiData));
	}
	else
	{
		write("Failure during the ASCII conversion!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to convert char array to byte array
//!
//! \param  char convertable_array is the request diagnostic character string
//!
//! \return No return value
//!
//! \note	It is necessary to convert the char array to byte array before sending it out with the inside Vector function. \n
//!			This function converts the request string to a compatible byte array to send for the camera and calculates the byte size. \n
//!			This byte array is a global variable.
//! \note	The parameter character string should contain only numbers and lowercase letters.
//- -----------------------------------------------------------------------------------------------
CharArray2Byte(char convertable_array[])
{
    int i;
    char c1,c2;
    int strIndex;
    
    strIndex = 0;
    
    for (i = 0; i < elcount(RqTxStringData); i++)
	{
		RqTxStringData[i] = 0;
	} 
   
    for (i = 0; i < elcount(convertable_array); i++)
    {
		RqTxStringData[i] = convertable_array[i];     //RqTxStringData is a global variable
    }

    ByteSize = 0;  //ByteSize is a global variable
    for (i = 0; i < (strlen(RqTxStringData)/2); i++)
    {
        strIndex = i * 2;  
        c1 = RqTxStringData[strIndex];
        c2 = RqTxStringData[strIndex + 1];
        RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);     // RqTxData is a global variable
        ByteSize++;
    }
    SID = RqTxData[0];
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Clears a specified character array
//!
//! \param  char string[] the string to be clear
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
clearArray(char string[])
{
  int i;
  
  for(i=0; string[i]!='\0'; ++i)
  {
    string[i] = '\0';
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that stores one byte in the byteString variable
//!
//! \param  byte response is the byte that should be converted
//! \param  char char is the character array where the byte should be stored
//! \param  long base is the number base of the byte
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
CreateByteCharacter (byte response, char s[], long base)
{
    char intString[3];
    char catString[3];

    snprintf(s, elcount(s), "");

    ltoa(response, intString, base);

    if( 1==strlen(intString) )
    {
        snprintf(catString, elcount(catString), "0");
        strncat(catString, intString, elcount(catString));
        strncpy(intString, catString, elcount(intString));
    }
   
    strncat(s, intString, elcount(intString));
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that stores the arrived response in the byteString variable
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
CreateByteString (byte response[], long offset,long responseLength)
{
    char intString[1023];
    char catString[10];
    int i=0;
    long dataLength;

    snprintf(byteString, elcount(byteString), "");
    dataLength = responseLength;

    for(i=offset; i < dataLength;i++)
    {
        ltoa(response[i], intString, 16);

        if( 1==strlen(intString) )
        {
            snprintf(catString, elcount(catString), "0");
            strncat(catString, intString, elcount(catString));
            strncpy(intString, catString, elcount(intString));
        }
       
        strncat(byteString, intString, elcount(byteString));
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Convert decimal value to binary and store it in "BinaryNumber" array
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
Dec2Binary(long DecNumber)
{
	int i;
	long k;
	int result;
	i = 31;
	clearArray(BinaryNumber);
	for (i; i >= 0; i--)
	  {
		k = _pow(2, i);
		result = DecNumber/k; 
		if(result >=1)
		{
			BinaryNumber[i] = '1';
			DecNumber=DecNumber-k;
		}
		else BinaryNumber[i] = '0';
	  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Convert hexadecimal value to binary and store it in "BinaryNumber" array
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
Hexa2Binary(char HexNumber[])
{
	int i;
	char buffer[5];
  
    i=0;
	clearArray(BinaryNumber);
	
	while(HexNumber[i])
	{
		if(HexNumber[i]=='0') strncpy(buffer,"0000",5);
		else if(HexNumber[i]=='1') strncpy(buffer,"0001",5);
		else if(HexNumber[i]=='2') strncpy(buffer,"0010",5);
		else if(HexNumber[i]=='3') strncpy(buffer,"0011",5);
		else if(HexNumber[i]=='4') strncpy(buffer,"0100",5);
		else if(HexNumber[i]=='5') strncpy(buffer,"0101",5);
		else if(HexNumber[i]=='6') strncpy(buffer,"0110",5);
		else if(HexNumber[i]=='7') strncpy(buffer,"0111",5);
		else if(HexNumber[i]=='8') strncpy(buffer,"1000",5);
		else if(HexNumber[i]=='9') strncpy(buffer,"1001",5);
		else if(HexNumber[i]=='a') strncpy(buffer,"1010",5);
		else if(HexNumber[i]=='b') strncpy(buffer,"1011",5);
		else if(HexNumber[i]=='c') strncpy(buffer,"1100",5);
		else if(HexNumber[i]=='d') strncpy(buffer,"1101",5);
		else if(HexNumber[i]=='e') strncpy(buffer,"1110",5);
		else if(HexNumber[i]=='f') strncpy(buffer,"1111",5);
		strncat(BinaryNumber,buffer,elcount(BinaryNumber));
		i++;
	}
}

//- ----------------------------------------------------------------------------------------------------
//! \brief  Function to prepare a playlist should be played in ADTF
//!
//!	\param  char measurementFolder[] is the the folder that contains the MEA
//! \param  char sequenceName[] is the sequence file. If you start ADTF in StartStopRecording mode, use "" or "-"
//!
//! \return No return value
//!
//! \note   You should give the full path of the folder with double backslashes, like this:
//! 		"c:\\Users\\abd2bp\\Documents\\Messtechnik\\JLR_143_RC02"
//- ----------------------------------------------------------------------------------------------------
preparePlaylist(char measurementFolder[], char sequenceName[])
{
  dword fileHandle;
  
  setWritePath(measurementFolder);
  fileHandle=openFileWrite("playlist.datpls",0);
  filePutString("c:\\temp\\",elcount("c:\\temp\\"),fileHandle);
  filePutString(sequenceName,elcount(sequenceName),fileHandle);
  fileClose(fileHandle);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Reverse the parameter string value and store it in "BinaryNumber" array
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
reverseString(char string[])
{
	int i;
	int length;
	char temp[32];
	
	i=0;
	length=0;
	while(string[i] != '\0')
	{
		length++;
		i++;
	}
	i=0;
	while(string[i] != '\0')
	{
		temp[i] = string[length-i-1];
		i++;
	}
	
	strncpy(BinaryNumber,temp,elcount(BinaryNumber));
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to save the previously received response to a global variable
//!
//! \return No return value
//- -----------------------------------------------------------------------------------------------
saveResponse()
{
    int i;
    for (i=1; i<8194; i++)
    { 
        seedString[i] = byteString[i];
        seedData[i] =  RsRxIntData[i];
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to send key to the camera based on the previously saved seed in the plant mode
//! 			
//! \param  char sendKey is the request to send the calculated key
//! \param  char sendKeyResponse is the expected response should be awaited
//! \param  dword RBEOLPin is used to define RBEOL unique pin
//! \param  dword PMARequest is used to define the plant mode activation part2 request
//! \param  char CompareMode is the compare mode should be used to check the response for the sent key
//!			
//! \return No return value
//!
//! \note	The tester requests a seed from the ECU and uses it to calculate the key using a specified formula. \n
//!			After the key calculation the function will send the key to the ECU and check the response.
//- -----------------------------------------------------------------------------------------------
sendKeyAlgoRBEOL(char sendKey[], char sendKeyResponse[], dword RBEOLPin, dword PMARequest, char CompareMode[])
{
	dword authKey;
	byte resultarray[6] = {0,0,0,0,0,0};
      
	resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
	resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);
      
	authKey = seedData[5] |
			(seedData[4] << 8) |
			(seedData[3] << 16) |
			(seedData[2] << 24);
               
	authKey = authKey & RBEOLPin; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
	authKey = authKey | PMARequest; //Plant mode activation part request
      
	resultarray[5] = (byte)(authKey & 0xff);
	resultarray[4] = (byte)((authKey >> 8) & 0xff);
	resultarray[3] = (byte)((authKey >> 16) & 0xff);
	resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
	CreateByteString(resultarray, 0, elcount(resultarray));

	RequestResponseCompareLogic(byteString, sendKeyResponse, CompareMode);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to set the CAN transmit and receive message IDs
//!	
//! \param  int rxId is the ID of the transmit messages in CAN.
//! \param  int txId is the ID of the receive messages in CAN.
//!
//! \return No return value
//!
//! \note	This function can set the CanIDs for the transmission of messages.
//! \note	The parameters should be hexadecimal values and compatible with normal addressing mode.
//- -----------------------------------------------------------------------------------------------
setType(int rxId, int txId)
{
	OSEKTL_SetTxId(txId);   
	OSEKTL_SetRxId(rxId);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to copy a substring of src to dest. The substring can be found between the given positions in src.
//!
//!	\param	char dest The destination buffer.
//!	\param	char src The source string.
//!	\param	long srcStart The start position of the substring.
//!	\param	long srcEnd The end position of the substring.
//!	\param	long max The size of dest.
//!
//! \return No return value
//!
//!	\note	The substring will exclude the characters from the 2 given char positions.
//- -----------------------------------------------------------------------------------------------
substr_cpy_pos(char dest[], char src [], long srcStart, long srcEnd, long max)
{
  long len;
	
  
  if (srcStart !=0)
  {
    len = srcEnd - srcStart - 1;
    srcStart = srcStart + 1;
  } 
  else
  {
    len = srcEnd - srcStart;
  }
	
  substr_cpy (dest, src, srcStart, len, max);
}

//- ----------------------------------------------------------------------------------------------------
//! \brief  Function to wait for an ADTF or HIL sequence start
//!
//! \return adtf_started: indicates if the ADTF measurement started or not
//- ----------------------------------------------------------------------------------------------------
WaitForADTFStartFunction(char adtf_started[])
{
	dword fileHandle;
	int i;
	 //waiting for ADTF to start
	setFilePath("c:\\unilogger",2);
	i=0;
	while(strncmp(adtf_started,"1",elcount(adtf_started) != 0) && i<4500)
	{
		fileHandle=openFileRead("adtf_phase.txt",0);
		fileGetString(adtf_started,elcount(adtf_started),fileHandle);
		fileClose(fileHandle);
		TestWaitForTimeout(200);
		i++;
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to wait for the occurrence of the next specific message
//!
//! \param  dword MessageID is the ID of the message that should be awaited
//! \param  long Timeout is the maximum time that should be waited [ms]
//!
//! \return No return value
//!
//! \note	The testcase searches the CAN channel the message is sent on.
//- -----------------------------------------------------------------------------------------------
WaitForMessageFunction(dword MessageID, long Timeout)
{
    long result;
  
    result = 0;

	result = TestWaitForMessage(MessageID, Timeout);      

  if (result == 1)
  {
    // Signal with expected value arrived!      
		TestStepPass("INFO","The message arrived");
	}
	else if (result == 0)
	{ 
    // Timeout occured!       
		TestStepFail("INFO","The message has not arrived within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Constraint violation!");
	}
	else
	{
		TestStepFail("INFO","General error!");
	}
}

// ----------------------------------------------------[TESTCASE / VOID FUNCTIONS]----------------------------------------------------

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to check that the given signal doesn't get the given value
//!
//! \param  signal signalName is the name of the signal which is tested
//! \param  float signalValue is the value of the tested signal should not get
//! \param  long Timeout is the timeout for the test
//! 
//! \teststep Check the $1 signal's value (avoid the specified value)
//! \testresponse The signal's value shouldn't be equal with $2
//! 
//! \note 	! The function considers the resolution of the signal !
//- -----------------------------------------------------------------------------------------------
testcase AvoidSignalValue (signal * signalName,  float signalValue, long Timeout)
{
    AvoidSignalValueFunction(signalName, signalValue, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to check that the given signal doesn't get the given value
//!
//! \return No return value
//!
//! \note 	See description of testcase AvoidSignalValue().
//- -----------------------------------------------------------------------------------------------
AvoidSignalValueFunction (signal * signalName,  float signalValue, long Timeout)
{
    long result;
    float signalActualValue;

    result = 0;
    signalActualValue = 0;
    
    result = TestWaitForSignalMatch (signalName, signalValue, Timeout);
	signalActualValue = getSignal(signalName);
  
    if (result == 1)
    {
        // Signal with expected value arrived!      
        TestStepFail("INFO","The signal got the value ( %f) within the timeout period!", signalValue);
        TestStep("INFO","The signal has the following value: %f,", signalActualValue);
		TestStep("INFO","If there is a difference between the desired and the actual value, it must be resolution problem. Check the DBC.");
    }
    else if (result == 0)
    { 
        // Timeout occured!   
        TestStepPass("INFO","The signal did not get the value ( %f ) within the timeout period!", signalValue);  
    }
    else if(result == -2)
    {
        TestStepFail("INFO","Signal is not valid");
    }
    else
    {
        TestStepFail("INFO","General error");
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to turn off and on the camera
//!
//! \param  int timeout is the waiting time after the hard reset
//! 
//! \teststep Perform HardReset and wait $1ms
//! \testresponse -
//- -----------------------------------------------------------------------------------------------
testcase cameraHardReset(int WaitTime)
{
	putValue(Env_VoltBKStat,0);
	TestWaitForTimeout(1000);
	putValue(Env_VoltBKStat,1);
	TestWaitForTimeout(WaitTime);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to turn off and on the camera
//!
//! \param  int timeout is the waiting time after the hard reset
//! 
//! \teststep Perform HardReset and wait 7s
//! \testresponse -
//- -----------------------------------------------------------------------------------------------
testcase cameraHardReset()
{
	putValue(Env_VoltBKStat,0);
	TestWaitForTimeout(1000);
	putValue(Env_VoltBKStat,1);
	TestWaitForTimeout(7000);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to change to the given CAN channel
//!
//! \param  char CanChannel is the name of the CAN channel we want to change to
//! 
//! \teststep Change the CAN channel to $1   
//! \testresponse -
//!
//! \note	The ID of the original CAN channel is saved so it can be restored later.
//! \note	Available CAN Channels are: \n
//!     		E_Can\n
//!     		SF_Can\n
//- -----------------------------------------------------------------------------------------------
testcase ChangeCanChannel(char CanChannel[])
{
  ChangeCanChannelFn(CanChannel);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to change to the given CAN channel
//!
//! \return No return value
//!
//! \note	See description of testcase ChangeCanChannel().
//- -----------------------------------------------------------------------------------------------
ChangeCanChannelFn(char CanChannel[])
{
  dword BusContext;
  dword ECanBusContext;
  dword FSCanBusContext;
  
  ECanBusContext = 0x10001;
  FSCanBusContext = 0x10002;
  
  StoredBuxContext = GetBusContext(); //Store CAN bus channel context

  if (0 == strncmp("E_Can", CanChannel,strlen(CanChannel)))
  {
    BusContext = GetBusContext();
    
    if(ECanBusContext != BusContext)
    {
      canOffline(3); 
      SetBusContext(ECanBusContext);
      canOnline(3);
      
      testStepPass("INFO","Switched to %s channel.", CanChannel);
    }
    else 
    {
      testStepPass("INFO","The %s channel was already selected.", CanChannel);
    }
  }
  else if (0 == strncmp("SF_Can", CanChannel,strlen(CanChannel)))
  {
    BusContext = GetBusContext();
    
    if(FSCanBusContext != BusContext)
    {
      canOffline(3); 
      SetBusContext(FSCanBusContext);
      canOnline(3);
      
      testStepPass("INFO","Switched to %s channel.", CanChannel);
    }
    else 
    {
      testStepPass("INFO","The %s channel was already selected.", CanChannel);
    }
  }
  else
  {
    TestStepFail("INFO","The channel is not valid!");
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given bit of the CAN signal is equal to the given value (0 or 1)
//!
//! \param  char signal[] the name of the searched CAN signal
//! \param  char value[] the expected value of the needed bit 
//! \param  int bit the number of the bit you have to check (0 is the lowest bit)
//! 
//! \teststep Check $1 CAN signal's $3 bit
//! \testresponse The $1 CAN signal's $3 bit equals with $2
//!
//! \note The value pramaeter can be only 0 or 1.
//- -----------------------------------------------------------------------------------------------
testcase CheckCANBit(char signalName[], char value[], int bit)
{
  CheckCANBitFunction(signalName, value, bit);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given bit of the CAN signal is equal to the given value (0 or 1)
//!
//! \return No return value
//!
//! \note See description of testcase CheckCANBit().
//- -----------------------------------------------------------------------------------------------
CheckCANBitFunction(char signalName[], char value[], int bit)
{ 
  int currentValue=0;
  char CanValue[20];
  
  //if signal is wrongly given convert to upper case
  toUpper(signalName,signalName,elcount(signalName));

  // read the signal actual value
  currentValue = getSignal(signalName);
  write("signalvalue:%d",currentValue);
  
  //For debug
  //write("Signal value is: %d", currentValue);
  Dec2Binary(currentValue); 
	write("Signal binary value is %s", BinaryNumber);  
  /*ltoa(currentValue,CanValue,16);

  Hexa2Binary(CanValue);       //change Signal value to binary form
  //For debug
  
  reverseString(BinaryNumber); //need to reverse the binary string to get the correct value*/
  
  //--------------------- Check if the given bit's value is equal to the expected value (of the bit) -------------------------//
  if(value[0] != '1' && value[0] != '0') TestStepFail("INFO","Wrong value was given to value parameter! It has to be 0 or 1!");
  else if(BinaryNumber[bit] == value[0]) TestStepPass("INFO","The value of the (%i). bit of (%s) signal is equal with the expected value (%c).  OK", bit, signalName, value[0] );
  else TestStepFail("INFO","The value of the (%i). bit of (%s) signal isn't equal with the expected value (%c).  FAIL", bit, signalName, value[0] );
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given CAN signal is changes its value from startValue to 
//! expectedValue in the given monitoringTime
//!
//! \param  char messageName[] the CAN message that contains the signal
//! \param  char signalName[] the name of the monitored CAN signal
//! \param  int startValue the start value of the signal  
//! \param  int expectedValue the expected value of the signal 
//! \param  int monitoringTime the time interval until the signal value has to change [ms]
//! \param  int sampleTime the time interval which represents the signal cycle time. Sample is taken when a signal is received [ms]
//! 
//! \teststep Check CAN signal $2 from message $1
//! \testresponse The $2 signal changes its value from $3 to $4 until $5 ms elapses
//- -----------------------------------------------------------------------------------------------
testcase CheckCANValueChange(char messageName[], char signalName[], int startValue, int expectedValue, int monitoringTime, int sampleTime)
{
  CheckCANValueChangeFunction(messageName, signalName, startValue, expectedValue, monitoringTime, sampleTime);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given CAN signal is changes its value from startValue to 
//! expectedValue in the given monitoringTime
//!
//! \return No return value
//!
//! \note See description of testcase CheckCANValueChange().
//- -----------------------------------------------------------------------------------------------
CheckCANValueChangeFunction(char messageName[], char signalName[], int startValue, int expectedValue, int monitoringTime, int sampleTime)
{ 
  int currentValue=0;
  char CanValue[50];
  int timeout = 0;
  int counter = 0;
  
  clearArray(CanValue);
  
  //if signal is wrongly given convert to upper case
  toUpper(signalName,signalName,elcount(signalName));

  // read the signal actual value
  strncat(CanValue, messageName, elcount(CanValue));
  strncat(CanValue, "::", elcount(CanValue));
  strncat(CanValue, signalName, elcount(CanValue));
  
  write("Signal to be checked: %s", CanValue);
  
  currentValue = getSignal(CanValue);
  
  //For debug
  write("Signal %s value is: %d", signalName, currentValue);
  
  //signal value is not equal to startValue - monitoring starts with wrong condition
  if(currentValue != startValue)
  {
	TestStepFail("INFO","The CAN signal: (%s) value: (%i) is NOT EQUAL the expected start value: (%i)", signalName, currentValue, startValue);
  }else
  {
    while(timeout != 1)
    {
	  TestWaitForTimeout(sampleTime);
	  currentValue = getSignal(CanValue);
	  if(currentValue == expectedValue && counter <= monitoringTime)
	  {
	  	counter += sampleTime;
		write("Counter value: %i", counter);
	  	TestStepPass("INFO","The CAN signal: (%s) value: (%i) is equal to the expected value ((%i)). OK", signalName, currentValue, expectedValue);
	  	timeout = 1;
	  }
	  else if(currentValue != expectedValue && counter <= monitoringTime)
	  {
	  	counter += sampleTime;
	  	write("Not equal yet. Counter value: (%i)", counter);
	  }
	  else if(currentValue != expectedValue && counter > monitoringTime)
	  {
		write("Counter value: %i", counter);
	  	TestStepFail("INFO","The CAN signal: (%s) value does not reached (%i) in (%i) time(ms) specified in test case. FAIL.", signalName, expectedValue, monitoringTime);
	  	timeout = 1;
	  }
    }
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compares the value with the signal's actual value
//!   There are multiple modes (defined with the type parameter)
//!
//! \param  char type[] can contains "Equal" "NotEqual" or a number (the minimal value)
//! \param  char module[] the name of the tested module
//! \param  char name[] the name of the searched DINX signal
//! \param  char value[] the expected value or maximal value
//! 
//! \teststep Check $3 DINX signal
//! \testresponse The $3 signal has correct value 
//- -----------------------------------------------------------------------------------------------
testcase CheckDINX(char type[], char module[], char name[], char value[])
{
  CheckDINXFunction( type, module, name, value);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compares the value with the signal's actual value
//!   There are multiple modes (defined with the type parameter)
//!
//! \return No return value
//!
//! \note See description of testcase PVWCheckDINX() / CheckDINX().
//- -----------------------------------------------------------------------------------------------
CheckDINXFunction(char type[], char module[], char name[], char value[]){
  
  int sync_state;
  int read_state;
  double currentValue;
  double lowLimit;
  double highLimit;

  sync_state = 0;
  read_state = 0;
  currentValue=0;
  lowLimit=0;
  highLimit=0;
  clearArray(currValue);
  // fills up buffer, with the actual value
  sync_state = SyncIsSuccessful(module);
  read_state = ReadCurrentValueIsSuccessful(module,name,sync_state);
  if ( read_state == 1 )
  {
    TestStep("INFO","Sync and read was successful.");
  }
  else if ( read_state == -1 )
  {
    TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
  }
  else if ( read_state == 0 )
  {
    TestStepFail("INFO","Sync wasn't successful! ERROR");	
  }
  
  currentValue=atodbl(currValue);
  lowLimit=atodbl(type);
  highLimit=atodbl(value);
  
  //--------------------- The expected value is equal with the actual value -------------------------//
  if(read_state == 1)
  {
	  if(strncmp(type,"Equal",elcount(type))==0)
	  {
		if(strncmp(currValue,value,elcount(value))==0)
		{
		  TestStepPass(name,"The value of the actual variable (%f) is equal with the expected value (%f).  OK", currentValue, highLimit );
		}
		else if(currentValue==highLimit)
		{
		  TestStepPass(name,"The value of the actual variable (%f) is equal with the expected value (%f).  OK", currentValue, highLimit );
		}
		else
		{
		  TestStepFail(name,"The value of the actual variable (%f) isn't equal with the expected value  (%f).  FAILED", currentValue, highLimit );
		}
	  }
	  
	  //--------------------- The expected value should be NOT equal with the actual value -------------------------//
	  else if(strncmp(type,"NotEqual",elcount(type))==0)
	  {
		if(strncmp(currValue,value,elcount(value))==0)
		{
		  TestStepFail(name,"The value of the actual variable (%f) is equal with the forbidden value (%f).  FAILED", currentValue, highLimit);
		}
		else if(currentValue==highLimit)
		{
		  TestStepFail(name,"The value of the actual variable (%f) is equal with the forbidden value (%f).  FAILED", currentValue, highLimit);
		}
		else
		{
		  TestStepPass(name,"The value of the actual variable (%f) isn't equal with the forbidden value  (%f).  OK", currentValue, highLimit);
		}
	  }
	  
	  //--------------------- The actual value should be in range within the type value and the expected value -------------------------//
	  else 
	  {
		//If type is a number, it's the lower limit of the range, if not: FAIL
		if(strstr_regex(type,"^(((0x)[0-9A-Fa-f]+)|([+,-]*[0-9]+)|([+,-]*[0-9]+\\.[0-9]+))$") == -1)
		{
		  TestStepFail("INFO","Test ERROR! - Wrong first parameter (%s)!", type);
		}
		else
		{
		  if(currentValue<=highLimit && currentValue>=lowLimit)
		  {
			TestStepPass(name,"The value of the actual variable (%f) is in the range (%f - %f).  OK", currentValue, lowLimit, highLimit );
		  }
		  else
		  {
			TestStepFail(name,"The value of the actual variable (%f) is out of range (%f - %f).  FAILED", currentValue, lowLimit, highLimit );
		  }
		}
	  }
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given bit of the DINX signal is equal to the given value (0 or 1)
//!
//! \param  char module[] the name of the tested module
//! \param  char name[] the name of the searched DINX signal
//! \param  char value[] the expected value of the needed bit 
//! \param  int bit the number of the bit you have to check (0 is the lowest bit)
//! 
//! \teststep Check $2 DINX signal's $4 bit
//! \testresponse The $2 DINX signal's $4 bit equals with $3
//!
//! \note The value pramaeter can be only 0 or 1.
//- -----------------------------------------------------------------------------------------------
testcase CheckDINXBit(char module[], char name[], char value[], int bit)
{
  CheckDINXBitFunction(module, name, value, bit);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given bit of the DINX signal is equal to the given value (0 or 1)
//!
//! \return No return value
//!
//! \note See description of testcase CheckDINXBit().
//- -----------------------------------------------------------------------------------------------
CheckDINXBitFunction(char module[], char name[], char value[], int bit)
{  
  int sync_state;
  int read_state;
  long currentValue;
  long expectedValue;
  
  sync_state = 0;
  read_state = 0;
  currentValue=0;

  // fills up buffer, with the actual value
  sync_state = SyncIsSuccessful(module);
  read_state = ReadCurrentValueIsSuccessful(module,name,sync_state);
  if ( read_state == 1 )
  {
    TestStep("INFO","Sync and read was successful.");
  }
  else if ( read_state == -1 )
  {
    TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
  }
  else if ( read_state == 0 )
  {
    TestStepFail("INFO","Sync wasn't successful! ERROR");	
  }
  currentValue = atol(currValue);
  Dec2Binary(currentValue);       //change DINX to binary form
  //reverseString(BinaryNumber);
  
  //--------------------- Check if the given bit's value is equal to the expected value (of the bit) -------------------------//
  if(value[0] != '1' && value[0] != '0') TestStepFail("INFO","Wrong value was given to value parameter! It has to be 0 or 1!");
  else if(BinaryNumber[bit] == value[0]) TestStepPass("INFO","The value of the (%i). bit of (%s) signal is equal with the expected value (%c).  OK", bit, name, value[0] );
  else TestStepFail("INFO","The value of the (%i). bit of (%s) signal isn't equal with the expected value (%c).  FAIL", bit, name, value[0] );
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to check a single FID value
//!
//! \param  int FIDNumber the number of the FID to ckeck
//! \param  int FIDValue the value of the given FID 
//! 
//! \teststep Check the FID[$1] DINX signal
//! \testresponse The FID[$1] DINX signal equals to $2
//!
//! \note The FIDValue pramaeter can be only 0 or 1.
//- -----------------------------------------------------------------------------------------------
testcase CheckFID(int FIDNumber, char FIDValue[])
{
	CheckFIDFunction(FIDNumber,FIDValue);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to check a single FID value
//!
//! \return No return value
//!
//! \note See description of testcase CheckFID().
//- -----------------------------------------------------------------------------------------------
CheckFIDFunction(int FIDNumber, char FIDValue[])
{
  dword fileHandle;
  int i;
  int j;
  int state;
  int seperator_pos; //position of the ";" character in the array
  char FIDArray[100];
  
  fileHandle = 0;
  i = 0;
  j = 0;
  state = 0;
  
  /*------------------------- write sync name -------------------------*/
  i = 0;
  setFilePath( "c:\\unilogger\\", 2 );
  if ( fileHandle == 0 )
  {
    for(i = 0; i < 5; i++)
    {
      //setTimer(t, 100); //set timer to 100ms
      TestWaitForTextEvent("Timer", 10); // wait for 10ms
      fileHandle = OpenFileWrite( "sync_name.txt", 0 );
      if ( fileHandle != 0 ) //break if the file is accessible
      {
        break;
      }          
    }
  }
  
  if( i < 5 )
  {
    filePutString( "CErrormgrFidOutput", elcount("CErrormgrFidOutput"), fileHandle ); //write ID from function argument
    fileClose ( fileHandle );
  }
  else
  {
    write( "Cannot create file: sync_name.txt" );
  }
  
  //--------------------- wait for ADTF -------------------------//
  j = 0;
  i = 0;
  while( (state == 0) && (j < 10) ) // j: number of cycle
  {
    TestWaitForTextEvent("Timer", 50); // wait for 50-100ms <- ez a sor esszencialis, ezzel varjuk meg, h az ADTF feldolgozzon!!! ("eleg idot hagyunk neki")
    //Try to open ATDF status file
    fileHandle = OpenFileRead( "sync_state.txt", 0 ); //0:ASCII, 1:bin 
    if( fileHandle == 0 )    
    {
      for(i = 0; i < 5; i++)
      {
        //setTimer(t, 100); //set timer to 100ms
        TestWaitForTextEvent("Timer", 10); // wait for 10ms
        fileHandle = OpenFileRead( "sync_state.txt", 0 ); //0:ASCII, 1:bin 
        if ( fileHandle != 0 ) //break if the file is accessible
        {
          break;
        }          
      }            
    }
    
    //Read (ADTF) status
    if( i < 5 ) 
    {
      //set arrays to zero
      clearArray(FileBuffer);
      
      //read file
      fileGetString( FileBuffer, elcount( FileBuffer ), fileHandle );                      
      fileClose( fileHandle );            

      //check status
      if( strncmp( "1", FileBuffer, elcount("1")) == 0 )
      {
        state = 1;         
      }
      else
      {
        state = 0;
      }
    }
    else // This means the file could not opened
    { 
      write( "Cannot open file: sync_state.txt" );
    }

    j++;
  }
  //write("number of cycle:%d", j);

  if ( state == 1 )
  {
    fileHandle = OpenFileWrite( "sync_state.txt", 0 ); //0: ASCII, 1:bin, 2:append ASCII, 3: append bin
    filePutString( "0", elcount("0"), fileHandle );
    fileClose ( fileHandle );

    /*------------------------DATA COMPARE---------------------*/
    i = 0;
    j = 0;
    //set arrays to zero
    clearArray(dinx_buffer);
    clearArray(FileBuffer);

    //open the ADTF output file
    fileHandle = OpenFileRead( "adtf_out.csv", 0 ); //0:ASCII mode, 1:BIN mode
    if( fileHandle == 0)
    {
      write( "Cannot open file: adtf_out.csv" );
    }
    else
    { 
      while (fileGetString(dinx_buffer,elcount(dinx_buffer),fileHandle) != 0)
      {
        for(i; i < 5; i++)
		{
			if(dinx_buffer[i] == '\n') 
			{
				FIDArray[j] = dinx_buffer[i-1];	
				j++;
			}
		}
		i = 0;
      }     
      fileClose ( fileHandle );
      if( FIDArray[FIDNumber] == FIDValue[0] ) TestStepPass("INFO","The value (%c) of the %d. FID matches the expected value (%c)! PASS", FIDArray[FIDNumber], FIDNumber, FIDValue[0]);
      else TestStepFail("INFO","The value (%c) of the %d. FID doesn't match the expected value (%c)! FAILED", FIDArray[FIDNumber], FIDNumber, FIDValue[0]);  
    }		
  }
  else
  {
    write("Sync error (state != 1)");
    TestStepFail("Test ERROR!");	       
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compare the selected CAN signal value with the desired value
//!
//! \param  signal * signalName The desired CAN signal name
//! \param  float signalValue The expected value
//! 
//! \teststep Check $1 signal value
//! \testresponse The signal value should be $2
//- -----------------------------------------------------------------------------------------------
testcase CheckSignalValue(signal * signalName, float signalValue)
{
    function_CheckSignalValue(signalName, signalValue);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compare the selected CAN signal value with the desired value
//!
//! \return No return value
//!
//! \note See description of testcase CheckSignalValue().
//- -----------------------------------------------------------------------------------------------
function_CheckSignalValue(signal * signalName, float signalValue)
{
    long result;
	float signal_value;
	result = CheckSignalMatch(signalName, signalValue);
	signal_value = getSignal(signalName);
	switch(result)
	{
		case 0:
			TestStepFail("INFO","Unexpected %s signal value: %.2lf", signalName.name, signal_value);
			TestStep("INFO","The expected was %.2lf", signalValue);
        break;
		case 1:
			TestStepPass("INFO","The %s signal value is %.2lf as expected.", signalName.name, signal_value);	
        break;
		case -1:
			TestStepFail("INFO","General error.");	
        break;
		default:
			TestStepFail("INFO","Incorrect result.");
		break;
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Closes the current picture.
//! Usage: #) closePicture()
//! 
//! \teststep Close picture
//! \testresponse The open picture is closed
//- -----------------------------------------------------------------------------------------------
testcase closePicture()
{
	function_closePicture();	
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to close the current picture.
//! Usage: #) closePicture()
//!
//! \return No return value
//! 
//! \note See description of testcase closePicture().
//- -----------------------------------------------------------------------------------------------
function_closePicture()
{
	if(sysExecCmd("taskkill /IM dllhost.exe","& exit")) TestStepPass("INFO","The picture has been closed.  OK" );
	else TestStepFail("INFO","Can not close picture! ERROR");	
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compare the CAN and DINX signal value same time
//!
//! \param  char module[] the selected module of the DINX signal
//! \param  char name[] the name of the compared DINX signal
//! \param  signal signalName the name of the compared CAN signal
//! \param  char CompareMode[] the compare mode can be "Equal" or "NotEqual"
//! \param  float tolerance the allowed maximum difference between the DINX and CAN signal values
//! 
//! \teststep Compare $2 DINX signal with $3 CAN signal 
//! \testresponse The $2 DINX signal is $4 with $3 CAN signal (with $5 tolerance)
//- -----------------------------------------------------------------------------------------------
testcase CompareCan_DinxSignalValue(char module[], char name[], signal * signalName, char CompareMode[], float tolerance)
{
	CompareCan_DinxSignalValueFunction(module, name, signalName, CompareMode, tolerance);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compare the CAN and DINX signal value same time
//!
//! \return No return value
//!
//! \note See description of testcase CompareCan_DinxSignalValue().
//- -----------------------------------------------------------------------------------------------
CompareCan_DinxSignalValueFunction(char module[], char name[], signal * signalName, char CompareMode[], float tolerance)
{
	int sync_state;
	int read_state;
	double CANSignalValue, DINXSignalValue;
	sync_state = 0;
	read_state = 0;
	CANSignalValue = 0;
	DINXSignalValue = 0;
	
	sync_state = SyncIsSuccessful(module);
	read_state = ReadCurrentValueIsSuccessful(module,name,sync_state);
	if(read_state == 1)
	{
		TestStep("INFO","Sync and read was successful.");
		CANSignalValue = getSignal(signalName);
		DINXSignalValue=atodbl(currValue);
		if(abs( CANSignalValue - DINXSignalValue ) <= tolerance)
		{
			if(strncmp(CompareMode,"Equal",elcount(CompareMode))==0)
			{
				TestStepPass("INFO","The CAN signal and the DINX signal values are equal. %s.%s = %s = %f", module, name, signalName.name, CANSignalValue);
			}
			else if(strncmp(CompareMode,"NotEqual",elcount(CompareMode))==0)
			{
				TestStepFail("INFO","The CAN signal and the DINX signal values are equal. %s.%s = %s = %f", module, name, signalName.name, CANSignalValue);
			}
			else
			{
				TestStepFail("INFO","Invalid compare mode!");
			}
		}
		else
		{
			if(strncmp(CompareMode,"Equal",elcount(CompareMode))==0)
			{
				TestStepFail("INFO","The CAN signal and the DINX signal values are not equal. %s.%s = %f, %s = %f", module, name, DINXSignalValue, signalName.name, CANSignalValue);
			}
			else if(strncmp(CompareMode,"NotEqual",elcount(CompareMode))==0)
			{
				TestStepPass("INFO","The CAN signal and the DINX signal values are not equal. %s.%s = %f, %s = %f", module, name, DINXSignalValue, signalName.name, CANSignalValue);
			}
			else
			{
				TestStepFail("INFO","Invalid compare mode!");
			}
		}
	}
	else if(read_state == -1)
	{
		TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
	}
	else if(read_state == 0)
	{
		TestStepFail("INFO","Sync wasn't successful! ERROR");	
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compare two different DINX signal values same time
//!
//! \param  char module1[] the selected module of the first DINX signal
//! \param  char name1[] the name of the compared first DINX signal
//! \param  char module2[] the selected module of the second DINX signal
//! \param  char name2[] the name of the compared second DINX signal
//! \param  char CompareMode[] the compare mode can be "Equal" or "NotEqual"
//! \param  float tolerance the allowed maximum difference between the two DINX signal values
//! 
//! \teststep Compare $2 DINX signal with $4 DINX signal 
//! \testresponse The $2 DINX signal is $5 with $4 CAN signal (with $6 tolerance)
//- -----------------------------------------------------------------------------------------------
testcase CompareDinx_DinxSignalValue(char module1[], char name1[], char module2[], char name2[], char CompareMode[], float tolerance)
{
	CompareDinx_DinxSignalValueFunction(module1, name1, module2, name2, CompareMode, tolerance);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compare two different DINX signal values same time
//!
//! \return No return value
//!
//! \note See description of testcase CompareDinx_DinxSignalValue().
//- -----------------------------------------------------------------------------------------------
CompareDinx_DinxSignalValueFunction(char module1[], char name1[], char module2[], char name2[], char CompareMode[], float tolerance)
{
	int sync_state;
	int read_state;
	double DINXSignalValue1, DINXSignalValue2;
	sync_state = 0;
	read_state = 0;
	DINXSignalValue1 = 0;
	DINXSignalValue2 = 0;
	
	sync_state = SyncIsSuccessful(module1);
	read_state = ReadCurrentValueIsSuccessful(module1,name1,sync_state);
	if(read_state == 1)
	{
		TestStep("INFO","Sync and read was successful.");
		DINXSignalValue1=atodbl(currValue);
		read_state = ReadCurrentValueIsSuccessful(module2,name2,sync_state);
		if(read_state == 1)
		{
			TestStep("INFO","Sync and read was successful.");
			DINXSignalValue2=atodbl(currValue);		
			if(abs( DINXSignalValue1 - DINXSignalValue2 ) <= tolerance)
			{
				if(strncmp(CompareMode,"Equal",elcount(CompareMode))==0)
				{
					TestStepPass("INFO","The CAN signal and the DINX signal values are equal. %s.%s = %s.%s = %f", module1, name1, module2, name2, DINXSignalValue1);
				}
				else if(strncmp(CompareMode,"NotEqual",elcount(CompareMode))==0)
				{
					TestStepFail("INFO","The CAN signal and the DINX signal values are equal. %s.%s = %s.%s = %f", module1, name1, module2, name2, DINXSignalValue1);
				}
				else
				{
					TestStepFail("INFO","Invalid compare mode!");
				}
			}
			else
			{
				if(strncmp(CompareMode,"Equal",elcount(CompareMode))==0)
				{
					TestStepFail("INFO","The CAN signal and the DINX signal values are not equal. %s.%s = %f, %s.%s = %f", module1, name1, DINXSignalValue1, module2, name2, DINXSignalValue2);
				}
				else if(strncmp(CompareMode,"NotEqual",elcount(CompareMode))==0)
				{
					TestStepPass("INFO","The CAN signal and the DINX signal values are not equal. %s.%s = %f, %s.%s = %f", module1, name1, DINXSignalValue1, module2, name2, DINXSignalValue2);
				}
				else
				{
					TestStepFail("INFO","Invalid compare mode!");
				}
			}
		}
		else if(read_state == -1)
		{
			TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
		}
		else if(read_state == 0)
		{
			TestStepFail("INFO","Sync wasn't successful! ERROR");	
		}
	}
	else if(read_state == -1)
	{
		TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
	}
	else if(read_state == 0)
	{
		TestStepFail("INFO","Sync wasn't successful! ERROR");	
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to check that the set of the currently active MIDs is a subset of the set given in the inputStr param
//!		
//! \param  char inputStr a string containing MID names with a | separator
//!
//! \teststep Check that $1 MIDs are present in ErrorMemory
//! \testresponse $1 MIDs were present
//- -----------------------------------------------------------------------------------------------
testcase DTC_Check_MID (char inputStr[])
{
	DTC_Check_MID_Function(inputStr);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to check that the set of the currently active MIDs is a subset of the set given in the inputStr param
//!
//! \return No return value
//!
//! \note See description of testcase DTC_Check_MID().
//- -----------------------------------------------------------------------------------------------
DTC_Check_MID_Function (char inputStr[])
{
	dword fileHandle;
	char MIDLineBuffer[500];
	int i, j, k, l, m, stateOfDTC, JLR_MID_offset, endPos, MIDfound;
	long result, timeOutValue, counter;
	char buffer[9], copy_byteString[100], array_of_MID[13] = "1904______1_"; // The missed part will be filled with the DTC itself and first/last appearance check
	char askedMIDList[100][100];

	//init
	counter = 0;
	stateOfDTC = 0;  
	JLR_MID_offset = 14;
	i= 1;
	
	if(MIDArr[0][0] == '0'){
		MIDArr[0][0] = '1';
		fileHandle = OpenFileRead( "U:\\temp\\MIDList.txt", 0 ); //0:ASCII mode, 1:BIN mode
		if( fileHandle == 0)
		{
			write( "Cannot open file: MIDList.txt" );
		}
		else
		{
		  //--------------------- Read the full file -------------------------//
			while (fileGetString(MIDLineBuffer,elcount(MIDLineBuffer),fileHandle)!=0)
			{
				strncpy (MIDArr[i],  MIDLineBuffer, strlen(MIDLineBuffer)+1);
				i++;
			}
			fileClose ( fileHandle );      
		}
	}

	endPos = 0;
	m=0;
	strncpy(MIDLineBuffer, inputStr, strlen(inputStr)+1);
	while(strncmp(MIDLineBuffer, "", strlen(MIDLineBuffer)) != 0){
		endPos = strstr_regex(MIDLineBuffer, "\\|.*");
		if(endPos != -1)
		{
			substr_cpy(askedMIDList[m], MIDLineBuffer, 0, endPos, 500);
			substr_cpy(MIDLineBuffer, MIDLineBuffer, endPos + 1, -1, 500);
	
		}
		else{
			substr_cpy(askedMIDList[m], MIDLineBuffer, 0, -1, 500);
			strncpy(MIDLineBuffer, "", 1);
		}
		TestStep("INFO","askedMIDList[%d]: %s", m, askedMIDList[m]);
		m++;
		endPos = 0;
	}
	
	TestStep("INFO","DTC_Request: %s", "190209");
	TestStep("INFO","DTC_Response: %s", "59027b.*");
	RequestResponseCompareLogic ("190209", "59027b.*", "Regexp");                
	//write("Debug ==> the value of the byteString: %s and its lenght: %d", byteString, strlen(byteString));
	strncpy(copy_byteString, byteString, strlen(byteString)+1); //since I call RequestResponseCompareLogic function several times in this function I have to copy the original byteString
	counter = strlen(copy_byteString);
	  
	if (strlen("59027b") < strlen(copy_byteString))
	{
		counter = (strlen(copy_byteString) - strlen("59027b"))/8; //number of characters in the response - the fix size(6 = strlen("59027b") ) of the UDS response divided by 8 (DTC lenght+status)
		TestStep("INFO","The number of DTCs on the Camera: %d! Checking for status and MIDs...", counter);
		
		for (i=0; i<counter;i++ )
		{
		  for (j = 0; j < 8 ; j++ ) // 
		  {
			buffer[j] = copy_byteString[j+6+i*8]; //6 is the offset of the positive response for UDS message            
		  }      
		  stateOfDTC = char2byte(buffer[7], 1); // if it is even --> PASSIVE; if it is odd --> ACTIVE
		  //write("\t%d. DTC is: %s", i+1, buffer);         
		  
		  if (0 == (stateOfDTC%2)) //Checking whether the DTC is passive or Active by even or odd number check
			{
			  TestStep("INFO","\t%d. DTC %c%c%c%c%c%c is in PASSIVE state! The Status byte is: %c%c", i+1, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]);
			}
		  else
			{
			  TestStep("INFO","\t%d. DTC %c%c%c%c%c%c is in ACTIVE state! The Status byte is: %c%c", i+1, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]);
			}
		  
		  for (k = 0; k < 6; k++) //Only the 3 byte long DTC needed. The 4th byte is the status
			{
			   array_of_MID[k+4] = buffer[k];
			}
		  
			  array_of_MID[11] = '0'; // Checking the first appearance of the MID of the DTC
			  //write("Debug array_of_MID ==> the value of the array_of_MID: %s and its length: %d", array_of_MID, strlen(array_of_MID)); 
			  TestStep("INFO","********************************************* Checking the FIRST appearance of the MID for DTC %c%c%c%c%c%c! ********************************************************************************", buffer[0], buffer[1], buffer[2],buffer[3],buffer[4],buffer[5]);
			  RequestResponseCompareLogic (array_of_MID, "5904.*", "Regexp");
			  
			  strncpy(byteString, byteString, strlen(byteString)+1);
			  
			  strncpy(MIDLineBuffer, MIDArr[char2int(byteString[strlen(byteString)-JLR_MID_offset-4],4096) + char2int(byteString[strlen(byteString)-JLR_MID_offset-3], 256) + char2int(byteString[strlen(byteString)-JLR_MID_offset-2],16) + char2int(byteString[strlen(byteString)-JLR_MID_offset-1], 1)], strlen(MIDArr[char2int(byteString[strlen(byteString)-JLR_MID_offset-4],4096) + char2int(byteString[strlen(byteString)-JLR_MID_offset-3], 256) + char2int(byteString[strlen(byteString)-JLR_MID_offset-2],16) + char2int(byteString[strlen(byteString)-JLR_MID_offset-1], 1)]));
			  
			  MIDfound = 0;
			  for(l = 0; l< m; l++){
				  if (strncmp(askedMIDList[l], MIDLineBuffer, strlen(MIDLineBuffer)) == 0){
					  MIDfound = 1;
					  TestStepPass("INFO","********************************************* In the  %d. DTC, the FIRST occurrence MID: %s (0x%c%c%c%c) is present in the given parameter list : %s *********************************************************************************", i+1, MIDLineBuffer, byteString[strlen(byteString)-JLR_MID_offset-4], byteString[strlen(byteString)-JLR_MID_offset-3], byteString[strlen(byteString)-JLR_MID_offset-2], byteString[strlen(byteString)-JLR_MID_offset-1], inputStr);
					  break;
				  }
			  }
			  if(MIDfound == 0){
				  TestStepFail("INFO","********************************************* In the  %d. DTC, the FIRST occurrence MID: %s (0x%c%c%c%c) is NOT present in the given parameter list : %s *********************************************************************************", i+1, MIDLineBuffer, byteString[strlen(byteString)-JLR_MID_offset-4], byteString[strlen(byteString)-JLR_MID_offset-3], byteString[strlen(byteString)-JLR_MID_offset-2], byteString[strlen(byteString)-JLR_MID_offset-1], inputStr);
			  }
			  
			  TestStep("INFO","********************************************* Checking the LAST appearance of the MID for DTC %c%c%c%c%c%c! *********************************************************************************", buffer[0], buffer[1], buffer[2],buffer[3],buffer[4],buffer[5]);
			  
			  array_of_MID[11] = '1'; // Checking the last appearance of the MID of the DTC
			  RequestResponseCompareLogic (array_of_MID, "5904.*", "Regexp");      
			  
			  strncpy(MIDLineBuffer, MIDArr[char2int(byteString[strlen(byteString)-JLR_MID_offset-4],4096) + char2int(byteString[strlen(byteString)-JLR_MID_offset-3], 256) + char2int(byteString[strlen(byteString)-JLR_MID_offset-2],16) + char2int(byteString[strlen(byteString)-JLR_MID_offset-1], 1)], strlen(MIDArr[char2int(byteString[strlen(byteString)-JLR_MID_offset-4],4096) + char2int(byteString[strlen(byteString)-JLR_MID_offset-3], 256) + char2int(byteString[strlen(byteString)-JLR_MID_offset-2],16) + char2int(byteString[strlen(byteString)-JLR_MID_offset-1], 1)]));
			  
			  MIDfound = 0;
			  for(l = 0; l< m; l++){
				  if (strncmp(askedMIDList[l], MIDLineBuffer, strlen(MIDLineBuffer)) == 0){
					  MIDfound = 1;
					    TestStepPass("INFO","********************************************* In the  %d. DTC, the LAST occurrence MID: %s (0x%c%c%c%c) is present in the given parameter list : %s *********************************************************************************", i+1, MIDLineBuffer, byteString[strlen(byteString)-JLR_MID_offset-4], byteString[strlen(byteString)-JLR_MID_offset-3], byteString[strlen(byteString)-JLR_MID_offset-2], byteString[strlen(byteString)-JLR_MID_offset-1], inputStr);
					  break;
				  }
			  }
			  if(MIDfound == 0){
				   TestStepFail("INFO","********************************************* In the  %d. DTC, the LAST occurrence MID: %s (0x%c%c%c%c) is NOT present in the given parameter list : %s *********************************************************************************", i+1, MIDLineBuffer, byteString[strlen(byteString)-JLR_MID_offset-4], byteString[strlen(byteString)-JLR_MID_offset-3], byteString[strlen(byteString)-JLR_MID_offset-2], byteString[strlen(byteString)-JLR_MID_offset-1], inputStr);
			  }
			  
	   }              
	}
  else
    {
      TestStepFail("INFO","##### There is NO DTC on the Camera! #####");
      //write("Number of characters in the response is :%d", strlen(copy_byteString));
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function compares the given input string (composed of 49 bit of 0 and 1) to the  
//!		ErrorMgr DinX output. The purpose of this function is to check which FID is set or not
//!
//! \param  char inputStr[] a string composed of 49 bit 0 and 1
//! 
//! \teststep Check if the FID array's values are equal with the following: $1
//! \testresponse FID array's values are equal with the following: $1
//!
//! \note The values in the parameter can be only 0 or 1. 0 means FID is set, 1 means FID is not set.
//! \note The order of FIDs in the inputStr must follow the FID order in file Fim_Fids_Cfg.h
//- -----------------------------------------------------------------------------------------------
testcase ErrorMgr(char inputStr[])
{
    dword fileHandle;
    char buffer[100];
    char FileBuffer[100];
    char nullStr[1] = ""; //empty string to set zero char arrays 
    int i;
    int j;
    int state;
    int seperator_pos; //position of the ";" character in the array
    char outputStr[100]; 
	
	fileHandle = 0;
	i = 0;
	j = 0;
	state = 0;
	seperator_pos = 0;
	
    
    strncpy(outputStr, nullStr, elcount(nullStr));
    
	/*------------------------- write sync name -------------------------*/
    i = 0;
	setFilePath( "c:\\unilogger\\",2 );
    fileHandle = OpenFileWrite( "sync_name.txt", 0 ); //0: ASCII, 1:bin, 2:append ASCII, 3: append bin
    if ( fileHandle == 0 )
    {
        for(i = 0; i < 5; i++)
        {
            //setTimer(t, 100); //set timer to 100ms
            TestWaitForTextEvent("Timer", 10); // wait for 10ms
            fileHandle = OpenFileWrite( "sync_name.txt", 0 );
            if ( fileHandle != 0 ) //break if the file is accessible
            {
                break;
            }          
        }
    }
    
    if( i < 5 )
    {
        filePutString( "CErrormgrFidOutput", elcount("CErrormgrFidOutput"), fileHandle ); //write ID from function argument
        fileClose ( fileHandle );
    }
    else
    {
       write( "Cannot create file: sync_name.txt" );
    }
   
    //--------------------- wait for ADTF -------------------------//
    j = 0;
	i = 0;
    while( (state == 0) && (j < 10) ) // j: number of cycle
    {
        TestWaitForTextEvent("Timer", 50); // wait for 50-100ms <- ez a sor esszencialis, ezzel varjuk meg, h az ADTF feldolgozzon!!! ("eleg idot hagyunk neki")
        //Try to open ATDF status file
        fileHandle = OpenFileRead( "sync_state.txt", 0 ); //0:ASCII, 1:bin 
        if( fileHandle == 0 )    
        {
            for(i = 0; i < 5; i++)
            {
               //setTimer(t, 100); //set timer to 100ms
               TestWaitForTextEvent("Timer", 10); // wait for 10ms
               fileHandle = OpenFileRead( "sync_state.txt", 0 ); //0:ASCII, 1:bin 
               write("probal olvasni");
               if ( fileHandle != 0 ) //break if the file is accessible
               {
                    break;
               }          
            }            
        }

        //Read (ADTF) status
        if( i < 5 ) 
        {
            //set arrays to zero
            //strncpy(buffer, nullStr, elcount(nullStr));
            strncpy(FileBuffer, nullStr, elcount(nullStr));
            
            //read file
            fileGetString( FileBuffer, elcount( FileBuffer ), fileHandle );                      
            fileClose( fileHandle );            

            //check status
            if( strncmp( "1", FileBuffer, elcount("1")) == 0 )
            {
                state = 1;         
            }
            else
            {
                state = 0;
            }
        }
        else // This means the file could not opened
        { 
            write( "Cannot open file: sync_state.txt" );
        }

        j++;
    }
//write("number of cycle:%d", j);

    if ( state == 1 )
    {
        setFilePath( "c:\\unilogger\\",2 );
        fileHandle = OpenFileWrite( "sync_state.txt", 0 ); //0: ASCII, 1:bin, 2:append ASCII, 3: append bin
        filePutString( "0", elcount("0"), fileHandle );
        fileClose ( fileHandle );

        /*------------------------DATA COMPARE---------------------*/
        i = 0;
		j = 0;
		//set arrays to zero
        strncpy(buffer, nullStr, elcount(nullStr));
        strncpy(FileBuffer, nullStr, elcount(nullStr));

        //open the ADTF output file
        fileHandle = OpenFileRead( "adtf_out.csv", 0 ); //0:ASCII mode, 1:BIN mode
        if( fileHandle == 0)
        {
            write( "Cannot open file: adtf_out.csv" );
        }
        else
        { 
			for(i = 0; i < strlen(inputStr); i++)
			{
        //set arrays to zero                
				strncpy(buffer, nullStr, elcount(nullStr));
                strncpy(FileBuffer, nullStr, elcount(nullStr));               
                
                //read a line from the file				
				fileGetString( FileBuffer, elcount( FileBuffer ), fileHandle );
				
				if(strlen(FileBuffer) > 0)
				{						
					//elem kivetele (balrol jobbra haladunk)
					seperator_pos = strstr(FileBuffer,";"); //a ";" pozicioja
					substr_cpy(buffer, FileBuffer, 0, seperator_pos, 255); // kivesszk az elemet a "buffer"-be
					substr_cpy(FileBuffer, FileBuffer, seperator_pos+1, strlen(FileBuffer), 255); // kihagyjuk a pontosvesszot
					//most a "buffer"-ben van az elso oszlop (azonosito - m_FID_u8), a "FileBuffer"-ben a masodik oszlop (ertek - m_Permission_b)
					outputStr[i] = FileBuffer[0]; //saving result 
                    //if( strncmp( FileBuffer, inputStr[i],  1 ) == 0 )
					if( FileBuffer[0] == inputStr[i])
					{
						//write("FID_%i: OK", i);
					}
					else
					{
						write("FID_%i: FAILED (%c)", i, FileBuffer[0]);
						j = 1; //indicates error
					}										
				}
			}
			fileClose ( fileHandle );
            write("Input:%s", inputStr);
            write("Output:%s", outputStr);
			TestStep("INFO","EXPECTED: %s", inputStr);
            TestStep("INFO","RECEIVED: %s", outputStr);
            if( j == 0 )
			{
				TestStepPass("Test PASSED!");
			}
			else
			{
				TestStepFail("Test FAILED!");
			}            
		}		
    }
    else
    {
        write("Sync error (state != 1)");
		TestStepFail("Test ERROR!");	       
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Executes the given command with parameters
//! Usage: #) executeCommand( string command xxx, string params "xxx /x -x --xxxx", string commandPath "x:\xxx xx\xx")
//!
//! \param  char command[] The program/command you want to execute in CMD
//! \param  char params[] all the params
//! \param  char commandPath[] the path where the first parameter is located
//! 
//! \teststep Execute $1 command with $2 parameters
//! \testresponse Command is executed
//- -----------------------------------------------------------------------------------------------
testcase executeCommand(char command[], char params[], char commandPath[])
{
	executeCommand_function(command, params, commandPath);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Executes the given command with parameters
//! Usage: #) executeCommand( string command xxx, string params "xxx /x -x --xxxx", string commandPath "x:\xxx xx\xx")
//!
//! \return No return value
//!
//! \note See description of testcase executeCommand().
//- -----------------------------------------------------------------------------------------------
executeCommand_function(char command[], char params[], char commandPath[]){
    // TestStepFail("INFO","The function NOT FULLY FUNCTIONAL yet! Results may be not expected! ERROR");	
    // kieszkepelesnel a command kore fonja az eredmenyeket, mert nem torli a valtozot ?!?!?!?!?!?!?!?!?!?!?!?
    
    char ESCcommand[500];
    char ESCparams[500];
    char ESCcPath[500];
    
    // ---------------- Path escaping
    pathEscape(command);
    strncpy(ESCcommand, command_buffer, 500);
     TestStep("ESCcommand", ESCcommand);
    // TestStep("command_buffer", command_buffer);
    
    pathEscape(params);
    strncpy(ESCparams, command_buffer, 500);
    strncat(ESCparams, " & exit", 500);
     TestStep("ESCparams", ESCparams);
    // TestStep("command_buffer", command_buffer);
    
    pathEscape(commandPath);
    strncpy(ESCcPath, command_buffer, 500);
     TestStep("ESCcPath", ESCcPath);
    // TestStep("command_buffer", command_buffer);
    
    
    // ---------------- Command execute 
    if ( sysExecCmd( ESCcommand, ESCparams, ESCcPath ) )
    {
        TestStepPass("INFO","The command executed successfully.  OK" );
    }
    else
    {
        TestStep("commandPath", commandPath );
        TestStep("ESCcPath", ESCcPath );
        
        TestStep("params", params );
        TestStep("ESCparams", ESCparams );
        
        TestStep("command ", command );
        TestStep("ESCcommand", ESCcommand );
        
        TestStepFail("INFO","Can not execute the given command! ERROR");	
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Waits until the signal value reaches the expected value
//!
//! \param  char type[] can contains "Equal" "NotEqual" or a number
//! \param  char module[] the selected module of the DINX signal
//! \param  char name[] the name of the searched DINX signal
//! \param  char value[] the expected value
//! \param  int minTime the min requied time
//! \param  int maxTime the max requied time
//!
//! \example #) extendedWaitDINX(string type _TYPE_, string module _MODULE_, string name _NAME_, string value _VALUE_, int minTime _MINTIME_, int maxTime _MAXTIME_) 
//!
//! \teststep Check $3 DINX signal
//! \testresponse Signal should be equal to $4
//- -----------------------------------------------------------------------------------------------
testcase extendedWaitDINX(char type[], char module[], char name[], char value[], long minTime, long maxTime)
{
  WaitDINXFunction(type, module, name, value, minTime, maxTime);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function get the control of the voltage supply, and set a voltage to the camera
//!
//! \param  int PortNumber the number of the port where the voltage supply connects
//! \param  char VoltageSupplyType[] the type of the voltage supply
//! \param  float Voltage the value of the voltage given to the camera
//! 
//! \teststep Get the voltage control on $1 port and set $3V to the output
//! \testresponse Voltage control has got and $3V is given out
//!
//! \note The VoltageSupplyType parameter can be BK or GW.
//- -----------------------------------------------------------------------------------------------
testcase GetVoltageControl(int PortNumber, char VoltageSupplyType[], float Voltage)
{
	GetVoltageControlFunction(PortNumber, VoltageSupplyType, Voltage);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function get the control of the voltage supply, and set a voltage to the camera
//!
//! \return No return value
//!
//! \note See description of testcase GetVoltageControl().
//- -----------------------------------------------------------------------------------------------
GetVoltageControlFunction(int PortNumber, char VoltageSupplyType[], float Voltage)
{
	putvalue(EnvVoltComPort,PortNumber);
	TestWaitForTimeout(100);
	if(strncmp(VoltageSupplyType,"BK",elcount(VoltageSupplyType)) == 0)
	{
		putvalue(EnvVoltageSupplySelector,0);	
		TestWaitForTimeout(100);
	}
	else if(strncmp(VoltageSupplyType,"GW",elcount(VoltageSupplyType)) == 0)
	{
		putvalue(EnvVoltageSupplySelector,1);
		TestWaitForTimeout(100);
	}
	else TestStepFail("INFO","The given voltage supply type is invalid!");
	TestWaitForTimeout(100);
	putvalue(Env_VoltBKChannel, 0);
	TestWaitForTimeout(100);
	putvalue(Env_VoltBKSet, Voltage);
	TestWaitForTimeout(100);
	putvalue(Env_VoltBKStat,1);
	TestWaitForTimeout(7000);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given DinX signal value keeps the expectedValue for a given time,
//! which is the monitoringTime
//!
//! \param  char moduleName[] the name of the monitored SW module that contains the given signal
//! Use an unilogger compatible string like "CLkaOutput"
//! \param  char signalName[] the name of the monitored DinX signal
//! \param  int expectedValue the expected value of the signal 
//! \param  int monitoringTime the time interval until the signal value will not change [ms]
//! 
//! \teststep Check $2 DINX signal for $4ms
//! \testresponse The $2 DINX signal holds $3 value for $4ms
//- -----------------------------------------------------------------------------------------------
testcase MonitorDINXSignalStable(char moduleName[], char signalName[], int expectedValue, long monitoringTime)
{
  MonitorDINXSignalStableFunction(moduleName, signalName, expectedValue, monitoringTime);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the given DinX signal value keeps the expectedValue for a given time,
//! which is the monitoringTime
//!
//! \return No return value
//!
//! \note See description of testcase MonitorDINXSignalStable().
//- -----------------------------------------------------------------------------------------------
MonitorDINXSignalStableFunction(char moduleName[], char signalName[], int expectedValue, long monitoringTime)
{ 
  long currentValue;
  int timeout;
  int counter;
  int sync_state;
  int read_state;
  int res;
  float timStart;
  
  
  currentValue = 0;
  timeout = 0;
  counter = 0;
  sync_state = 0;
  read_state = 0;
  res = 0;
  timStart = timeNowFloat();
  
  sync_state = SyncIsSuccessful(moduleName);
  read_state = ReadCurrentValueIsSuccessful(moduleName,signalName,sync_state);
  if ( read_state == 1 )
  {
    TestStep("INFO","Sync and read was successful.");
  }
  else if ( read_state == -1 )
  {
    TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
  }
  else if ( read_state == 0 )
  {
    TestStepFail("INFO","Sync wasn't successful! ERROR");	
  }
  
  res = strtol(currValue,currentValue);
  
  //check that DinX value is equal to the expected at monitoring start
  if(currentValue != expectedValue)
  {
	 TestStepFail("INFO","Dinx signal %s value %i does not equal %i at monitoring start! ERROR", signalName, currentValue, expectedValue);  
  }
  
  //For debug
  //write("Signal %s value is: %i", signalName, currentValue);
  //write("The \"MonitorDINXSignalFunction begint\" take %f ms.", (timeNowFloat()-timStart) / 100.0 ) ; // ---- time measurement ---- 
  
  //increase time counter for the first DinX read
  counter += (int)((timeNowFloat()-timStart) / 100.0);
  
  while(timeout != 1)
  {
	timStart = timeNowFloat();

    // fills up buffer, with the actual value
    sync_state = SyncIsSuccessful(moduleName);
	read_state = ReadCurrentValueIsSuccessful(moduleName,signalName,sync_state);
    if ( read_state == 1 )
    {
      TestStep("INFO","Sync and read was successful.");
    }
    else if ( read_state == -1 )
    {
      TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
    }
    else if ( read_state == 0 )
    {
      TestStepFail("INFO","Sync wasn't successful! ERROR");	
    }
	
	res = strtol(currValue, currentValue);
  
	//For debug
	//write("Signal %s value is: %i", signalName, currentValue);
	
    if(currentValue == expectedValue && counter <= monitoringTime)
    {
	  write("The Dinx signal: (%s) value: (%i) is equal to the expected value ((%i)). OK", signalName, currentValue, expectedValue);
    }
    else if(currentValue != expectedValue && counter <= monitoringTime)
    {
	  TestStepFail("INFO","The Dinx signal: (%s) value changed from (%i) to (%i) during monitoring. FAIL.", signalName, expectedValue, currentValue);
	  timeout = 1;
    }
    else if(currentValue != expectedValue && counter > monitoringTime)
    {
	  TestStepFail("INFO","The Dinx signal: (%s) value did not stayed (%i) in (%i) time(ms) specified in test case. FAIL.", signalName, expectedValue, monitoringTime);
	  timeout = 1;
    }
	else if(currentValue == expectedValue && counter > monitoringTime)
	{
	  TestStepPass("INFO","The Dinx signal: (%s) value: (%i) was equal to the expected value ((%i)) in monitoring time. OK", signalName, currentValue, expectedValue);
	  timeout = 1;
	}
	//increase time counter for DinX read
	counter += (int)((timeNowFloat()-timStart) / 100.0);
	if(counter > monitoringTime)
	{
		timeout = 1;
	}
	//For debug
	//write("The \"MonitorDINXSignalFunction WHILE\" take %f ms.", (timeNowFloat()-timStart) / 100.0 ) ; // ---- time measurement ---- 
	//write("Counter: %d , timeout: %d", counter,timeout);
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the value of the given DinX signal keeps between the given lowerBound and upperBound parameters for a given time,
//! which is the monitoringTime
//!
//! \param  char moduleName[] the name of the monitored SW module that contains the given signal
//! Use an unilogger compatible string like "CLkaOutput"
//! \param  char signalName[] the name of the monitored DinX signal
//! \param  float lowerBound the lower bound of the signal value
//! \param  float upperBound the upper bound of the signal value
//! \param  long monitoringTime the time interval until the signal value will be between the given boundary values [ms]
//! 
//! \teststep Check $2 DINX signal for $5ms
//! \testresponse The $2 DINX signal holds its value between $3 and $4 for $5ms
//- -----------------------------------------------------------------------------------------------
testcase MonitorDINXSignalStableInRange(char moduleName[], char signalName[], float lowerBound, float upperBound, long monitoringTime)
{
  MonitorDINXSignalStableInRangeFunction(moduleName, signalName, lowerBound, upperBound, monitoringTime);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function checks if the value of the given DinX signal keeps between the given lowerBound and upperBound parameters for a given time,
//! which is the monitoringTime
//!
//! \return No return value
//!
//! \note See description of testcase MonitorDINXSignalStableInRange().
//- -----------------------------------------------------------------------------------------------
MonitorDINXSignalStableInRangeFunction(char moduleName[], char signalName[], float lowerBound, float upperBound, long monitoringTime)
{ 
  double currentValue;
  int timeout;
  int counter;
  int sync_state;
  int read_state;
  int res;
  float timStart;
  
  timeout = 0;
  currentValue = 0;
  counter = 0;
  sync_state = 0;
  read_state = 0;
  res = 0;
  timStart = timeNowFloat();
  
  sync_state = SyncIsSuccessful(moduleName);
  read_state = ReadCurrentValueIsSuccessful(moduleName,signalName,sync_state);
  if ( read_state == 1 )
  {
    TestStep("INFO","Sync and read was successful.");
  }
  else if ( read_state == -1 )
  {
    TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
  }
  else if ( read_state == 0 )
  {
    TestStepFail("INFO","Sync wasn't successful! ERROR");	
  }
  
  res = strtod(currValue,currentValue);
  
  //check that DinX value is in the expected vale range at monitoring start
  if(currentValue < lowerBound)
  {
	 TestStepFail("INFO","Dinx signal %s value %g is lower than the given lower bound value %g at monitoring start! ERROR", signalName, currentValue, lowerBound);  
  }
  else if(currentValue > upperBound)
  {
	 TestStepFail("INFO","Dinx signal %s value %g is greater than the given upper bound value %g at monitoring start! ERROR", signalName, currentValue, upperBound);  
  }
  
  //increase time counter for the first DinX read
  counter += (int)((timeNowFloat()-timStart) / 100.0);
  
  while(timeout != 1)
  {
	timStart = timeNowFloat();

    // fills up buffer, with the actual value
    sync_state = SyncIsSuccessful(moduleName);
	read_state = ReadCurrentValueIsSuccessful(moduleName,signalName,sync_state);
    if ( read_state == 1 )
    {
      TestStep("INFO","Sync and read was successful.");
    }
    else if ( read_state == -1 )
    {
      TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
    }
    else if ( read_state == 0 )
    {
      TestStepFail("INFO","Sync wasn't successful! ERROR");	
    }
	
	res = strtod(currValue, currentValue);
  
  
  
	if(counter <= monitoringTime ){
		if (currentValue >= lowerBound && currentValue <= upperBound)
			write("The Dinx signal: (%s) value: (%g) is between the expected value range [((%g));((%g))]. OK", signalName, currentValue, lowerBound, upperBound);
		else if(currentValue < lowerBound)
		{
			TestStepFail("INFO","The Dinx signal: (%s) value changed to (%g), which is lower than the given lower bound value (%g) during monitoring. FAIL.", signalName, currentValue, lowerBound);  
			timeout = 1;
		}
		else if(currentValue > upperBound)
		{
			TestStepFail("INFO","The Dinx signal: (%s) value changed to (%g), which is greater than the given upper bound value (%g) during monitoring. FAIL.", signalName, currentValue, upperBound);  
			timeout = 1;
		}
	}
	else {
		if (currentValue >= lowerBound && currentValue <= upperBound)
			write("The Dinx signal: (%s) value: (%i) was between the expected value range [((%g));((%g))] in the specified (%i) monitoring time(ms). OK", signalName, currentValue, lowerBound, upperBound, monitoringTime);
		else
		{
			TestStepFail("INFO","The Dinx signal: (%s) value (%g) did not stay in the given value range [((%g));((%g))] in (%i) time(ms) specified in test case. FAIL.", signalName, currentValue, lowerBound, upperBound, monitoringTime);  
			timeout = 1;
		}
	}
	
	//increase time counter for DinX read
	counter += (int)((timeNowFloat()-timStart) / 100.0);
	if(counter > monitoringTime)
	{
		timeout = 1;
	}
  }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Compares the value with the signal's actual value
//!   There are multiple modes (defined with the type parameter)
//!
//! \param  char type[] can contains "Equal" "NotEqual" or a number
//! \param  char module[] the name of the tested module
//! \param  char name[] the name of the searched DINX signal
//! \param  char value[] the expected value
//! 
//! \teststep Check $3 DINX signal
//! \testresponse The $3 signal has correct value 
//- -----------------------------------------------------------------------------------------------
testcase PVWCheckDINX(char type[], char module[], char name[], char value[])
{
  CheckDINXFunction( type, module, name, value);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Waits until the signal value reaches the expected value
//!
//! \param  char module[] the selected module of the DINX signal
//! \param  char name[] the name of the searched DINX signal
//! \param  char value[] the expected value
//! 
//! \example #) PVWWaitDINX(string module _MODULE_, string name _NAME_, string value _VALUE_)
//!
//! \teststep Monitor $2 DINX signal for 15 sec
//! \testresponse Signal reached the value of $3
//- -----------------------------------------------------------------------------------------------
testcase PVWWaitDINX(char module[], char name[], char value[])
{
  // WaitDINXFunction(module, name, value, 15000);  // REPLACED with new version below 12:55 2016.09.22.
  WaitDINXFunction("Equal", module, name, value, 0, 15000);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to read out the available temperature values for all ECUs and Imagers
//!
//!	\param	char type indicates what type of measured temperature value should be read out
//! 
//! \teststep Read out the temperature value of the $1
//! \testresponse -
//!
//! \note	This testcase is available in all platforms. Before calling this testcase, enter into Plant mode and RBEOL.
//!	\note	Offset is considered.
//!			\n
//!			Available types:\n
//!			- GenericECU: Returns the average of the ECU temperatures.\n
//!			- GenericImager: Returns the average of the Imager temperatures.\n
//!			- Zynq0: Returns the temperature of the Zynq0.\n
//!			- Zynq1: Returns the temperature of the Zynq1.\n
//!			- ImagerA: Returns the temperature of the ImagerA.
//- -----------------------------------------------------------------------------------------------
testcase ReadTempRBEOL(char type[])
{
	ReadTempPlant(type);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to read out the available temperature values for all ECUs and Imagers
//!
//! \return Desired temperature value in integer
//!
//! \note	See description of testcase ReadTempRBEOL().
//- -----------------------------------------------------------------------------------------------
int ReadTempPlant(char type[])
{
	//Variables
	int t; //The decimal value of the temperature will be stored here
	char tempECU[4]; //This is needed for the response extraction
	char tempImg[4]; //This is needed for the response extraction
	char tempZ0[4]; //This is needed for the response extraction
	char tempZ1[4]; //This is needed for the response extraction
	char tempImgA[4]; //This is needed for the response extraction
	char tempImgB[4]; //This is needed for the response extraction
	
	//At this point RBEOL session is assumed
	if(RequestResponseCompareLogic("224250","624250.*","Regexp"))
	{
		saveResponse();
	
		if(0 == strncmp("GenericECU", type, strlen(type)))
		{
			tempECU[0]='0';
			tempECU[1]='x';
			tempECU[2]=seedString[8]; //ECU temp
			tempECU[3]=seedString[9];
			
			t=(int)atol(tempECU);
			t=t-128;
			
			TestStep("INFO", "The measured ECU temperature is: %d degC", t);
		}	
		else if(0 == strncmp("GenericImager", type, strlen(type)))
		{
			tempImg[0]='0';
			tempImg[1]='x';
			tempImg[2]=seedString[12]; //Img temp
			tempImg[3]=seedString[13];
		
			t=(int)atol(tempImg);
			t=t-128;
			
			TestStep("INFO", "The measured Imager temperature is: %d degC", t);
		}	
		else if(0 == strncmp("Zynq0", type, strlen(type)))
		{
			tempZ0[0]='0';
			tempZ0[1]='x';
			tempZ0[2]=seedString[16]; //Z0 ECU
			tempZ0[3]=seedString[17];
			
			t=(int)atol(tempZ0);
			t=t-128;
			
			TestStep("INFO", "The measured Zynq0 temperature is: %d degC", t);
		}	
		else if(0 == strncmp("Zynq1", type, strlen(type)))
		{
			tempZ1[0]='0';
			tempZ1[1]='x';
			tempZ1[2]=seedString[20]; //Z1 ECU
			tempZ1[3]=seedString[21];
			
			t=(int)atol(tempZ1);
			t=t-128;
			
			TestStep("INFO", "The measured Zynq1 temperature is: %d degC", t);
		}
		else if(0 == strncmp("ImagerA", type, strlen(type)))
		{
			tempImgA[0]='0';
			tempImgA[1]='x';
			tempImgA[2]=seedString[24]; //Img A
			tempImgA[3]=seedString[25];
			
			t=(int)atol(tempImgA);
			t=t-128;
		
			TestStep("INFO", "The measured Imager A temperature is: %d degC", t);
		}
		else if(0 == strncmp("ImagerB", type, strlen(type)))
		{
			tempImgB[0]='0';
			tempImgB[1]='x';
			tempImgB[2]=seedString[28]; //Img B
			tempImgB[3]=seedString[29];
			
			t=(int)atol(tempImgB);
			t=t-128;
		
			TestStep("INFO", "The measured Imager B temperature is: %d degC", t);
		}
		else
		{
			TestStepFail("INFO","The type '%s' is not valid!", type);
		}
		return t;
	}
	else
	{
		return 0;
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function release the control of the voltage supply and set back voltage supply control
//!         environment variables to default
//!
//! \param  int PortNumber the number of the port where the voltage supply connects
//! 
//! \teststep Release the voltage control on $1 port
//! \testresponse Voltage control has been released
//- -----------------------------------------------------------------------------------------------
testcase ReleaseVoltageControl(int PortNumber)
{
	ReleaseVoltageControlFunction(PortNumber);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The function release the control of the voltage supply and set back voltage supply control
//!         environment variables to default
//!
//! \return No return value
//!
//! \note See description of testcase ReleaseVoltageControl().
//- -----------------------------------------------------------------------------------------------
ReleaseVoltageControlFunction(int PortNumber)
{
	putvalue(Env_VoltBKStat,0);
	TestWaitForTimeout(100);
	putvalue(Env_VoltBKSet, 0);
	TestWaitForTimeout(100);
	putvalue(EnvVoltageSupplySelector,2);
	TestWaitForTimeout(100);
	if(Rs232Close(PortNumber)) write("Serial port %d successfully closed.", PortNumber);    
    else write("An error occurred during closing of the serial port %d.", PortNumber);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which send diagnostic message and check the response
//!
//! \param  char Request is the request should be sent
//! \param  char Response is the expected response should be awaited
//! \param  char CompareMode is the compare mode should be used to check the response
//! 
//! \teststep Send Diagnostic message with service 0x$1   
//! \testresponse Expected response is $2
//!
//! \note	The function can send a string to the ECU from the parameter (Request) and check the received message (Response). \n
//! 		String to byte conversion is needed to send and receive the string parameters, the function also includes this feature.
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//- -----------------------------------------------------------------------------------------------
testcase RequestResponse(char Request[], char Response[], char CompareMode[])
{
	RequestResponseCompareLogic(Request, Response, CompareMode);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to send diagnostic message and check the response
//!
//! \return If the expected response is received, the function returns with 1 and test step passed state, otherwise with 0 and test step failed state
//!
//! \note	See description in testcase RequestResponse().
//- -----------------------------------------------------------------------------------------------
int RequestResponseCompareLogic(char Request[], char Response[], char CompareMode[])
{
    byte responsePending;
    long result;
    long timeOutValue;
    int numberRPs;
	int BusyRepeatRequest;
	int numberBRR;
    
    numberRPs = 0;
	numberBRR = 0;
    timeOutValue = 5000;
	//check the validity of the compare mode
    if( ! (0 == strncmp("Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("None", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) 
		|| 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode))))
	{
		TestStepFail("INFO","The CompareMode '%s' is not valid!", CompareMode);
        TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed!");
		return 0;
	}
	else
	{
		//The compare mode is valid
		CharArray2Byte(Request);              // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
		TestStep("INFO","REQUEST: %s (The compare mode is: %s)", Request, CompareMode);
		//OSEKTL_ActivateAck(1);
		OSEKTL_DataReq(RqTxData, ByteSize);   //Sending out Request in a RxTxData global byte array
		
		//START check the response from the camera: 
		do
		{ 
			//Wait for the message from the camera
			responsePending = 0;
			BusyRepeatRequest = 0;
			if(ResponseLength < 1000)
			{
				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
			}
			else if(ResponseLength < 3000)
			{
				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue*2);
			}
			else
			{
				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue*3);
			}
			if(result == 0)
			{  
				//If no response is received
				return responseMatching(CompareMode, Response, numberRPs, "Noresponse", result);
			}
			else if(result == 1)
			{    
				//If response is received
				//Negative branch starts
				if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID ) 
				{ 
					if(RsRxIntData[2] == 0x78)
					{
						TestStep("INFO","Response Pending received from ECU");
						responsePending = 1;
						numberRPs++;
						timeOutValue = 10000;
					}
					else if(RsRxIntData[2] == 0x21) //If ECU is busy
					{
						if(strlen(Response) == 6)
						{
							if((Response[4] == '2') && (Response[5] == '1'))
							{
								TestStep("INFO","Busy Repeat Request detected as expected: %s", byteString);
								return responseMatching(CompareMode, Response, numberRPs, "NRC", result);
							}
							else
							{
								BusyRepeatRequest = 1;
							}
						}
						else
						{
							BusyRepeatRequest = 1;
						}
						if(BusyRepeatRequest)
						{
							testWaitForTimeout(2000);
							OSEKTL_DataReq(RqTxData, ByteSize);
							numberBRR++;
							TestStep("INFO","Busy Repeat Request detected: %s -> Repeat last request!", byteString);
						}
					}
					else
					{
						//TestStep("INFO","Negative Response from ECU!");
						return responseMatching(CompareMode, Response, numberRPs, "NRC", result);
					}
				}
				//Positive branch starts
				if(RsRxIntData[0] == (SID + 0x40))
				{
					//TestStep("INFO","Positive Response from ECU!");
					return responseMatching(CompareMode, Response, numberRPs, "response", result);
				}	
			}
		}while(((responsePending == 1) && (numberRPs < 12)) || ((BusyRepeatRequest == 1) && (numberBRR < 32)));  //Pending and Busy Repeat response handling
	
		if(responsePending == 1)
		{
			TestStepFail("INFO","No response received after 12 response pending!");
			return 0;
		}
		if(BusyRepeatRequest == 1)
		{
			TestStepFail("INFO","The ECU is still busy after 32 tries!");
			return 0;
		}
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which send diagnostic message and check the response with specified CAN ID
//!
//! \param  char Request is the request should be sent
//! \param  char Response is the expected response should be awaited
//! \param  char CompareMode is the compare mode should be used to check the response
//! \param  int rxId is the ID of the transmit messages in CAN
//! \param  int txId is the ID of the receive messages in CAN
//! 
//! \teststep Send Diagnostic message with service 0x$1 on $5 CAN ID  
//! \testresponse Expected response is $2
//!
//! \note	The function can send a string to the ECU from the parameter (Request) and check the received message (Response). \n
//! 		String to byte conversion is needed to send and receive the string parameters, the function also includes this feature. \n
//!			Function set the transmit and receive CAN IDs to send the request message, finally it resets the default CAN IDs.
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//- -----------------------------------------------------------------------------------------------
testcase RequestResponseCanMsgId(char Request[], char Response[], char CompareMode[], int rxId, int txId)
{
	int current_txid, current_rxid;
	
	current_txid = OSEKTL_GetTxId();
	current_rxid = OSEKTL_GetRxId();
	
	if(rxId != 0 && txId !=0)
    {
		setType (rxId, txId);
    }
    else 
    {
		TestStepFail("INFO","The address (TX/RX) is not valid!");
    }   
    RequestResponseCompareLogic(Request, Response, CompareMode);
    
    //Reset the deafult CAN message IDs
    setType (current_rxid,current_txid);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that measures the time interval between a sent request and an expected response
//!
//! \param  char Request is the request should be sent
//! \param  char Response is the expected response should be awaited
//! \param  char CompareMode is the compare mode should be used
//! \param  char aTime1 is the low threshold of the expected time interval in ms
//! \param  char aTime2 is the high threshold of the expected time interval in ms
//! 
//! \teststep Send 0x$1 Diagnostic message and calculate the elapsed time till the 0x$2 Diagnostic response arrives.
//! \testresponse The response time is between the expected time interval
//! 
//! \note	This testcase sends a diagnostic request and waits for a specific response. \n
//! 		Measures the time interval between a sent request and the awaited response. \n
//! 		This time interval is compared to an expected time interval.
//- -----------------------------------------------------------------------------------------------
testcase RequestResponseTimeElapsed(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
	RequestResponseTimeElapsedFn(Request, Response, CompareMode, aTime1, aTime2);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that measures the time interval between a sent request and an expected response.
//!
//! \return No return value
//!
//! \note	See description of testcase RequestResponseTimeElapsed().
//- -----------------------------------------------------------------------------------------------
RequestResponseTimeElapsedFn(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
	byte responsePending;
	long result;
	long timeOutValue;
	int numberRPs;
	float startTime1;
	float startTime2;
	float endTime;
	int respOk;
	int i;
	float time1;
	float time2;
 
	//Init
	respOk = 0;
	endTime = 0;
	i = 0;
	time1 = 0;
	time2 = 0;
  
	time1 = atodbl(aTime1);
	time2 = atodbl(aTime2);
    
	responsePending = 0;
	numberRPs = 0;
	timeOutValue = 5000;
  
	//Check the validity of the compare mode
	if( ! (0 == strncmp("Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("None", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) 
		|| 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual", CompareMode,strlen(CompareMode))|| 0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode))))
	{
		TestStepFail("INFO","The CompareMode '%s' is not valid!", CompareMode);
		TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed!");
	}
	else
	{
		//The compare mode is valid
		    
		//Set timer (t20ms) to 20ms
		setTimer(t20ms, 20);
		//Store start time
		startTime1 = timeNow()/100.0;
  
		//START check the response from the camera: 
		do
		{ 
			if( (endTime - startTime2)/100.0 < 20.0 && (i != 0)) //
		{
			TestWaitForTextEvent("Minimum time delay is reached!", 100);
		}
		else if(  timeToElapse(t10ms) > 0 )
		{
			//long timeToElapse(mstimer t) (Form 2)			
			TestWaitForTextEvent("Maximum time delay is reached!", 100);
		}
      
  		CharArray2Byte(Request);              // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
  		TestStep("INFO","REQUEST: %s (The compare mode is: %s)", Request, CompareMode);
      
                //OSEKTL_ActivateAck(1);
  		OSEKTL_DataReq(RqTxData, ByteSize);   //Sending out Request in a RxTxData global byte array

		setTimer(t20ms, 20);
		startTime2 = timeNow()/100.0;
      
		//Wait for the message from the camera
		responsePending = 0;
		result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
                endTime = timeNow()/100.0;
      
		// if elapsed time more than 20ms, start 10ms counter
		if( (endTime - startTime2)/100.0 >= 20.0 )
	    {
		    setTimer(t10ms,10); // set timer (t10ms) to 10ms
	    }
      
		if(result == 0)
		{  
			//If no response is received
			responseMatching(CompareMode, Response, numberRPs, "Noresponse", result);
		}
		else if(result == 1)
		{    
			//If response is received
			//Negative branch starts
			if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID ) 
			{ 
				respOk = 0;
				if( RsRxIntData[2] == 0x78 )
				{
					TestStep("INFO","Response Pending received from ECU");
					responsePending = 1;
					numberRPs++;
					timeOutValue = 10000;
				}
				else
				{
					//TestStep("INFO","Negative Response from ECU!");
					responseMatching(CompareMode, Response, numberRPs, "NRC", result);
				}
			}
			//Positive branch starts
			if( RsRxIntData[0] == (SID + 0x40) )  
			{
				//TestStep("INFO","Positive Response from ECU!");
				respOk = responseMatching(CompareMode, Response, numberRPs, "response", result);
			}	
		}
		i++;
	        }while( ((responsePending == 1) && (numberRPs < 24)) || ((respOk != 1) && ((endTime - startTime1) < 35000.0)) );  //Handling of pending response  and maximum testcase duration
	        }
		if( responsePending == 1 )
		{
			TestStepFail("INFO","Timeout while waiting for diag response!");
		}

  //Evaluation of test result
	TestStep("INFO","Start Time [ms]: %f", startTime1);
	TestStep("INFO","End Time [ms]: %f", endTime);
	TestStep("INFO","Elapsed Time [ms]: %.0f", (endTime - startTime1));
  
	if((endTime - startTime1) >= 1000000.0)
	{
		testStepFail("INFO", "TestStep timeout!");
	}
	else if( (endTime - startTime1) >= time1 && (endTime - startTime1) <= time2)
	{
		testStepPass("INFO", "Elapsed time is in the expected range!");
	}
	else
	{
		testStepFail("INFO", "Elapsed time is out of the expected range!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to restore to the original CAN channel
//! 
//! \teststep Restore CAN channel   
//! \testresponse -
//!
//! \note	The ID of the original CAN channel is saved by the ChangeCanChannelFn funtion.
//- -----------------------------------------------------------------------------------------------
testcase RestoreCanChannel()
{
  RestoreCanChannelFn();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to restore to the original CAN channel
//!
//! \return No return value
//!
//! \note	See description of testcase RestoreCanChannel().
//- -----------------------------------------------------------------------------------------------
RestoreCanChannelFn()
{
   canOffline(3); 
   SetBusContext(StoredBuxContext);
   canOnline(3);
   testStepPass("INFO","CAN channel restored to %x",StoredBuxContext);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which sets the value of the given environment variable to a previously stored value
//!
//! \param  char EnvvarName is the name of the environment variable which value should be set
//! 
//! \teststep Restore $1 signal's value   
//! \testresponse -
//! 
//! \note	This test case is mostly used after the SaveSignalValue test case to restore the value
//!			of a specific signal by it's environment variable.
//- -----------------------------------------------------------------------------------------------
testcase RestoreSignalValue (char EnvvarName[])
{
    putValue (EnvvarName, StoredSignalValue);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which stores the value of the given environment variable
//!
//! \param  char EnvvarName is the name of the environment variable which value should be stored
//! 
//! \teststep Save $1 signal's value   
//! \testresponse -
//!
//! \note	This test case is mostly used to store signal values by using it's environment variable.
//- -----------------------------------------------------------------------------------------------
testcase SaveSignalValue (char EnvvarName[])
{
    StoredSignalValue = getValue (EnvvarName);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Set an environment varible to a desired value
//!
//! \param  char Name The name of the desired environment variable
//! \param  char Value The desired value
//! \param  long WaitTime The necessary waiting time after the setting of the selected environment variable
//! 
//! \teststep Set the $1 to $2 and wait $3
//! \testresponse -
//! 
//! \note The following environment variable types are supported: Integer, Float, String.
//! 	  The function will convert the desired value to the proper type
//- -----------------------------------------------------------------------------------------------
testcase SetEnvVar(char Name[], char Value[], long WaitTime)
{
    function_SetEnvVar(Name, Value, WaitTime);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Set an environment varible to a desired value
//!
//! \return No return value
//!
//! \note See description of testcase SetEnvVar().
//- -----------------------------------------------------------------------------------------------
function_SetEnvVar(char Name[], char Value[], long WaitTime)
{
    int intValue;
	float floatValue;
	
	if(1 == str_match_regex(Value, "^(\\d+)$")) //int
	{
		intValue = atol(Value);
		strtod(Value, floatValue);
		putValue(Name, intValue);
		putValue(Name, floatValue);
        TestStepPass("Passed","The %s envvar (int) value was set to %s .", Name, Value);	
	}
	else if(1 == str_match_regex(Value, "^(\\d+(\\.\\d+)?)$")) //float
	{
		strtod(Value, floatValue);
		putValue(Name, floatValue);
        TestStepPass("Passed","The %s envvar (float) value was set to %s .", Name, Value);	
	}
	else //string
	{
		putValue(Name, Value);
        TestStepPass("Passed","The %s envvar (string) value was set to %s .", Name, Value);	
	}
	if(WaitTime == 0) //Handling to avoid infinite loop
	{
		TestWaitForTimeout(1);
	}
	else
	{
		TestWaitForTimeout(WaitTime);
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which sets the value of the given environment variable to a specified value PLUS the offset
//!
//! \param  char EnvvarName is the name of the environment variable which value should be set
//! \param  char value is the base value
//! \param  char offset is the offset added to the base value
//! 
//! \teststep Set the $1 environment variable to $2 with $3 offset
//! \testresponse -
//!
//! \note	 This test case can be used as a way to use predefined variables, then use it as a base value.
//!        Examle usage: (set to the param value)
//!                      #) SetEnvvarTo (string EnvvarName ENV_NAME_YOU_KNOW, string value @some_param@, string offset 0)
//!                      
//!                      (set to less than the value)
//!                      #) SetEnvvarTo (string EnvvarName ENV_NAME_YOU_KNOW, string value @some_param@, string offset -13)
//- -----------------------------------------------------------------------------------------------
testcase SetEnvvarTo(char EnvvarName[], char value[], char offset[])
{
  double value_db;
  double offset_db;
    
  value_db = atodbl(value);
  offset_db = atodbl(offset);
  
  putValue (EnvvarName, value_db + offset_db);
   TestStepPass("INFO","The value of the variable is now equal with the given value + offset value.  OK" );
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Opens a picture.
//! Usage: #) showPicture(string PicturePath "C:\Users\Public\Pictures\Sample Pictures\Chrysanthemum.jpg")
//!
//! \param char PicturePath[] is the path of the needed picture
//! 
//! \teststep Show picture $1 to the camera
//! \testresponse Picture $1 is open
//- -----------------------------------------------------------------------------------------------
testcase showPicture(char PicturePath[])
{
	function_showPicture(PicturePath);	
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to open a picture.
//! Usage: #) showPicture(string PicturePath "C:\Users\Public\Pictures\Sample Pictures\Chrysanthemum.jpg")
//!
//! \return No return value
//!
//! \note See description of testcase showPicture().
//- -----------------------------------------------------------------------------------------------
function_showPicture(char PicturePath[])
{
	clearArray(command_buffer);
	pathEscape(PicturePath);
	if(sysExecCmd(command_buffer,"& exit")) TestStepPass("INFO","The picture has been opened.  OK" );
	else TestStepFail("INFO","Can not open the given path! ERROR");	
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to test the changing of the given two signals in a message against the given signal values
//!
//! \param  signal firstSingalName is the name of the first signal to be tested
//! \param  float firstAssumedValue is the assumed signal value of the first signal at the begining of the test
//! \param  cfloat firstExpectedValue is the expected signal value of the first signal at the end of the test
//! \param  signal secondSingalName is the name of the second signal to be tested
//! \param  float secondAssumedValue is the assumed signal value of the second signal at the begining of the test
//! \param  cfloat secondExpectedValue is the expected signal value of the second signal at the end of the test
//! \param  char MessageName is the message what contains the signals
//! 
//! \teststep Check that 2 signal ($1,$4) values are equal to $2,$5 at the begining and $3,$6 at the end of the test
//! \testresponse Signal ($1,$4) values were equal to the expected values at begining and end of the test
//- -----------------------------------------------------------------------------------------------
testcase SignalMonitoring(signal * firstSingalName, float firstAssumedValue, float firstExpectedValue,signal * secondSingalName, float secondAssumedValue, float secondExpectedValue, char MessageName[] )
{
  int changeOccured;
  float firstSignalActualValue;
  float secondSignalActualValue;
  dword MessageID;
  long Timeout;
  int i;
  
  changeOccured = 0;
  firstSignalActualValue = 0;
  secondSignalActualValue = 0;
  MessageID = GetMessageID(MessageName);
  Timeout = 1000;
  i = 0;
  
    while (changeOccured == 0 && i < 15000)
    {
      firstSignalActualValue = getsignal(firstSingalName);
      secondSignalActualValue = getsignal(secondSingalName);
      
      if (firstSignalActualValue == firstAssumedValue && secondSignalActualValue ==  secondAssumedValue)
      {
        changeOccured = 0;
        TestStep("INFO","The values of the monitored signals did not change.");
      }
      else if (firstSignalActualValue != firstAssumedValue && secondSignalActualValue ==  secondAssumedValue)
      {
        changeOccured = 1;
        TestStep("INFO","The value of the %s signal changed to %f", firstSingalName.name, firstSignalActualValue);
        continue;
      }
      else if (firstSignalActualValue == firstAssumedValue && secondSignalActualValue !=  secondAssumedValue)
      {
        changeOccured = 2;
        TestStep("INFO","The value of the %s signal changed to %f", secondSingalName.name, secondSignalActualValue);
        continue;
      }
      else if (firstSignalActualValue != firstAssumedValue && secondSignalActualValue !=  secondAssumedValue)
      {
        changeOccured = 3;
        TestStep("INFO","The value of the %s signal changed to %f", firstSingalName.name, firstSignalActualValue);
        TestStep("INFO","The value of the %s signal changed to %f", secondSingalName.name, secondSignalActualValue);
        continue;
      }
      
      if(i == 0 && firstSignalActualValue == firstExpectedValue && secondSignalActualValue == secondExpectedValue)
      { 
        changeOccured = -1;
        // if at the begining, the signals ALREADY have the expected value
		TestStep("INFO:","Assumed value is not present at the time when the function is called.");
      }
      
      TestWaitForMessage(MessageID, Timeout);   // kicserelve, hogy ne spammelje tele a html-t
      
      i++;
    }
    if (i!=15000)
    {
      if (i == 1 && changeOccured == -1)
      {
        testStepFail("INFO", "The monitored signals already have the expected values.");
      }
      else if(firstSignalActualValue == firstExpectedValue && secondSignalActualValue == secondExpectedValue)
      {
        testStepPass("INFO", "The monitored signals have the expected values.");
      }
      else if(firstSignalActualValue == firstExpectedValue && secondSignalActualValue != secondExpectedValue)
      {
        TestStep("INFO","The %s signal has the expected value", firstSingalName.name);
        TestStepFail("INFO","The %s signal doesn't have the expected value", secondSingalName.name);
      }
      else if(firstSignalActualValue != firstExpectedValue && secondSignalActualValue == secondExpectedValue)
      {
        TestStep("INFO","The %s signal has the expected value", secondSingalName.name);
        TestStepFail("INFO","INFO","The %s signal doesn't have the expected value", firstSingalName.name);
      }
      else
      {
        TestStepFail("INFO","None of the monitored signals have the expected value");
      }
    }
    else
    {
      testStepFail("INFO", "TestStep timeout!");
    }
}


//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to check if the specified signal values remain unchanged for a specified time
//!
//! \param  signal firstSingalName is the name of the first signal to be tested
//! \param  cfloat firstExpectedValue is the expected signal value of the first signal
//! \param  signal secondSingalName is the name of the second signal to be tested
//! \param  cfloat secondExpectedValue is the expected signal value of the second signal
//! \param  char MessageName is the message what contains the signals
//! \param  long supressTime is the time the signal should not change
//! 
//! \teststep Check that 2 signals ($1,$3) holds there expected values ($2,$4) for $5 time [ms]
//! \testresponse Signal ($1,$3) values were equal to the expected values for $5 time[ms]
//- -----------------------------------------------------------------------------------------------
testcase SignalMonitoringStable(signal * firstSingalName, float firstExpectedValue,signal * secondSingalName, float secondExpectedValue, char MessageName[], long supressTime )
{
  int changeOccured;
  float firstSignalActualValue;
  float secondSignalActualValue;
  dword MessageID;
  long Timeout;
  long result;
  long i;
  
  changeOccured = 0;
  firstSignalActualValue = 0;
  secondSignalActualValue = 0;
  MessageID = GetMessageID(MessageName);
  Timeout = 1001;
  result = 1;
  i = 0;
  
  supressTime = supressTime / 20;
  
 // suppressed testcase
    while (changeOccured == 0 && i < supressTime && result == 1)
    {
      firstSignalActualValue = getsignal(firstSingalName);
      secondSignalActualValue = getsignal(secondSingalName);
      
      if (firstSignalActualValue == firstExpectedValue && secondSignalActualValue ==  secondExpectedValue)
      {
        changeOccured = 0;
        //TestStep("INFO","The values of the monitored signals did not change.");
      }
      else
      {
        changeOccured = 1;
        TestStep("INFO","The value of the %s signal is: %f", firstSingalName.name, firstSignalActualValue);
        TestStep("INFO","The value of the %s signal is: %f", secondSingalName.name, secondSignalActualValue);
      }
      result = TestWaitForMessage(MessageID, Timeout);   // kicserelve, mert kell a visszateresi erteke!
      
      i++;
    }
    
    if(i==supressTime && result == 1)
    {
      testStepPass("INFO", "The values of the monitored signals did not change during the monitored time-period.");
    }
    else if (i <= supressTime && result == 0 && changeOccured == 0 )
    {
		testStep("INFO", "The requested message may not exist, TestWaitForMessage returned with timeout" );
      testStepPass("INFO", "The values of the monitored signals did not change. The sequence ended!");
    }
    else if (result == -2) 
    {
      TestStepFail("INFO","Constraint violation!");
    }
    else
    {
      TestStepFail("INFO","The values of the monitored signals CHANGED during the monitored time-period!");
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to check if the specified signal values remain unchanged for a specified time, given by the messageTime param
//!
//! \param  signal firstSingalName is the name of the first signal to be tested
//! \param  cfloat firstExpectedValue is the expected signal value of the first signal
//! \param  signal secondSingalName is the name of the second signal to be tested
//! \param  cfloat secondExpectedValue is the expected signal value of the second signal
//! \param  char MessageName is the message what contains the signals
//! \param  long supressTime is the time the signal should not change
//! \param  long messageTime is the time the expected message arrives regularly
//! 
//! \teststep Check that 2 signals ($1,$3) holds there expected values ($2,$4) for $6 time [ms]
//! \testresponse Signal ($1,$3) values were equal to the expected values for $6 time[ms]
//- -----------------------------------------------------------------------------------------------
testcase SignalMonitoringStableExtended(signal * firstSingalName, float firstExpectedValue,signal * secondSingalName, float secondExpectedValue, char MessageName[], long supressTime, long messageTime )
{
  int changeOccured;
  float firstSignalActualValue;
  float secondSignalActualValue;
  dword MessageID;
  long Timeout;
  long result;
  long i;
  
  changeOccured = 0;
  firstSignalActualValue = 0;
  secondSignalActualValue = 0;
  MessageID = GetMessageID(MessageName);
  Timeout = 1001;
  result = 1;
  i = 0;
  
  supressTime = supressTime / messageTime;
  
 // suppressed testcase
    while (changeOccured == 0 && i < supressTime && result == 1)
    {
      firstSignalActualValue = getsignal(firstSingalName);
      secondSignalActualValue = getsignal(secondSingalName);
      
      if (firstSignalActualValue == firstExpectedValue && secondSignalActualValue ==  secondExpectedValue)
      {
        changeOccured = 0;
        //TestStep("INFO","The values of the monitored signals did not change.");
      }
      else
      {
        changeOccured = 1;
        TestStep("INFO","The value of the %s signal is: %f", firstSingalName.name, firstSignalActualValue);
        TestStep("INFO","The value of the %s signal is: %f", secondSingalName.name, secondSignalActualValue);
        continue;
      }
      result = TestWaitForMessage(MessageID, Timeout);   // kicserelve, mert kell a visszateresi erteke!
      
      i++;
    }
    
    if(i==supressTime && result == 1)
    {
      testStepPass("INFO", "The values of the monitored signals did not change during the monitored time-period.");
    }
    else if (i <= supressTime && result == 0 && changeOccured == 0 )
    {
		testStep("INFO", "The requested message may not exist, TestWaitForMessage returned with timeout" );
      testStepPass("INFO", "The values of the monitored signals did not change. The sequence ended!");
    }
    else if (result == -2) 
    {
      TestStepFail("INFO","Constraint violation!");
    }
    else
    {
      TestStepFail("INFO","The values of the monitored signals CHANGED during the monitored time-period!");
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to check if the specified signal values remain unchanged for a specified time, given by the messageTime param
//!
//! \param  signal firstSingalName is the name of the first signal to be tested
//! \param  cfloat firstExpectedValue is the expected signal value of the first signal
//! \param  signal secondSingalName is the name of the second signal to be tested
//! \param  cfloat secondExpectedValue is the expected signal value of the second signal
//! \param  char MessageName is the message what contains the signals
//! \param  long supressTime is the time the signal should not change
//! 
//! \teststep Check that 2 signals ($1,$3) holds there expected values ($2,$4) for $6 time [ms]
//! \testresponse Signal ($1,$3) values were equal to the expected values for $6 time[ms]
//- -----------------------------------------------------------------------------------------------
testcase SignalMonitoringStableExtended (signal * firstSingalName, float firstExpectedValue,signal * secondSingalName, float secondExpectedValue, char MessageName[], long supressTime)
{
  int changeOccured;
  float firstSignalActualValue;
  float secondSignalActualValue;
  dword MessageID;
  long Timeout;
  long result;
  long i;
  long startTime;
  long endTime;
	
  endTime = timeNow()/100.0;	 
  changeOccured = 0;
  firstSignalActualValue = 0;
  secondSignalActualValue = 0;
  MessageID = GetMessageID(MessageName);
  Timeout = 1001;
  result = 1;
  i = 0;
  startTime = timeNow()/100.0;
   
 // suppressed testcase
    while (changeOccured == 0 && supressTime > (endTime - startTime) && result == 1)
    {
      firstSignalActualValue = getsignal(firstSingalName);
      secondSignalActualValue = getsignal(secondSingalName);
      
      if (firstSignalActualValue != firstExpectedValue || secondSignalActualValue !=  secondExpectedValue)
      {
        changeOccured = 1;
        TestStep("INFO","The value of the %s signal is: %f", firstSingalName.name, firstSignalActualValue);
        TestStep("INFO","The value of the %s signal is: %f", secondSingalName.name, secondSignalActualValue);
      }
      result = TestWaitForMessage(MessageID, Timeout);
      endTime = timeNow()/100.0;
    }
    
    if(result == 1 && changeOccured == 0)
    {
      testStepPass("INFO", "The values of the monitored signals did not change during the monitored time-period.");
    }
    else if (result == 0)
    {
		testStep("INFO", "The requested message may not exist, TestWaitForMessage returned with timeout" );
      testStepPass("INFO", "Timeout occurred in %s", MessageName);
    }
    else if (result == -2) 
    {
      TestStepFail("INFO","Constraint violation!");
    }
    else if(changeOccured == 1)
    {
      TestStepFail("INFO","The values of the monitored signals CHANGED during the monitored time-period!");
    }
	else{
		TestStepFail("INFO","Other error occurred!");
	}
}

//- ----------------------------------------------------------------------------------------------------
//! \brief  Testcase to start an ADTF sequence or recording and wait for the sequence or recording start
//!
//!	\param  char measurementFolder[] is the the folder that contains the MEA
//! \param  char mode[] is the operating mode of the ADTF. It can be Playback or StartStopRecording
//! \param  char sequenceFolder[] is the folder that contains the sequence. If you start ADTF in StartStopRecording mode, use "" or "-"
//! \param  char sequenceName[] is the sequence file. If you start ADTF in StartStopRecording mode, use "" or "-"
//! 
//! \teststep Start ADTF from the $1 folder in $2 mode with $4 sequence
//! \testresponse ADTF starting has executed
//!
//! \note   You should give the full path of the folder with double backslashes, like this:
//! 		"c:\\Users\\abd2bp\\Documents\\Messtechnik\\JLR_143_RC02"
//- ----------------------------------------------------------------------------------------------------
testcase StartADTF(char measurementFolder[], char mode[], char sequenceFolder[], char sequenceName[])
{
  char filters[200];
  char envvarCommand[250];
  char commandParameters[300];
  char startCommand[400];
  char adtfPath[200];
  dword fileHandle;
  char adtf_started[2];
  int i;
  int error=0;
  char isExisting[30];
  
  strncpy(adtf_started,"0",elcount(adtf_started));
  
  setFilePath("c:\\unilogger",2);
  fileHandle=openFileWrite("adtf_phase.txt",0);
  filePutString("0",elcount("0"),fileHandle);
  fileClose(fileHandle);

  //concatenate the file path to set the environment variable for plugins
  if(strncmp(measurementFolder,"",elcount(measurementFolder))==0 || strncmp(measurementFolder,"",elcount(measurementFolder))==0)
  {
      testStepFail("INFO","There isn't any working folder given!");
      error=1;
  }
  else
  {
      snprintf(filters,elcount(filters),"");
      snprintf(envvarCommand,elcount(envvarCommand),"");
      strncpy(filters,measurementFolder,elcount(filters));
      strncat(filters,"\\filter",elcount(filters));
      strncpy(envvarCommand,"SET ADTF2_COMPONENT_DIR=",elcount(envvarCommand));
      strncat(envvarCommand,filters,elcount(envvarCommand));
  }
 
  //concatenate the ADTF start command
  snprintf(commandParameters,elcount(commandParameters),"");
  strncpy(commandParameters," -project=",elcount(commandParameters));
  strncat(commandParameters,measurementFolder,elcount(commandParameters));
  strncat(commandParameters,"\\adtf_workspace\\mea.prj -active=",elcount(commandParameters));
  if(strncmp(mode,"Playback",elcount(mode))==0)
  {
      if(strncmp(sequenceName,"",elcount(sequenceName))==0 || strncmp(sequenceFolder,"",elcount(sequenceFolder))==0 || strncmp(sequenceName,"-",elcount(sequenceName))==0 || strncmp(sequenceFolder,"-",elcount(sequenceFolder))==0)
      {
          testStepFail("INFO","The given mode is Playback, but there isn't any given sequence or the containing folder of it!");
          error=1;
      }
      else
      {
    	    preparePlaylist(measurementFolder, sequenceName);
    	  
          strncat(commandParameters,"Playback -playlist=",elcount(commandParameters));
          strncat(commandParameters,measurementFolder,elcount(commandParameters));
          strncat(commandParameters,"\\playlist.datpls -globals=C:\\TOOLS\\COMMON\\ADTF\\2.9-win64_vc100\\bin\\globals.xml -run -nosplash -quit",elcount(commandParameters));
      }
  }
  else if(strncmp(mode,"StartStopRecording",elcount(mode))==0)
  {
      if((strncmp(sequenceName,"",elcount(sequenceName))!=0 && strncmp(sequenceName,"-",elcount(sequenceName))!=0) || (strncmp(sequenceFolder,"",elcount(sequenceFolder))!=0 && strncmp(sequenceFolder,"-",elcount(sequenceFolder))!=0))
      {
          testStepFail("INFO","The given mode is StartStopRecording, but there's a sequence or the containing folder of it given!");
          error=1;
      }
      else
      {
 	        strncat(commandParameters,"StartStopRecording -globals=C:\\TOOLS\\COMMON\\ADTF\\2.9-win64_vc100\\bin\\globals.xml -run -nosplash",elcount(commandParameters)); 	  
      }
  }
  else 
  {
      testStepFail("INFO","The given mode is invalid!");
      error=1;
  }
  
  snprintf(startCommand,elcount(startCommand),"");
  strncpy(startCommand,"c:\\TOOLS\\COMMON\\ADTF\\2.9-win64_vc100\\bin\\adtf_devenv.exe",elcount(startCommand));
  strncat(startCommand,commandParameters,elcount(startCommand));
  
  //write commands to batch file
  setWritePath("c:\\temp");
  fileHandle=openFileWrite("startADTF.bat",0);
  if(strncmp(mode,"Playback",elcount(mode))==0)
  {
  	  filePutString("xcopy ",elcount("xcopy "),fileHandle);
  	  filePutString(sequenceFolder,elcount(sequenceFolder),fileHandle);
  	  filePutString("\\",elcount("//"),fileHandle);
  	  filePutString(sequenceName,elcount(sequenceName),fileHandle);
  	  filePutString(" c:\\temp\\ /D /y",elcount(" c:\\temp\\ /D /y"),fileHandle);
      filePutString(" > c:\\temp\\isExisting.txt",elcount(" > c:\\temp\\isExisting.txt"),fileHandle);
      filePutString("\n",elcount("\n"),fileHandle);
  }
  filePutString(envvarCommand,elcount(envvarCommand),fileHandle);
  filePutString("\n",elcount("\n"),fileHandle);
  filePutString(startCommand,elcount(startCommand),fileHandle);
  filePutString("\n",elcount("\n"),fileHandle);
  if(strncmp(mode,"Playback",elcount(mode))==0)
  {
      filePutString("del /f /q c:\\temp\\",elcount("del /f /q c:\\temp\\"),fileHandle);
      filePutString(sequenceName,elcount(sequenceName),fileHandle);
      filePutString("\n",elcount("\n"),fileHandle);
      filePutString("del /f /q c:\\temp\\isExisting.txt",elcount("del /f /q c:\\temp\\isExisting.txt"),fileHandle);
      filePutString("\n",elcount("\n"),fileHandle);
  }
  filePutString("exit",elcount("exit"),fileHandle);
  filePutString("\n",elcount("\n"),fileHandle);
  fileClose(fileHandle);
  
    //open the batch file
    if(error == 0) 
    {  
        sysExecCmd("start c:\\temp\\startADTF.bat & exit","","c:\\temp");
        WaitForADTFStartFunction(adtf_started);
        setFilePath("c:\\temp",0);
		fileHandle=openFileRead("isExisting.txt",0);
		fileGetString(isExisting,elcount(isExisting),fileHandle);
		fileClose(fileHandle);
        if(strstr(isExisting,"0 File(s) copied") != -1)
        {
            TestStepFail("INFO","The given sequence file or sequence folder doesn't exist!");
        }
        if(strncmp(adtf_started,"1",elcount(adtf_started)) == 0)
        {
            setFilePath("c:\\unilogger",2);
            fileHandle=openFileWrite("adtf_phase.txt",0);
            filePutString("0",elcount("0"),fileHandle);
            fileClose(fileHandle);
            testStepPass("INFO","The ADTF successfully started in %s mode.",mode);    
        }
        else
        {
            testStepFail("INFO","The running of the ADTF sequence or recording couldn't start.");
        }
    }
    else testStepFail("INFO","The running of the ADTF sequence or recording couldn't start.");
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase for starting a specified HIL sequence
//!
//! \param  char source[] contains the full path of the HIL input sequence
//! \param  char destination[] contains the path of the destination folder of output sequence
//! \param  char dbcName[] contains the name of the dbc used by HIL
//! \param  char HILrecordingEXT[] contains the extension string to concatenate to the output sequence name
//! 
//! \teststep Start HIL sequence $1
//! \testresponse Sequence started
//- -----------------------------------------------------------------------------------------------
testcase StartAndWaitHIL(char source[], char destination[], char dbcName[], char HILrecordingEXT[])
{
	char FileName[25];
	char command[15];
    char params[100];
    char commandPath[35];
	
	strncpy(FileName, "temp_HIL_playlist.xml", elcount("temp_HIL_playlist.xml"));
	strncpy(command, "HILConsole.exe", elcount("HILConsole.exe"));
	strncpy(params, dbcName, elcount(dbcName));
	strncat(params, " C:\\temp\\", elcount(params));
	strncat(params, FileName, elcount(params));
	strncat(params, " true true false", elcount(params));
	strncpy(commandPath, "C:\\BOSCH_IDT\\HIL\\Release\\bin", elcount("C:\\BOSCH_IDT\\HIL\\Release\\bin"));
	
	WriteXMLPlaylistForHIL_function(source, destination, HILrecordingEXT, FileName);
	executeCommand_function(command, params, commandPath);
	WaitForHILSequenceStart_function();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Starts the video specified in the parameter: VideoPath
//! Usage: #) startVideo( string VideoPath s:\02_labt\labt_bp_video_seq\rsf\20_sl.mp4, string MonitorNum 2, string Loop yes)
//!
//! \param  char VideoPath[] The path of the video
//! \param  char MonitorNum[] Expects one number, greater than zero
//! \param  char Loop[] "Yes" or "Y" or "1" if you want play repeatedly, anything else if not
//! 
//! \teststep Start video $1
//! \testresponse $1 video is has started
//!
//! \note Its important to check "View > Options > Playback > Repeat forever" radio-button before the first launch!
//! \note The testcase needs (500ms + time of video opening) 
//- -----------------------------------------------------------------------------------------------
testcase startVideo(char VideoPath[], char MonitorNum[], char Loop[])
{
    function_startVideo(VideoPath, MonitorNum, Loop);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to start the video specified in the parameter: VideoPath
//! Usage: #) startVideo( string VideoPath s:\02_labt\labt_bp_video_seq\rsf\20_sl.mp4, string MonitorNum 2, string Loop yes)
//!
//! \return No return value
//!
//! \note See description of testcase startVideo().
//- -----------------------------------------------------------------------------------------------
function_startVideo(char VideoPath[], char MonitorNum[], char Loop[])
{
    // Usage: 
    // #) startVideo( string VideoPath s:\02_labt\labt_bp_video_seq\rsf\20_sl.mp4, string MonitorNum 2, string Loop yes)
    char CloseOrNotClose[100];
    char command[500];
    char homecinemaPath[100];
    char homecinemaPathAlternate[100];
	char TACmedia[100];
	char TACmonitor[100];
	int tac_sw_valid, tac_monitor_valid;
	tac_sw_valid = 0;
	clearArray(homecinemaPath);
	if(getTACConfFile("[MEDIA]") == 1)
	{
		if(getTACConfFileParam("SW=") == 1) //SW PATH
		{
			strncpy(homecinemaPath, TACStringParam, 100); //SET TAC MEDIAPATH FOR USING
			if(getTACConfFileParam("EXE=") == 1) //EXE
			{
				strncpy(TACmedia, TACStringParam, 100);
			}
			else
			{
				TestStep("TAC","The media exe file 'EXE=' not found in the TAC, therefore the default media player will be used: 'mpc-hc64.exe'");
				strncpy(TACmedia, "mpc-hc64.exe", 100);
			}
			tac_sw_valid = 1;
		}
		else
		{
			TestStep("TAC","The media path 'SW=' not found in the TAC, therefore the default media player will be used: 'C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe'");
			strncpy(homecinemaPath, "C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe", 100);
		}
	}
    else
	{
		// ---------------- homecinemaPath
		strncpy(homecinemaPath, "C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe", 100);
	}
	strncpy(homecinemaPathAlternate, "C:\\Program Files (x86)\\Media Player Classic - Home Cinema", 100);
	// ---------------- Path escaping
	pathEscape(VideoPath);
	TestWaitForTimeout(100);
	// ---------------- Monitor to play on
	TestWaitForTimeout(100);
	if(getTACConfFile("[MONITOR]") == 1)
	{
		tac_monitor_valid = 0;
		if(getTACConfFileParam("ID=") == 1) //MONITOR ID
		{
			strncpy(TACmonitor, TACStringParam, 100);
			tac_monitor_valid = 1;
		}
		else
		{
			TestStep("TAC","The monitor ID was not found in the TAC file, therefore the default parameter will be used: %s", MonitorNum);
		}
	}
	if(tac_monitor_valid)
	{
		if(atol(TACmonitor) > 0 && atol(TACmonitor) < 4)
		{ 
			ltoa(atol(TACmonitor), TACmonitor, 10);
		}
		else
		{
			strncpy(TACmonitor, "1", 10);
		}
	}
	else if(atol(MonitorNum) > 0 && atol(MonitorNum) < 4)
	{ 
		ltoa(atol(MonitorNum), MonitorNum, 10);
	}
	else
	{
		strncpy(MonitorNum, "1", 10);
	}
	// ---------------- Close after one sequence?
	toLower(Loop,Loop,elcount(Loop));
	TestWaitForTimeout(100);
	if(strncmp(Loop,"yes",elcount("yes"))==0 || strncmp(Loop,"1",elcount("1"))==0 || strncmp(Loop,"y",elcount("y"))==0)
	{
		strncpy(CloseOrNotClose,"", 10);
	}
	else
	{
		strncpy(CloseOrNotClose," /close", 10);
	}
	// ---------------- Command concat
	TestWaitForTimeout(100);
	// sysExecCmd( "mpc-hc.exe", "s:\\02_labt\\labt_bp_video_seq\\rsf\\20_sl.mp4 /play /fullscreen /monitor 2","C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe"  )
	clearArray(command); // clear command array
	strncat(command, command_buffer , 500);
	strncat(command, " /play /fullscreen /monitor 1", 500);
	if(tac_monitor_valid)
	{
		TestStep("TAC","The monitor ID was used from TAC: '%s'", TACmonitor);
		strncat(command, TACmonitor, 500);
	}
	else
	{
		strncat(command, MonitorNum, 500);	
	}
	strncat(command, CloseOrNotClose, 500);	
	strncat(command, " & exit", 500);
	// ---------------- Command execute 
	TestWaitForTimeout(100);
	if(tac_sw_valid)
	{
		TestStep("TAC","The media path was used from TAC: '%s', exe file: '%s'", homecinemaPath, TACmedia);
		if(sysExecCmd(TACmedia, command, homecinemaPath))
		{
			TestStepPass("TAC","The video has been started from TAC parameters.  OK");
		}
		else
		{
			TestStepFail("TAC","Can not execute the given command from TAC! ERROR");
		}
	}
	else if(sysExec("C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe", command))
	{
		// TestStep("Command", command );
		TestStepPass("INFO","The video has been started.  OK" );
		// TestStep("Program path", homecinemaPath);
	}
	else if(sysExecCmd("mpc-hc.exe", command, homecinemaPathAlternate))
	{
		// TestStep("Command", command );
		TestStepPass("INFO","The video has been started, on alternate location.  OK");
	}
	else
	{
		TestStep("Program path", homecinemaPath);
		TestStep("Program path alternate", homecinemaPathAlternate);
		TestStep("Escaped path", command_buffer );
		TestStep("Monitor num", MonitorNum );
		TestStep("Loop? ", Loop );
		TestStep("Command", command );
		TestStepFail("INFO","Can not execute the given command! ERROR");
	}
}

//- ----------------------------------------------------------------------------------------------------
//! \brief  Testcase to stop ADTF
//! 
//! \teststep Stop ADTF
//! \testresponse ADTF stopped
//- ----------------------------------------------------------------------------------------------------
testcase StopADTF()
{
  dword fileHandle; 
  
  TestWaitForTimeout(5000);
  sysExecCmd("taskkill /IM adtf_devenv.exe & exit","");
  TestWaitForTimeout(3000);
  setWritePath("c:\\unilogger");
  fileHandle=openFileWrite("adtf_phase.txt",0);
  filePutString("0",elcount("0"),fileHandle);
  fileClose(fileHandle);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Stops the current video playback (shows a BLACK screen instead)
//! Usage: #) stopVideo()
//! 
//! \teststep Stop video
//! \testresponse Video is stopped
//- -----------------------------------------------------------------------------------------------
testcase stopVideo()
{
    function_stopVideo();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to stop the current video playback (shows a BLACK screen instead)
//! Usage: #) stopVideo()
//!
//! \return No return value
//! 
//! \note See description of testcase stopVideo().
//- -----------------------------------------------------------------------------------------------
function_stopVideo()
{
    char homecinemaPath[100];
    char homecinemaPathAlternate[100];
	char TACmedia[100];
	int tac_sw_valid;
	tac_sw_valid = 0;
    // ---------------- homecinemaPath
    clearArray(homecinemaPath);
	if(getTACConfFile("[MEDIA]") == 1)
	{
		if(getTACConfFileParam("SW=") == 1) //SW PATH
		{
			strncpy(homecinemaPath, TACStringParam, 100); //SET TAC MEDIAPATH FOR USING
			if(getTACConfFileParam("EXE=") == 1) //EXE
			{
				strncpy(TACmedia, TACStringParam, 100);
			}
			else
			{
				TestStep("TAC","The media exe file 'EXE=' not found in the TAC, therefore the default media player will be used: 'mpc-hc64.exe'");
				strncpy(TACmedia, "mpc-hc64.exe", 100);
			}
			tac_sw_valid = 1;
		}
		else
		{
			TestStep("TAC","The media path 'SW=' not found in the TAC, therefore the default media player will be used: 'C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe'");
			strncpy(homecinemaPath, "C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe", 100);
		}
	}
	else
	{
		strncpy(homecinemaPath, "C:\\Program Files\\MPC HomeCinema\\mpc-hc64.exe", 100);
	}
    strncpy(homecinemaPathAlternate, "C:\\Program Files (x86)\\Media Player Classic - Home Cinema", 100);
    // ---------------- Command execute 
	if(tac_sw_valid)
	{
		TestStep("TAC","The media path was used from TAC: '%s', exe file: '%s'", homecinemaPath, TACmedia);
		if(sysExecCmd(TACmedia, "S:\\02_LabT\\LabT_BP_video_seq\\LKW_LDW\\BLACK_screen.mp4 & exit", homecinemaPath))
		{
			TestStepPass("TAC","The video has been stopped from TAC parameters.  OK");
		}
		else
		{
			TestStepFail("TAC","Can not execute the given command from TAC! ERROR");
		}
	}
    else if(sysExecCmd("mpc-hc.exe", "S:\\02_LabT\\LabT_BP_video_seq\\LKW_LDW\\BLACK_screen.mp4 & exit" , homecinemaPath))
    {
        TestStepPass("INFO","The current video has been stopped.  OK" );
    }
	else if(sysExecCmd("mpc-hc.exe", "S:\\02_LabT\\LabT_BP_video_seq\\LKW_LDW\\BLACK_screen.mp4 & exit" , homecinemaPathAlternate))
    {
        TestStepPass("INFO","The current video has been stopped, on alternate location.  OK");
    }
    else
    {
        TestStep("Program path", homecinemaPath);        
        TestStep("Program path", homecinemaPathAlternate);        
        TestStep("File path", "S:\\02_LabT\\LabT_BP_video_seq\\LKW_LDW\\BLACK_screen.mp4");
        TestStepFail("INFO","Can not execute the given command! ERROR");	
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The testcase will bring up a Popup window where the tester confirmation is necessary to continue the testcase
//!
//! \param  char Text The text what the Popup window will contains
//! 
//! \teststep Wait for tester confirmation
//! \testresponse $1
//- -----------------------------------------------------------------------------------------------
testcase TesterConfirmation(char Text[])
{
    function_TesterConfirmation(Text);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  The testcase will bring up a Popup window where the tester confirmation is necessary to continue the testcase
//!
//! \return No return value
//!
//! \note See description of testcase TesterConfirmation().
//- -----------------------------------------------------------------------------------------------
function_TesterConfirmation(char Text[])
{
    long result;
	result = TestWaitForTesterConfirmation(Text);
	switch(result)
	{
		case 0:
			TestStepFail("INFO","Timeout occurred.");	
        break;
		case 1:
			TestStepPass("INFO","The tester clicked: Yes.");	
        break;
		case 2:
			TestStepFail("INFO","The tester clicked: No.");	
        break;
		case -1:
			TestStepFail("INFO","General error, e.g. due to a call outside of a test sequence.");	
        break;
		case -2:
			TestStepFail("INFO","Constraint occurred.");	
        break;
		default:
			TestStepFail("INFO","Incorrect result.");
		break;
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that saves timestamp for end time, calculates the time elapsed from the start time saved 
//! 		with testcase TimeNowStart and compares it to an expected time interval
//!
//! \param  char aTime1 is the low threshold of the expected time interval
//! \param  char aTime2 is the high threshold of the expected time interval
//! 
//! \teststep Save measurement timestamp and do the time interval calculation
//! \testresponse Elapsed time is between the expected time range
//!
//! \note   testcase TimeNowStart() must be called before this testcase!
//- -----------------------------------------------------------------------------------------------
testcase TimeNowEnd(char aTime1[], char aTime2[])
{    
	float time1;
	float time2;
	float tMesEnd;
  
	time1 = 0;
	time2 = 0;
	
	time1 = atodbl(aTime1);
	time2 = atodbl(aTime2);
	
	tMesEnd = timeNow()/100;
	
	TestStep("INFO","Start Time [ms]: %f", tMesStart);
	TestStep("INFO","End Time [ms]: %f", tMesEnd);
	TestStep("INFO","Elapsed Time [ms]: %.0f", (tMesEnd - tMesStart));
	
	if( (tMesEnd - tMesStart) >= time1 && (tMesEnd - tMesStart) <= time2)
	{
		testStepPass("INFO", "Elapsed time is in the expected range!");
	}
	else
	{
		testStepFail("INFO", "Elapsed time is out of the expected range!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that saves timestamp for start time
//! 
//! \teststep Save measurement timestamp for time interval calculation
//! \testresponse Timestamp is saved for later use
//- -----------------------------------------------------------------------------------------------
testcase TimeNowStart()
{    
    tMesStart = timeNow()/100;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Test execution will wait till the desired time
//!
//! \param  long Time The desired wait time in the teststep in ms
//! 
//! \teststep Wait for $1ms
//! \testresponse -
//- -----------------------------------------------------------------------------------------------
testcase Wait(long Time)
{
	TestWaitForTimeout(Time);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Waits until the timeout value, to a signal reaches the expected value (generalized)
//!
//! \param  char module[] the selected module of the DINX signal
//! \param  char name[] the name of the searched DINX signal
//! \param  char value[] the expected value
//! \param  int timeout the time to wait, in milisec
//! 
//! \example #) WaitDINX(string module _MODULE_, string name _NAME_, string value _VALUE_, int timeout _TIMEOUT_)
//!
//! \teststep Monitor $2 DINX signal for $4 ms
//! \testresponse Signal reached the value of $3
//- -----------------------------------------------------------------------------------------------
testcase WaitDINX(char module[], char name[], char value[], long timeout) // TODO add type, equal, nnot equal, range
{
  // WaitDINXFunction(module, name, value, timeout);  // REPLACED with new version below 12:58 2016.09.22.
  WaitDINXFunction("Equal", module, name, value, 0, timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Waits until the timeout value, to a signal reaches the expected value (function)
//!
//! \return No return value
//!
//! \note See description of testcase extendedWaitDINX() / PVWWaitDINX() / WaitDINX().
//- -----------------------------------------------------------------------------------------------
WaitDINXFunction(char type[], char module[], char name[], char value[], long minTime, long maxTime){
  // 13:07 2016.09.22. --------------------------- new version, with more complex timeout mehanism, and range option -------------------------------
  int sync_state;
  int read_state;
  int i;
  long timeout;
  long timein;
  int equal; // can take 1 (equal), 0(NOTequal), -1(type is a number)
  
  // ---- time measurement ---- ADDED 12:50 2016.09.23.
  float tStart;
  // ---- time measurement ---- ADDED 12:50 2016.09.23.
  
  double currentValue;
  double expectedValue;
  double lowLimit;
  double highLimit;
  
  sync_state = 0;
  read_state = 0;
  i = 0;
  currentValue=0;
  expectedValue=0;
  clearArray(currValue);
  timeout = maxTime/100; // TODO 13:58 2016.09.22. check if this is accurate time measure // FIXED ADDED 13:26 2016.09.23. new measure option
  timein = minTime/100;  // TODO 13:58 2016.09.22. check if this is accurate time measure // FIXED ADDED 13:26 2016.09.23. new measure option
  
  lowLimit = atodbl(type);
  highLimit = atodbl(value);
  
  // ------------------------- Pre checks, what type is it ---------------------
  if (strncmp(type,"Equal",elcount(type))== 0){
    equal = 1; // if equal
  }
  else if (strncmp(type,"NotEqual",elcount(type))== 0){
    equal = 0; // if not equal
  }
  else if(strstr_regex(type,"^(((0x)[0-9A-Fa-f]+)|(-?[0-9]+)|(-?[0-9]+\\.[0-9]+))$") != -1){
    equal = -1; // type is a number
  }
  else {
    TestStepFail("ERROR","Wrong _type_ parameter! It should be Equal, NotEqual or a number as low limit! ERROR");	
  }
  
  // Pre checks, max value valid
  if(strstr_regex(value,"^(((0x)[0-9A-Fa-f]+)|(-?[0-9]+)|(-?[0-9]+\\.[0-9]+))$") == -1){
    TestStepFail("ERROR","Wrong _value_ parameter! It must be a number! ERROR");	
  }

  setTimer(OverTime,maxTime);
  // ---------------------------- Main site -------------------------------------
  while( i++ < timeout && timeOverrun == 0)	// wait timeout/100 sec (checks ~10 times in a sec)
  {
    tStart = timeNowFloat(); // ---- time measurement ---- ADDED 12:50 2016.09.23. FOR TESTING
    setTimer(WaitDINXFunctionTimer, 100);  // ADDED 13:17 2016.09.23. starts a timer
    
    // fills up buffer, with the actual value
	sync_state = SyncIsSuccessful(module);
    read_state = ReadCurrentValueIsSuccessful(module,name,sync_state);
    if ( read_state == 1 )
    {
      //TestStep("DEBUG","Sync and read was successful.");
      currentValue=atodbl(currValue);
      
      if ( currentValue == highLimit && equal == 1) // if its in "Equal" mode break if reaches highLimit
      {
        // TestStep("DEBUG Equal mode","value: %d, equal: %d", currentValue, equal);
        if (i == timeout ) i--;  // ensures, that in the last step it does not confuses with end of time
        break;	// the current value reached the expected value
      }
      
      if ( currentValue == highLimit && equal == 0) // if its in "NotEqual" mode break if reaches highLimit
      {
        // TestStep("DEBUG NotEqual mode","value: %d, equal: %d", currentValue, equal);
        if (i == timeout ) i--;
        break;	// the current value reached the avoidable value
      }
      
      if ( currentValue <= highLimit && currentValue >= lowLimit && equal == -1) // if its in "RANGE" mode break if within lowLimit and highLimit
      {
        // TestStep("DEBUG Range mode","value: %d, equal: %d", currentValue, equal);
        if (i == timeout ) i--;
        break;	// the current value reached the inside of the range
      }
    }
    else if ( read_state == -1 )
    {
      //TestStep("DEBUG","notOpen");
      TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
    }
    else if ( read_state == 0 )
    {
      //TestStep("DEBUG","notSync");
      TestStepFail("INFO","Sync wasn't successful! ERROR");	
    }
    
    // TestStep("DEBUG mode","The \"WaitDINXFunction WHILE\" take %d ms.", (timeNowFloat()-tStart) / 100.0 ) ; // ---- time measurement ---- ADDED 12:50 2016.09.23. FOR TESTING
    TestWaitForTextEvent("WaitDINXFunction-TIMER", 100); // wait MAXIMUM 100ms, or the arrival of the started timer ADDED 13:19 2016.09.23.
    // TestWaitForTextEvent("Timer", 50);	// wait ~0.05 sec	// TODO new timer!? 15:03 2016.09.22.
  }
  cancelTimer(OverTime);
  
  
  // ------------------------ check result ----------------------
  if(read_state == 1)
  {
	  if (equal == 1) // Equal mode
	  {
		if (i < timeout && i >= timein && timeOverrun == 0)
		{
		  // TestStep("DEBUG Equal mode","Equal, IN TIME, type: %s, expected: %d, current: %d", type, highLimit, currentValue); // FOR TESTING
		  TestStepPass(name,"The value (%f) of the variable is now equal with the expected value (%f).  OK", currentValue, highLimit );
		}
		else if ( i < timein && timeOverrun == 0)
		{
		  // TestStep("DEBUG Equal mode","Equal, OUT (low) TIME, type: %s, expected: %d, current: %d", type, highLimit, currentValue); // FOR TESTING
		  TestStepFail(name,"The value (%f) of the variable reached faster the expected value (%f).  FAIL", currentValue,  highLimit );
		}
		else
		{
		  // TestStep("DEBUG Equal mode","Equal, OUT (high) TIME, type: %s, expected: %d, current: %d", type, highLimit, currentValue); // FOR TESTING
		  TestStepFail(name,"The value (%f) of the variable does not reach the expected value (%f) within the given timeout! FAIL", currentValue, highLimit);
		}      
	  }
	  else if (equal == 0) // NOTequal mode
	  {
		if (i < timeout && i >= timein && timeOverrun == 0)
		{
		  // TestStep("DEBUG NotEqual mode","NotEqual, IN TIME, type: %s, expected: %d, current: %d", type, highLimit, currentValue); // FOR TESTING
		  TestStepFail(name,"The value (%f) of the variable is now equal with the avoidable value (%f).  FAIL", currentValue,  highLimit );
		}
		else if ( i < timein && timeOverrun == 0)
		{
		  // TestStep("DEBUG NotEqual mode","NotEqual, OUT (low) TIME, type: %s, expected: %d, current: %d", type, highLimit, currentValue); // FOR TESTING
		  TestStepFail(name,"The value (%f) of the variable reached faster the avoidable value (%f).  FAIL", currentValue,  highLimit );
		}
		else
		{
		  // TestStep("DEBUG NotEqual mode","NotEqual, OUT (high) TIME, type: %s, expected: %d, current: %d", type, highLimit, currentValue); // FOR TESTING
		  TestStepPass(name,"The value (%f) of the variable does not reach the avoidable value (%f) within the given timeout! OK", currentValue,  highLimit);
		}   
	  }
	  else
	  {
		if (i < timeout && i >= timein && timeOverrun == 0)
		{
		  // TestStep("DEBUG RANGE mode","RANGE, IN TIME, type: %s, min: %d, max: %d, current: %d", type, lowLimit, highLimit, currentValue); // FOR TESTING
		  TestStepPass(name,"The value (%f) of the variable is now in range of the given time limits (%f - %f).  OK", currentValue, lowLimit, highLimit );
		}
		else if ( i < timein && timeOverrun == 0)
		{
		  // TestStep("DEBUG RANGE mode","RANGE, OUT (low) TIME, type: %s, min: %d, max: %d, current: %d", type, lowLimit, highLimit, currentValue); // FOR TESTING
		  TestStepFail(name,"The value (%f) of the variable reached faster the requested range (%f - %f).  FAIL", currentValue, lowLimit, highLimit );
		}
		else
		{
		  // TestStep("DEBUG RANGE mode","RANGE, OUT (high) TIME, type: %s, min: %d, max: %d, current: %d", type, lowLimit, highLimit, currentValue); // FOR TESTING
		  TestStepFail(name,"The value (%f) of the variable does not reach the requested range (%f - %f) within the given timeout! FAIL", currentValue, lowLimit, highLimit);
		}  
	  }
	}
	if(timeOverrun != 0) timeOverrun = 0;
  // 13:07 2016.09.22. --------------------------- new version, with more complex timeout mehanism, and range option -------------------------------
  
  /* void WaitDINXFunction(char module[], char name[], char value[], int timeout){  // REPLACED with new version 13:05 2016.09.22.
  int state;
  int i;
  double currentValue;
  double expectedValue;

  state = 0;
  i = 0;
  currentValue=0;
  expectedValue=0;
  timeout = timeout/50;

  while( i++ < timeout )	// wait timeout/100 sec (checks ~ten times in a sec)
  {
    // fills up buffer, with the actual value
    state = ReadCurrentValueIsSuccessful(module,name);
    if ( state == 1 )
    {
      //TestStep("INFO","Sync and read was successful.");
      currentValue=atodbl(currValue);
      expectedValue=atodbl(value);
      //write("While");
      if ( currentValue == expectedValue )
      {
        break;	// the current value reached the expected value
      }
    }
    else if ( state == -1 )
    {
      //write("notOpen");
      TestStepFail("INFO","Can not open adtf_out.csv! ERROR");	
    }
    else if ( state == 0 )
    {
      //write("notSync");
      TestStepFail("INFO","Sync wasn't successful! ERROR");	
    }
    TestWaitForTextEvent("Timer", 50);	// wait ~0.05 sec	
  }
  
  if (i < timeout)
  {
    //write("NotEqual");
    TestStepPass("INFO","The value of the variable is now equal with the expected value, %f.  OK", currentValue );
  }
  //write("AllGood");
  else TestStepFail("INFO","The value (%f) of the variable does not reach the expected value within the given timeout sec! ERROR", currentValue); */
}

//- ----------------------------------------------------------------------------------------------------
//! \brief  Testcase to wait for an ADTF or HIL sequence start
//! 
//! \teststep Wait for the starting phase of ADTF measurement
//! \testresponse ADTF measurement has started
//- ----------------------------------------------------------------------------------------------------
testcase WaitForADTFStart()
{
	char adtf_started[2];
  dword fileHandle;
	
	WaitForADTFStartFunction(adtf_started);
	if(strncmp(adtf_started,"1",elcount(adtf_started)) == 0)
	{
		setFilePath("c:\\unilogger",2);
		fileHandle=openFileWrite("adtf_phase.txt",0);
		filePutString("0",elcount("0"),fileHandle);
		fileClose(fileHandle);
		testStepPass("INFO","The ADTF successfully started.");    
	}
	else
	{
		testStepFail("INFO","The running of the ADTF sequence or recording couldn't start.");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to wait till a specific DTC has been qualified
//!
//! \param  char Request is the diagnostic request should be sent
//! \param  char Response is the expected response should be awaited
//! \param  char CompareMode is the compare mode should be used
//! 
//! \teststep Waiting for a specified DTC
//! \testresponse The response should be equal with 0x$2
//- -----------------------------------------------------------------------------------------------
testcase WaitForDTC(char Request[], char Response[], char CompareMode[])
{
	int result;
	int i;
	
	result = 0;
	i =0;
		
	while(result ==0 && i<120)
	{
		//Wait 2 s
		testWaitForTimeout(2000);
		//Read the Error memory whether the DTC of the failure is stored in or not
		result = RequestResponseCompareLogic(Request, Response, CompareMode);
    
		//Increment i variable by 1
		i++;
	}
	//Verification of test result
	if (i!=120)
	{
		//The testcase is passed, the expected response has received
		testStepPass("INFO", "The DTC is activated!");
	}	
    else
    {
	  //4 mins elapsed and qualification did not occure
	  testStepFail("INFO", "TestStep timeout!");
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Waits until the HIL sequence has been started
//! 
//! \teststep Wait until the HIL sequence has started
//! \testresponse HIL sequence has started
//- -----------------------------------------------------------------------------------------------
testcase WaitForHILSequenceStart()
{
    WaitForHILSequenceStart_function();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Waits until the HIL sequence has been started
//!
//! \return No return value
//! 
//! \note See description of testcase WaitForHILSequenceStart().
//- -----------------------------------------------------------------------------------------------
WaitForHILSequenceStart_function()
{
   long timeOutValue;
    
   timeOutValue = 1000000000;

   TestWaitForTextEvent("HIL sequence starts", timeOutValue);
        
   TestStep("INFO", "**********************************************************");
   TestStep("INFO", "**********************************************************");   
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to wait for the occurrence of the next specific message
//!
//! \param  char MessageName is the name of the message that should be awaited
//! \param  long Timeout is the maximum time that should be waited [ms]
//! 
//! \teststep Wait $2ms for $1 message   
//! \testresponse -
//!
//! \note	The testcase searches the CAN channel the message is sent on.
//- -----------------------------------------------------------------------------------------------
testcase WaitForMessage (char MessageName[], long Timeout)
{
  WaitForMessageFunction(MessageName, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to wait for the occurrence of the next specific message
//!
//! \return No return value
//!
//! \note	See description of testcase WaitForMessage().
//- -----------------------------------------------------------------------------------------------
WaitForMessageFunction(char MessageName[], long Timeout)
{
	dword MessageID;
	char MsgName[64];
	
	MessageID = GetMessageID(MessageName);
	if(getMessageName(MessageID, 0x10001, MsgName, elcount(MsgName)))
	{
		testStep("INFO","Message %s found on 0x10001 channel", MessageName);
		TestWaitForMessage(MessageID, Timeout);
	}
    else if(getMessageName(MessageID, 0x10002, MsgName, elcount(MsgName)))
	{
	  testStep("INFO","Message %s found on 0x10002 channel", MessageName);
	  canOffline(3); 
	  SetBusContext(0x10002);
	  canOnline(3);
	  TestWaitForMessage(MessageID, Timeout);
	  canOffline(3); 
	  SetBusContext(0x10001);
	  canOnline(3);
	}
	else
	{
		testStepFail("INFO","The given message name: %s was not found on 0x10001 and 0x10002 channel.", MessageName);
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to wait for the occurrence of the next specific message on the given CAN channel
//!
//! \param  char MessageName is the name of the message that should be awaited
//! \param  char CanChannel is the name of the CAN channel the message is awaited on
//! \param  long Timeout is the maximum time that should be waited [ms]
//! 
//! \teststep Wait $3ms for $1 message on $2   
//! \testresponse -
//!
//! \note	Available CAN Channels are: \n
//!     		E_Can\n
//!     		SF_Can\n
//- -----------------------------------------------------------------------------------------------
testcase WaitForMessageOnBus (char MessageName[], char CanChannel[], long Timeout)
{
	WaitForMessageOnBusFunction(MessageName,CanChannel, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to wait for the occurrence of the next specific message on the given CAN channel.
//!
//! \return Returns the result of the TestWaitForMessage function:
//!     		1: Resume due to event occured \n
//!     		0: Resume due to timeout \n
//!     		-1: General error \n
//!     		-2: Resume due to constraint violation
//!
//! \note	See description of testcase WaitForMessageOnBus().
//- -----------------------------------------------------------------------------------------------
long WaitForMessageOnBusFunction (char MessageName[], char CanChannel[], long Timeout)
{
	dword MessageID;
  long result;
  
  result = 0;
	
	ChangeCanChannelFn(CanChannel);
	
	MessageID = GetMessageID(MessageName);

	  write("ID= %x", MessageID);
    
    result = TestWaitForMessage(MessageID, Timeout);
	
	RestoreCanChannelFn();
	return result;
}

//- ----------------------------------------------------------------------------------------------------
//! \brief  Testcase to wait for an ADTF or HIL sequence stop
//! 
//! \teststep Wait for the end of the sequence
//! \testresponse Sequence has ended
//- ----------------------------------------------------------------------------------------------------
testcase WaitForSequenceStop()
{
    int i;
    char adtf_stopped[2];
    dword fileHandle;
  
    strncpy(adtf_stopped,"0",elcount(adtf_stopped));
    i=0;
    while(strncmp(adtf_stopped,"2",elcount(adtf_stopped) != 0) && i<4500)
    {
        setFilePath("c:\\unilogger",2);
        fileHandle=openFileRead("adtf_phase.txt",0);
        fileGetString(adtf_stopped,elcount(adtf_stopped),fileHandle);
        fileClose(fileHandle);
        TestWaitForTimeout(200);
        i++;
    }
    if(strncmp(adtf_stopped,"2",elcount(adtf_stopped)) == 0)
    {
        setFilePath("c:\\unilogger",2);
        fileHandle=openFileWrite("adtf_phase.txt",0);
        filePutString("0",elcount("0"),fileHandle);
        fileClose(fileHandle);
        testStepPass("INFO","The ADTF successfully stopped.");
    }
    else
    {
        testStepFail("INFO","The running of the ADTF hasn't stopped until the timeout.");
    }
    testWaitForTimeout(20000);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which checks the given value against the value of the signal and waits for the given value
//!
//! \param  signal signalName is the name of the signal which is tested
//! \param  float signalValue is the value of the tested signal what we wait for
//! \param  long Timeout is the timeout for the test
//! 
//! \teststep Check $1 signal for $3ms
//! \testresponse Signal value is $2
//!
//! \note 	If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.\n
//! 		! The function considers the resolution of the signal !
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValue(signal * signalName,  float signalValue, long Timeout)
{
  WaitForSignalValueFunction(signalName, signalValue, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that checks the given value against the value of the signal and waits for the given value
//!  
//! \return No return value
//!
//! \note 	See description of testcase WaitForSignalValue().
//- -----------------------------------------------------------------------------------------------
WaitForSignalValueFunction(signal * signalName,  float signalValue, long Timeout)
{
  long result;
  float signalActualValue;

  result = 0;
  signalActualValue = 0;
  
  
  result = TestWaitForSignalMatch (signalName, signalValue, Timeout);
  signalActualValue = getSignal(signalName);
  
  if (result == 1 )
	{
    // Signal with expected value arrived!      
		TestStepPass("INFO","The signal has the following value: %f,", signalActualValue);
		TestStep("INFO","The tester desired the following value: %f,", signalValue);
		TestStep("INFO","If there is a difference between the desired and the actual value, it must be resolution problem. Check the DBC.");
		TestStep("INFO","If you want to check if the signal has the exact value, use WaitForSignalValuePrecise.");
	}
	else if (result == 0)
	{ 
    // Timeout occured! 

		TestStep("INFO","The signal has the following value: %f,", signalActualValue);        
		TestStepFail("INFO","The signal has not arrived with the expected value within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Signal is not valid");
	}
	else
	{
		TestStepFail("INFO","General error");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which checks the given value range against the value of the signal and waits for the signal to get in the given value range
//!
//! \param  signal signalName is the name of the signal which is tested
//! \param  float aLowLimit is the lower bound of the given value range for what we wait for
//! \param  float aHighLimit is the upper bound of the given value range for what we wait for
//! \param  long Timeout is the timeout for the test
//! 
//! \teststep Check whether $1 signal value occures  within the $2 - $3 range with $5 timeout
//! \testresponse $1 signal value is between the range of $2 - $3
//!
//! \note If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValueInRange (signal * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
  WaitForSignalValueInRangeFunction(signalName, aLowLimit, aHighLimit, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that checks the given value range against the value of the signal and waits for the signal to get in the given value range
//!  
//! \return No return value
//!
//! \note 	See description of testcase WaitForSignalValueInRange() / WaitForSignalValueInsideRange().
//- -----------------------------------------------------------------------------------------------
WaitForSignalValueInRangeFunction(signal * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
	long result;
  float signalActualValue;

  result = 0;
  signalActualValue = 0;
  
  
  result = TestWaitForSignalInRange (signalName, aLowLimit, aHighLimit, Timeout);
  signalActualValue = getSignal(signalName);
  
  if (result == 1)
  {
		TestStep("INFO","The signal has the following value: %f,", signalActualValue);
		TestStepPass("INFO","The signal arrived within the expected value range: %f %f", aLowLimit, aHighLimit);
	}
	else if (result == 0)
	{ 
		TestStep("INFO","The signal has the following value: %f,", signalActualValue);        
		TestStepFail("INFO","The signal has not arrived with the expected value range within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Signal is not valid");
	}
	else
	{
		TestStepFail("INFO","General error");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which checks the given value range against the value of the system variable and waits for the system variable to get in the given value range
//!
//! \param  sysvarFloat signalName is the name of the system variable which is tested
//! \param  float aLowLimit is the lower bound of the given value range for what we wait for
//! \param  float aHighLimit is the upper bound of the given value range for what we wait for
//! \param  long Timeout is the timeout for the test
//! 
//! \teststep Check whether $1 signal value occures  within the $2 - $3 range with $5 timeout
//! \testresponse $1 signal value is between the range of $2 - $3
//!
//! \note If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValueInRange (sysvarFloat * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
  WaitForSignalValueInRangeFunction(signalName, aLowLimit, aHighLimit, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that checks the given value range against the value of the system variable and waits for the system variable to get in the given value range
//!  
//! \return No return value
//!
//! \note 	See description of testcase WaitForSignalValueInRange().
//- -----------------------------------------------------------------------------------------------
WaitForSignalValueInRangeFunction(sysvarFloat * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
	long result;
  float signalActualValue;

  result = 0;
  signalActualValue = 0;
  
  
  result = TestWaitForSignalInRange (signalName, aLowLimit, aHighLimit, Timeout);
  signalActualValue = sysGetVariableFloat(signalName);
  
  if (result == 1)
  {
		TestStep("INFO","The signal has the following value: %f,", signalActualValue); 
		TestStepPass("INFO","The signal arrived within the expected value range: %f %f", aLowLimit, aHighLimit);
	}
	else if (result == 0)
	{ 
    
		TestStep("INFO","The signal has the following value: %f,", signalActualValue);        
		TestStepFail("INFO","The signal has not arrived with the expected value range within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Signal is not valid");
	}
	else
	{
		TestStepFail("INFO","General error");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which checks the given value range against the value of the system variable and waits for the system variable to get in the given value range
//! 
//! \param  signal signalName is the name of the signal which is tested
//! \param  float aLowLimit is the lower bound of the given value range for what we wait for
//! \param  float aHighLimit is the upper bound of the given value range for what we wait for
//! \param  long Timeout is the timeout for the test
//! 
//! \teststep Check whether $1 signal value occures  within the $2 - $3 range with $5 timeout on the network.
//! \testresponse $1 signal value is between the range of $2 - $3
//!
//! \note If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValueInsideRange (signal * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
  WaitForSignalValueInRangeFunction(signalName, aLowLimit, aHighLimit, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which checks the given value range against the value of the system variable and waits for the system variable to get in the given value range
//! 
//! \param  signal signalName is the name of the signal which is tested
//! \param  float aLowLimit is the lower bound of the given value range the signal value has to be outside
//! \param  float aHighLimit is the upper bound of the given value range the signal value has to be outside
//! \param  long Timeout is the timeout for the test
//!
//! \teststep Check whether $1 signal value occures  outside  the $2 - $3 range with $5 timeout on the network
//! \testresponse $1 signal value is otuside the range of $2 - $3
//!
//! \note 	If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValueOutsideRange (signal * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
  WaitForSignalValueOutsideRangeFunction(signalName, aLowLimit, aHighLimit, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that checks the given value range against the value of the signal and waits for the signal to get outside the given value range.
//!  
//! \return No return value
//!
//! \note 	See description of testcase WaitForSignalValueOutsideRange().
//- -----------------------------------------------------------------------------------------------
WaitForSignalValueOutsideRangeFunction(signal * signalName, float aLowLimit, float aHighLimit, long Timeout)
{
	long result;
	float signalActualValue;

	result = 0;
	signalActualValue = 0;

	result = TestWaitForSignalOutsideRange (signalName, aLowLimit, aHighLimit, Timeout);
	signalActualValue = getSignal(signalName);

	if (result == 1)
	{
		TestStep("INFO","The signal has the following value: %f,", signalActualValue);     
		TestStepPass("INFO","The signal received outside the specified value range: %f %f", aLowLimit, aHighLimit);
	}
	else if (result == 0)
	{ 
		
		TestStep("INFO","The signal has the following value: %f,", signalActualValue);        
		TestStepFail("INFO","The signal was not received with the expected value range within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Signal is not valid");
	}
	else
	{
		TestStepFail("INFO","General error");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that checks the given value against the value of the signal and waits for the signal to get the given value with the added precision
//!
//! \param  ssignal signalName is the name of the signal which is tested
//! \param  float signalValue is the value what we wait for
//! \param  float precision is the small range, within we wait for the value
//! \param  long Timeout is the timeout for the test
//! 
//! \teststep Check whether $1 signal value have the value $2 using $3 precision with $4 timeout on the network
//! \testresponse $1 signal value is $2 with the precision of $3 on the network
//!
//! \note If this condition is already met when this function is called, it returns immediately 
//!  without waiting. The test step is evaluated as either passed or failed depending on the results.\n
//!  ! The function DOES NOT considers the resolution of the signal !
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValuePrecise (signal * signalName, float signalValue, float precision, long Timeout)
{
	if (precision == 0.0)
	{
		TestStepFail("ERROR","The precision value can not be set to 0.0! Use WaitForSignalValue in that case!");  
	}
	else
	{
		WaitForSignalValueInRangeFunction(signalName, signalValue - abs(precision), signalValue + abs(precision), Timeout);
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Prints the nesessary file to run VISOR in file-server-mode
//!
//! \param  char source[] contains the module needed for sync
//! \param  char destination[] contains the module needed for sync
//! \param  char HILrecordingEXT[] contains the module needed for sync
//! 
//! \teststep Create a playlist foHIL with sequence $4
//! \testresponse Playlist is created
//- -----------------------------------------------------------------------------------------------
testcase WriteXMLPlaylistForHIL(char source[], char destination[], char HILrecordingEXT[], char FileName[])
{
	WriteXMLPlaylistForHIL_function(source, destination, HILrecordingEXT, FileName);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Prints the nesessary file to run VISOR in file-server-mode
//!
//! \return No return value
//!
//! \note See description of testcase WriteXMLPlaylistForHIL().
//- -----------------------------------------------------------------------------------------------
WriteXMLPlaylistForHIL_function(char source[], char destination[], char HILrecordingEXT[], char FileName[]){
  dword fileHandle;
  char part_01_until_destination[274] = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!--THIS FILE IS GENERATED FROM WriteXMLPlaylistForHIL_function!--><datfilelist version=\"3\"><localSettings><tempsource>C:\\temp\\HIL_TempSrc</tempsource><tempdestination>C:\\temp\\HIL_TempDest</tempdestination><destinationfolder>" ;
  char part_02_until_hilrecordinext[38] = "</destinationfolder><hilrecordingext>";
  char part_03_until_source[122] = "</hilrecordingext><overrideconfigurationpath/></localSettings><datfilefolder><dataset/><flashfile/><coding_file/><source>";
  char part_04_until_EOF[106] = "</source><destinationfolder/><overrideconfigurationpath/><hilrecordingext/></datfilefolder></datfilelist>";
  
  fileHandle = 0;
  
  setWritePath( "c:\\temp\\" );
  // file open
  fileHandle = OpenFileWrite( FileName, 0 );
  if ( fileHandle == 0 ) //break if the file is not accessible
  {
    write( "Cannot create file: " );
    write( FileName );
    TestStepFail("ERROR","Cannot create file! ERROR");	
  }
  
  // file writing
  filePutString( part_01_until_destination, elcount(part_01_until_destination), fileHandle ); //write first part
  filePutString( destination, elcount(destination), fileHandle ); //write first variable (DESTINATION)
  filePutString( part_02_until_hilrecordinext, elcount(part_02_until_hilrecordinext), fileHandle ); //write second part
  filePutString( HILrecordingEXT, elcount(HILrecordingEXT), fileHandle ); //write second variable (HILRECORDINGEXT)
  filePutString( part_03_until_source, elcount(part_03_until_source), fileHandle ); //write third part
  filePutString( source, elcount(source), fileHandle ); //write third variable (SOURCE)
  filePutString( part_04_until_EOF, elcount(part_04_until_EOF), fileHandle ); //write last part

  // close file
  fileClose ( fileHandle );
  TestStep("INFO","Temp playlist File created: %s", FileName);
}

// ----------------------------------------------------[OSEK FUNCTIONS]----------------------------------------------------

//- -----------------------------------------------------------------------------------------------
//! \brief  Function which returns the number of data successfully sent
//!
//! \param  long c stores the data length
//- -----------------------------------------------------------------------------------------------
OSEKTL_DataCon (long c)
{
    TestStep("INFO","Data Transmission done!");
    //write ("Successfully sent data length: %d", c);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function which returns the number of data received
//!
//! \param  long count stores the data length
//- -----------------------------------------------------------------------------------------------
OSEKTL_DataInd (long count)
{
    int RIP;
    int i = 0;
    //char tmpString[255];
    RIP = SID + 0x40;
    OSEKTL_GetRxData(RsRxIntData, elcount(RsRxIntData));
	ResponseLength = count;
    if(count <= elcount(RsRxIntData))
    {
		switch(routineHandle)
		{
			case 10:
				CreateByteString(RsRxIntData, 0, count);
				snprintf(g_TextEvent, elcount(g_TextEvent), "Datablock%d",RsRxIntData[1]);
				TestSupplyTextEvent(g_TextEvent);
            break;
			default:
				CreateByteString(RsRxIntData, 0, count);
				TestSupplyTextEvent("TpMsgReceived");
			break;
		}
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Shows error message from transport layer
//!
//! \param  long count stores the data length
//!
//! \note:	Errors:  \n
//!   		 1: Timeout waiting for CF\n
//!  		 2: Timeout waiting for FC\n
//!  		 3: Received Wrong SN\n
//!  		 4: TxBusy, only one transmission possible at the same time\n
//!   		 5: Received unexpected PDU\n
//!  		 6: Timeout while trying to send a CAN message\n
//!  		 7: Too many FC.WFT sent\n
//!  		 8: Receiver buffer overflow\n
//!  		 9: Wrong parameter\n
//!  		 10: Invalid flow status received\n
//!  		 11: Transfer has been aborted explicitly\n
//!  		 <0: Unknown Error.
//- -----------------------------------------------------------------------------------------------
OSEKTL_ErrorInd(int error)
{
    write("TP Error %d", error);
  if (error == 1)
    write("Error message from transport layer: Timeout waiting for CF.");
  else if (error == 2)
    write("Error message from transport layer: Timeout waiting for FC.");
  else if (error == 3)
    write("Error message from transport layer: Received Wrong SN.");
  else if (error == 4)
    write("Error message from transport layer: TxBusy, only one transmission possible at the same time.");
  else if (error == 5)
    write("Error message from transport layer: Received unexpected PDU.");
  else if (error == 6)
    write("Error message from transport layer: Timeout while trying to send a CAN message.");
  else if (error == 7)
    write("Error message from transport layer: Too many FC.WFT sent.");
  else if (error == 8)
    write("Error message from transport layer: Receiver buffer overflow.");
  else if (error == 9) 
    write("Error message from transport layer: Wrong parameter.");
  else if (error == 10)
    write("Error message from transport layer: Invalid flow status received.");
  else if (error == 11)
    write("Error message from transport layer: Transfer has been aborted explicitly.");
  else 
    write("Error message from transport layer: Unknown Error.");
}