/*@!Encoding:1252*/

variables
{    
    /*Debug*/
    int     g_debug = 0;
    
    /*Globals*/
    int     ByteSize;
    int     SID;
    int     StoredSignalValue;
    char    byteString[2048];
    char    seedString[2048];
    byte    seedData[2048];
	msTimer t20ms;
    msTimer t10ms;

    //mstimer waitTimeForResponse;

    
    /* ReadDataByID data */
    byte    RqTxData[2048];
    char    RqTxStringData[4096];
    byte    RsRxIntData[2048];
    char    RsRxStringData[2048];
    
    /* XCP messages */
   // message XCP_Kamera_CRO_01 Msg_XCP_Kamera_CRO_01;
  //  message XCP_Kamera_DTO_01 Msg_XCP_Kamera_DTO_01;
    message 0x782 DSDL;

    //msTimer 20_ms;
    msTimer     Act20ms;
    //message XCP_MPC_CRO       Msg_XCP_MPC_CRO;
    //message XCP_MPC_DTO       Msg_XCP_MPC_DTO;
    
    /* Handle to switch within the TP Rx routines */
    long routineHandle = 0;
    char g_TextEvent[12];
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Signals "Minimum time delay is reached!" when the t10ms timer expires.
//- -----------------------------------------------------------------------------------------------
on timer t10ms
{
    TestSupplyTextEvent("Minimum time delay is reached!");
    //setTimer(t10ms,10); //set timer (t20ms) to 20ms   
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Signals "Minimum time delay is reached!" when the t20ms timer expires.
//- -----------------------------------------------------------------------------------------------
on timer t20ms
{
    TestSupplyTextEvent("Minimum time delay is reached!");
    //setTimer(t10ms,10); //set timer (t20ms) to 20ms    
}


on preStart
{
    dword BusContext;
    int stMinTime;
    int blockSize;
    int rxId;
    int txId;

    //putValue(EnvFilePath,"");

    /* Set Bus context for correct CAN channel usage */
    if (1 == g_debug)
    {
        BusContext = GetBusContext();
        write("BusContext pre set = %x",BusContext); //Debugmsg   
    }
    SetBusContext(0x10001); //Set CAN channel
    CanOnline(3); //reset CAN
    BusContext = GetBusContext(); //Read CAN bus channel context
    write("BusContext set = %x",BusContext);

    stMinTime = 0x14;
    blockSize = 0x08;
    rxId = 0x76B;
    txId = 0x763;

    //SysSetVariableString(sysvar::Diag::SessionID, "0xFF");
    //SysSetVariableString(sysvar::Diag::Data, "0xFF");
    //SysSetVariableString(sysvar::Diag::ServiceID, "0xFF");
    //SysSetVariableString(sysvar::Diag::LocalID, "0xFFFF");

    /* Init */
    OSEKTL_SetTxId(txId);
    OSEKTL_SetRxId(rxId);
    OSEKTL_SetSTMIN(stMinTime);
    OSEKTL_SetBS(blockSize);
    OSEKTL_SetNrmlMode();
    /****************/
}

testcase EstablishXCPConnection(int CANChannel)
{
    long result;
    long timeOutValue;
    
    result = 0;
    timeOutValue = 2000;

    switch(CANChannel)
    {
     /*  case 1:
        Msg_XCP_Kamera_CRO_01.Byte(0)=0xFF;
        Msg_XCP_Kamera_CRO_01.Byte(1)=0x00;
        Msg_XCP_Kamera_CRO_01.Byte(2)=0x00;
        Msg_XCP_Kamera_CRO_01.Byte(3)=0x00;
        Msg_XCP_Kamera_CRO_01.Byte(4)=0x00;
        Msg_XCP_Kamera_CRO_01.Byte(5)=0x00;
        Msg_XCP_Kamera_CRO_01.Byte(6)=0x00;
        Msg_XCP_Kamera_CRO_01.Byte(7)=0x00;

        TestWaitForTimeout(500);
        output(Msg_XCP_Kamera_CRO_01);
        
        result = TestWaitForTextEvent("XCPConnection CAN1", timeOutValue);
      break; */
      
      case 2:
        /*Msg_XCP_MPC_CRO.Byte(0)=0xFF;
        Msg_XCP_MPC_CRO.Byte(1)=0x00;
        Msg_XCP_MPC_CRO.Byte(2)=0x00;
        Msg_XCP_MPC_CRO.Byte(3)=0x00;
        Msg_XCP_MPC_CRO.Byte(4)=0x00;
        Msg_XCP_MPC_CRO.Byte(5)=0x00;
        Msg_XCP_MPC_CRO.Byte(6)=0x00;
        Msg_XCP_MPC_CRO.Byte(7)=0x00;

        TestWaitForTimeout(500);
        output(Msg_XCP_MPC_CRO);
        
        result = TestWaitForTextEvent("XCPConnection CAN2", timeOutValue);*/
      break;
    }

    switch(result)
    {
        case 0:
            TestStepFail("1.0","Timeout while waiting for XCP connection");
        break;

        case 1:
            TestStepPass("1.0","XCP connection established!");
        break;

    }
}

CharArray2Byte(char convertable_array[])
{

    int i;
    char c1,c2;
    int strIndex;
    
    strIndex = 0;
    
    for (i = 0; i < elcount(RqTxStringData); i++)
      {
          RqTxStringData[i] = 0;
      } 
   
    for (i = 0; i < elcount(convertable_array); i++)
     {
      RqTxStringData[i] = convertable_array[i];     //RqTxStringData is a global variable
     }

    ByteSize = 0;  //ByteSize is a global variable
    for (i = 0; i < (strlen(RqTxStringData)/2); i++)
    {
        strIndex = i * 2;
         
        c1 = RqTxStringData[strIndex];
        c2 = RqTxStringData[strIndex + 1];
//        write ("Here is c1: %c and c2: %c", c1, c2);
        RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);     // RqTxData is a global variable
        ByteSize++;
    }
    SID = RqTxData[0];
}

setType(int rxId, int txId)
{
// TODO:   Check if the rxId an txId is a valid hex format

//They will be from now the message IDs in CAN
  OSEKTL_SetTxId(txId);   
  OSEKTL_SetRxId(rxId);
}

RequestResponseCompareLogic(char Request[], char Response[], char CompareMode[])
{

    byte responsePending;
    long result;
    long timeOutValue;
    int numberRPs;
    
    responsePending = 0;
    numberRPs = 0;
    timeOutValue = 5000;

    if(0 == strncmp("Equal", CompareMode,strlen(CompareMode)))
      {
//        write ("###### CompareMode: %s ", CompareMode);
        TestStep("INFO","The CompareMode is: %s", CompareMode);
      }
    else if(0 == strncmp("Regexp", CompareMode,strlen(CompareMode)))
      {
//        write ("###### CompareMode: %s ", CompareMode);
        TestStep("INFO","The CompareMode is: %s", CompareMode);
      } 
    else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
      {
//        write ("###### CompareMode: %s ", CompareMode);
        TestStep("INFO","The CompareMode is: %s", CompareMode);
      }
    else 
      {
//        write("###### CompareMode is invalid: %s ", CompareMode");
        TestStepFail("INFO","The CompareMode is not valid!");
        TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None!");
      }

    CharArray2Byte(Request);              // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
    TestStep("INFO","REQUEST: %s", Request);
    //OSEKTL_ActivateAck(1);
    OSEKTL_DataReq(RqTxData, ByteSize);   //Sending out Request in a RxTxData global byte array
    
    setType (0x76B,0x763);
    //check whether the CompareMode is None
    //if yes, no response is expected
    if (0 != strncmp("None", CompareMode,strlen(CompareMode)))
    {  
      do
      { 
          responsePending = 0;
          result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
          if(result == 0)
          {  
              TestStepFail("INFO","Timeout while waiting for diag response");          
          }
          else if(result == 1)
          { 
              TestStep("INFO","Diag response received!");
              TestStep("INFO","EXPECTED: %s", Response);
              TestStep("INFO","RECEIVED: %s", byteString);
              
              //Negative branch starts
              if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID ) 
              { 
                  if( RsRxIntData[2] == 0x78 )
                  {
                      TestStep("INFO","Response Pending received from ECU");
                      responsePending = 1;
                      numberRPs++;
                      timeOutValue = 10000;
                  }
                  else
                  {
                      TestStep("INFO","Negative response received!");

                      if(0 == strncmp("Equal", CompareMode, strlen("Equal")))
                      {   
                          if(0 == strncmp(byteString, Response, strlen(Response)) && strlen(byteString) == strlen(Response))
                          {
                              TestStepPass("INFO","Expected NRC received!");
                          }
                          else
                          {   
                              TestStepFail("INFO","Unexpected NRC received!");
                          }
                      }
                      else
                      {
                          if(0 == strncmp("Regexp", CompareMode,strlen("Regexp")))
                          {   
//                              write("Debug ==> the value of the byteString: %s and the Response is: %s", byteString, Response);
                              if(1 == str_match_regex(byteString, Response))
                              {
                                  TestStepPass("INFO","Expected substring in NRC received!");
                              }
                              else
                              {
                                  TestStepFail("INFO","NRC contains not expected substring!");
                              }
                          }
                      }
                  }

              }
              // End of negative branch
              
              //Positive branch starts
              if( RsRxIntData[0] == (SID + 0x40) )  
              {
                  TestStep("INFO","Positive Response from ECU!");

                  if(0 == strncmp("Equal", CompareMode,strlen("Equal")))
                  {
                      if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
                      {
                          TestStepPass("INFO","Expected response received!");
                      }
                      else
                      {
                          TestStepFail("INFO","Unexpected response received!");
                      }
                  }
                  else
                  {   
                          if(0 == strncmp("Regexp", CompareMode,strlen("Regexp")))
                          {   
//                              write("Debug ==> the value of the byteString: %s and the Response is: %s", byteString, Response);
                              if(1 == str_match_regex(byteString, Response))
                          {
                              TestStepPass("INFO","Expected substring in response received!");
                          }
                          else
                          {
                              TestStepFail("INFO","Response contains not expected substring!");
                          }
                      }
                  }
              }

          }
         
      } while( (responsePending == 1) && (numberRPs < 24) );  //Pending response handling

      if( responsePending == 1 )
      {
          TestStepFail("INFO","Timeout while waiting for diag response!");
      }
    }
    else 
    {
        timeOutValue = 5000;
    //  write("CompareMode is None, no response is required!");
        result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
    //  write ("Here is the response result: %d", result);
        TestStep("INFO","CompareMode is None, no response is required!");
        if( result == 0 )
        {   
            TestStepPass("INFO","Response did not arrive as expected!");
        }
        else
        {
            TestStepFail("INFO","Response arrived but it was NOT expected!");
        }
    }

}

//Save the previously received response to a global variable
void saveResponse()
{
    int i;
    for (i=1; i<2048; i++)
    { 
        seedString[i] = byteString[i];
        seedData[i] =  RsRxIntData[i];
        //write(">>save<< seedString values: %c",seedString[i]);
    }
}

//Compare the previously saved seed with the actual.
int compareSeedAlgo()
{
    int i, equal;
    equal = 0;
    for (i=4; i<12; i++)
    { 
        write("seedString values: %c",seedString[i]);
        write("byteString values: %c",byteString[i]);
        if (seedString[i] != byteString[i])
        {
            equal++;
        }
    }
    if (equal == 0)
    {   
        return 1;//TestStepPass("INFO","Seeds are identical!");
    }
    else
    {
        return 0;//TestStepFail("INFO","Seeds are different!");
    }
}

//Send key to the camera based on the previously saved seed
void sendKeyAlgo(char sendKey[], char sendKeyResponse[], dword Pin)
{
	dword authKey;
    byte resultarray[6] = {0,0,0,0,0,0};

    resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
    resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);

    authKey = seedData[5] |
           (seedData[4] << 8) |
           (seedData[3] << 16) |
           (seedData[2] << 24);
      
    authKey = authKey + Pin;
        
    resultarray[5] = (byte)(authKey & 0xff);
	resultarray[4] = (byte)((authKey >> 8) & 0xff);
	resultarray[3] = (byte)((authKey >> 16) & 0xff);
	resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
    CreateByteString(resultarray, 0, elcount(resultarray));

    if(0 == strncmp("None", sendKeyResponse,strlen(sendKeyResponse)))
    {
        RequestResponseCompareLogic(byteString, "", "None");
    }
    else
    {
        RequestResponseCompareLogic(byteString, sendKeyResponse, "Equal");
    }  
}

void sendKeyAlgoREP(char sendKey[], char sendKeyResponse[], dword REP_A_Key, dword REP_B_Key, dword REP_C_Key, dword REP_D_Key)
{
    dword authKey;
    dword tempkey;
    dword keyLowValue, keyUpperValue;
    dword keyMaxValue = 0xFFFFFFFF; 
    int i;
    byte resultarray[6] = {0,0,0,0,0,0};

    resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
    resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);

    authKey = seedData[5] |
           (seedData[4] << 8) |
           (seedData[3] << 16) |
           (seedData[2] << 24);
               
    for(i = 0; i <7 ; i++)
    {

        tempkey = authKey ;
        authKey = authKey + REP_A_Key;
        // write(" tempkey and authKey  for j value %i beginning loop: %lx, %lx ",j, tempkey, authKey );    

        if((keyMaxValue - REP_A_Key) < tempkey)
        {
        /* Rotate Right by 10 */
            keyLowValue = authKey & (0x000003FF);
            keyUpperValue = keyLowValue << 22;
            authKey = authKey >> 10;
            authKey = authKey | keyUpperValue;
            authKey = authKey ^ REP_B_Key;
        }
        else
        {
        /* Rotate Left by 13 */
            keyUpperValue = authKey & (0xFFF80000);
            keyLowValue   = keyUpperValue >> 19;
            authKey      = authKey << 13;
            authKey      = authKey | keyLowValue;
            authKey      = authKey ^ REP_C_Key;
        }
    }

    authKey = authKey - REP_D_Key;
        
    resultarray[5] = (byte)(authKey & 0xff);
	resultarray[4] = (byte)((authKey >> 8) & 0xff);
	resultarray[3] = (byte)((authKey >> 16) & 0xff);
	resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
    CreateByteString(resultarray, 0, elcount(resultarray));

    if(0 == strncmp("None", sendKeyResponse,strlen(sendKeyResponse)))
    {
        RequestResponseCompareLogic(byteString, "", "None");
    }
    else
    {
        RequestResponseCompareLogic(byteString, sendKeyResponse, "Equal");
    }
}

void sendKeyAlgoRBEOL(char sendKey[], char sendKeyResponse[], dword RBEOLPin, dword PMARequest)
{
	  //Calculation of the key is described in MPC2 MDC DCOM BASE module:
      //doors://abt-doors-da.de.bosch.com:36665/?version=2&prodID=0&view=0000001d&urn=urn:telelogic::1-4147106800294823-O-1044-0002a241
      dword authKey;
      byte resultarray[6] = {0,0,0,0,0,0};
      
      resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
      resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);
      
      authKey = seedData[5] |
               (seedData[4] << 8) |
               (seedData[3] << 16) |
               (seedData[2] << 24);
               
      authKey = authKey & RBEOLPin; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
      authKey = authKey | PMARequest; //Plant mode activation part request
      
      resultarray[5] = (byte)(authKey & 0xff);
	  resultarray[4] = (byte)((authKey >> 8) & 0xff);
	  resultarray[3] = (byte)((authKey >> 16) & 0xff);
	  resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
      CreateByteString(resultarray, 0, elcount(resultarray));

      if(0 == strncmp("None", sendKeyResponse,strlen(sendKeyResponse)))
      {
        RequestResponseCompareLogic(byteString, "", "None");
      }
      else
      {
        RequestResponseCompareLogic(byteString, sendKeyResponse, "Equal");
      }
}

changeSession(int sessionId)
{
	  byte buffer[2];
    long result;
    byte responsePending = 0;
    int  numberRPs;
    long timeOutValue = 1000;
    long rc = 0;

    buffer[0] = 0x10;
    buffer[1] = sessionId;

    OSEKTL_DataReq(buffer, 2);

    do
    {
        responsePending = 0;
        result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);

        if(result == 0)
        {
            TestStepFail("INFO","Timeout while waiting for diag response");          
        }
        else if(result == 1)
        {
            TestStep("INFO","Diag response received!");
            TestStep("INFO","$%02x %02x %02x %02x %02x %02x %02x", RsRxIntData[0], RsRxIntData[1], RsRxIntData[2], RsRxIntData[3], RsRxIntData[4], RsRxIntData[5], RsRxIntData[6]);
            
            if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == 0x10 )
            {
                if( RsRxIntData[2] == 0x78 )
                {
                    TestStep("INFO","Response Pending received from ECU");
                    responsePending = 1;
                    numberRPs++;
                    timeOutValue = 5000;
                }
                else
                {
                    TestStepFail("INFO","Diag session could not be set!");
                }

            }
            else if( RsRxIntData[0] == 0x50 && RsRxIntData[1] == sessionId )
            {
                TestStepPass("INFO","Diag session successfully set!");
            }
            else
            {
                TestStep("INFO","Waiting...");
                responsePending = 1;
            }

        }

    } while( (responsePending == 1) && (numberRPs < 24) );
}

/*on message XCP_MPC_DTO
{
    Msg_XCP_MPC_DTO = this;

    if(Msg_XCP_MPC_DTO.byte(0) == 0xFF)
    {
      TestSupplyTextEvent("XCPConnection CAN1");
    }
}*/

//on message XCP_Kamera_DTO_01
//{
//    Msg_XCP_Kamera_DTO_01 = this;
//
//    if(Msg_XCP_Kamera_DTO_01.byte(0) == 0xFF)
//    {
//      TestSupplyTextEvent("XCPConnection CAN2");
//    }
//}

OSEKTL_DataCon (long c)
{
    TestStep("INFO","Data Transmission done!");
    //write ("Successfully sent data length: %d", c);
}

OSEKTL_DataInd (long count)
{
    int RIP;
    int i = 0;
    //char tmpString[255];

    RIP = SID + 0x40;
    OSEKTL_GetRxData(RsRxIntData, elcount(RsRxIntData));

    if(count <= elcount(RsRxIntData))
    {
        if(0x7F == RsRxIntData[0] &&
           0x21 == RsRxIntData[2]  )
        {
           
            OSEKTL_DataReq(RqTxData, ByteSize);
            write("Busy Repeat Request detected -> Repeat last request!");
            write("***********************************************************");
        }
        else if(0x7F == RsRxIntData[0] && 0x36 == RsRxIntData[1] &&
           0x78 == RsRxIntData[2]  )
        {
            OSEKTL_FI_AbortTx();
            setTimer(Act20ms,20);

        }
        else
        {
          switch(routineHandle)
          {
            case 10:
                CreateByteString(RsRxIntData, 0, count);
                snprintf(g_TextEvent, elcount(g_TextEvent), "Datablock%d",RsRxIntData[1]);
                TestSupplyTextEvent(g_TextEvent);
                break;
       // write("Debug ==> the value of RsRxIntData is: - %x", RsRxIntData[1]);
            default:
                CreateByteString(RsRxIntData, 0, count);
                TestSupplyTextEvent("TpMsgReceived");
                break;
          }
        }
    }
}

OSEKTL_ErrorInd(int error)
{
    


long FI_ID ;

write("Surya TP Error %d", error);

    if (!OSEKTL_GetRxId())
    {	
    switch( error )
	{
		case 1: 	
			write(" Error (%d): Timeout while waiting for CF",  error );
			putValue( EnvReqStatus_CAN, "Timeout while waiting for CF" );
			putValue( EnvRespTime_CAN, OSEKTL_GetTimeoutCF() );	
		break;

		case 2: 	
			write(" Error (%d): Timeout while waiting for FC",  error ); 
			putValue( EnvReqStatus_CAN, "Timeout while waiting for FC" );
			putValue( EnvRespTime_CAN, OSEKTL_GetTimeoutFC() );			
		break;

		case 3:
		 	write(" Error (%d): Wrong Sequence Number",  error );
			putValue( EnvReqStatus_CAN, "Wrong Sequence Number" );
		break;

		case 4:
		 	write(" Error (%d): TP_DLL busy",  error ); 
			putValue( EnvReqStatus_CAN, "TP_DLL busy" );
		break;

		case 5:
		 	write(" Error (%d): Unexpected PDU",  error ); 
			putValue( EnvReqStatus_CAN, "Unexpected PDU" );
		break;

		case 6:
		 	write(" Error (%d): Timeout while trying to send a CAN frame",  error );
			putValue( EnvReqStatus_CAN, "Timeout while trying to send a CAN frame" );
		break;

		case 7:
		 	write(" Error (%d): Too many FCs: WFT Overrun",  error ); 
			putValue( EnvReqStatus_CAN, "To many flow control: WFT Overrun" );
		break;
		
		case 8:
			write(" Error (%d):Receiver buffer overflow",  error ); 
			putValue( EnvReqStatus_CAN, "Receiver buffer overflow" );
		break;

		case 9:
			write(" Error (%d): Wrong parameter",  error ); 
			putValue( EnvReqStatus_CAN, "Wrong parameter" );
		break;
		
		default: 	
			write(" Error (%d): unknown error",  error ); 
			putValue( EnvReqStatus_CAN, "unknown error" );
		break;
	}
    }


}

//on sysvar Diag::PlainData
//{
//    int i = 0;
//    int byteLen = 1023;
//    char c1;
//    char c2;
//    int strIndex = 0;
// 
//    for (i = 0; i < elcount(RqTxStringData); i++)
//    {
//        RqTxStringData[i] = 0;
//    }
//    SysGetVariableString(sysvar::Diag::PlainData, RqTxStringData, elcount(RqTxStringData));
//
//    ByteSize = 0;
//    for (i = 0; i < byteLen; i++)
//    {
//        strIndex = i * 2;
//        if (RqTxStringData[strIndex] != 0)
//        {
//            c1 = RqTxStringData[strIndex];
//            c2 = RqTxStringData[strIndex + 1];
//            RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);
//            ByteSize++;
//        }
//    }
//    SID = RqTxData[0];
//}

on envVar EnvTransmitDataODX
{
    routineHandle = getValue(this);
}

byte char2byte (char c, int factor)
{
    switch(c){
    case 'F':
    case 'f': return 15 * factor;
    case 'E':
    case 'e': return 14 * factor;
    case 'D':
    case 'd': return 13 * factor;
    case 'C':
    case 'c': return 12 * factor;
    case 'B':
    case 'b': return 11 * factor;
    case 'A':
    case 'a': return 10 * factor;
    case '9': return 9 * factor;
    case '8': return 8 * factor;
    case '7': return 7 * factor;
    case '6': return 6 * factor;
    case '5': return 5 * factor;
    case '4': return 4 * factor;
    case '3': return 3 * factor;
    case '2': return 2 * factor;
    case '1': return 1 * factor;
    }
    return 0;
}

testcase CommonRequest (char expResp[], int isSubstring)
{
    /* isSubstring is an extension for being able to check whether the response contains the expResp as substring */
    /* values: 0 - expResp has to match with the whole response                                                   */
    /*         1 - expResp can be a substring of the response                                                     */
    /*         2 - it is expected that the response does not contain expResp as substring                         */

    long result;
    byte responsePending;
    byte suppressPositive;
    int numberRPs;
    long timeOutValue;
    long rc;

    responsePending = 0;
    numberRPs = 0;
    timeOutValue = 5000;
    rc = 0;
	
    //OSEKTL_ActivateAck(1);
    OSEKTL_DataReq(RqTxData, ByteSize);
    
    //check whether the suppress positive is switvhed on in the request
    //if yes, no response is expected
    suppressPositive = RqTxData[1] >> 4;
    
    if (suppressPositive != 0x08)
    {
      do
      {
          responsePending = 0;
          result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
          if(result == 0)
          {
              TestStepFail("INFO","Timeout while waiting for diag response");          
          }
          else if(result == 1)
          {
              TestStep("INFO","Diag response received!");
              TestStep("INFO","EXPECTED: %s", expResp);
              TestStep("INFO","RECEIVED: %s", byteString);
              
              if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID )
              {
                  if( RsRxIntData[2] == 0x78 )
                  {
                      TestStep("INFO","Response Pending received from ECU");
                      responsePending = 1;
                      numberRPs++;
                      timeOutValue = 10000;
                  }
                  else
                  {
                      TestStep("INFO","Negative response received!");

                      if(0 == isSubstring)
                      {
                          if(0 == strncmp(byteString, expResp, strlen(expResp)) && strlen(byteString) == strlen(expResp))
                          {
                              TestStepPass("1.1","Expected NRC received!");
                          }
                          else
                          {
                              TestStepFail("1.1","Unexpected NRC received!");
                          }
                      }
                      else
                      {
                          if(-1 != strstr(byteString, expResp))
                          {
                              if(1 == isSubstring)
                              {
                                  TestStepPass("1.1","Expected substring in NRC received!");
                              }
                              else
                              {
                                  TestStepFail("1.1","NRC contains not expected substring!");
                              }
                          }
                          else
                          {
                              if(2 == isSubstring)
                              {
                                  TestStepPass("1.1","NRC does not contain not expected substring!");
                              }
                              else
                              {
                                  TestStepFail("1.1","Expected substring in NRC not received!");
                              }
                          }
                      }
                  }

              }

              if( RsRxIntData[0] == (SID + 0x40) )
              {
                  TestStep("INFO","Positive Response from ECU!");

                  if(0 == isSubstring)
                  {
                      if(0 == strncmp(byteString, expResp, strlen(expResp))&& strlen(byteString) == strlen(expResp))
                      {
                          TestStepPass("1.1","Expected response received!");
                      }
                      else
                      {
                          TestStepFail("1.1","Unexpected response received!");
                      }
                  }
                  else
                  {
                      if(-1 != strstr(byteString, expResp))
                      {
                          if(1 == isSubstring)
                          {
                              TestStepPass("1.1","Expected substring in response received!");
                          }
                          else
                          {
                              TestStepFail("1.1","Response contains not expected substring!");
                          }
                      }
                      else
                      {
                          if(2 == isSubstring)
                          {
                              TestStepPass("1.1","Response does not contain not expected substring!");
                          }
                          else
                          {
                              TestStepFail("1.1","Expected substring in response not received!");
                          }
                      }
                  }
              }

          }

      } while( (responsePending == 1) && (numberRPs < 24) );

      if( responsePending == 1 )
      {
          TestStepFail("1.1","Timeout while waiting for diag response!");
      }
    }
}

testcase RequestResponseCanMsgId(char Request[], char Response[], char CompareMode[], int rxId, int txId)
{
    /* CompareMode is an extension for being able to check whether the response contains the Response as substring */
    /* values: Equal  - Response has to match with the whole response                                                   */
    /*         Regexp - Response can be a substring of the response                                                     */
    /*         None   - it is expected that the response does not contain Response as substring                         */


// Check whether is the rxId and the txId is empty (empty = 0)
    if(rxId != 0 && txId !=0)
    {
      setType (rxId, txId);
    }
    else 
    {
      setType (0x76B,0x763);
    }
         
    RequestResponseCompareLogic(Request, Response, CompareMode);
    
    //Reset the deafult CAN message IDs
    //setType (0x76B,0x763);
}

testcase RequestResponse(char Request[], char Response[], char CompareMode[])
{
  RequestResponseCompareLogic(Request, Response, CompareMode);
}

testcase ResetCamera(dword WaitTime)
{

  long result;
  
	RequestResponseCompareLogic("1101", "5101", "Equal");
  result = testWaitForTimeout(WaitTime);
  if (-1 == result)
  {
//    write ("General error with the testWaitForTimeout function, for example, functionality is not available!");
    TestStepFail("INFO","General error with the testWaitForTimeout function, for example, functionality is not available!");
  } else if (-2 == result)
  {
//    write ("Resume due to constraint violation in the testWaitForTimeout function!");
    TestStepFail("INFO","Resume due to constraint violation in the testWaitForTimeout function!");
  }
}

testcase Login (char LoginType[])
{ 
  dword repairFixValue, devFixValue;
  
  //init
  repairFixValue = 0x4e87;
  devFixValue = 0x15e57;
  
  
  if(0 == strncmp("AppRepair", LoginType, strlen(LoginType)))
  {
//    write ("Debug == > LoginType is: %s", LoginType);
    TestStep("INFO","The LoginType is: %s", LoginType);
    RequestResponseCompareLogic("2703", "6703.+", "Regexp");
    saveResponse();
    sendKeyAlgo("2704", "6704", repairFixValue);
  }
  else if(0 == strncmp("AppDev", LoginType, strlen(LoginType)))
  {
//    write ("Debug == > LoginType is: %s", LoginType);
    TestStep("INFO","The LoginType is: %s", LoginType);
    RequestResponseCompareLogic("2703", "6703.+", "Regexp");
    saveResponse();
    sendKeyAlgo("2704", "6704", devFixValue);
  }
  else if(0 == strncmp("FblRep", LoginType, strlen(LoginType)))
  {
    TestStep("INFO","The LoginType is: %s", LoginType);
    RequestResponseCompareLogic("2711", "6711.+", "Regexp");
    saveResponse();
    sendKeyAlgoREP("2712", "6712", 0x41916668, 0x12774118, 0x86905668, 0x10371229);
  }
  else if(0 == strncmp("RBEOL", LoginType, strlen(LoginType)))
  {
//    write ("Debug == > LoginType is: %s", LoginType);
    TestStep("INFO","The LoginType is: %s", LoginType);
    RequestResponseCompareLogic("2761", "6761.+", "Regexp");
    saveResponse();
    sendKeyAlgoRBEOL("2762", "6762", 0x42444441, 0x80FA1108); 
  }
  else
  {
//    write ("The LoginType is wrong! %s",LoginType);  
//    write ("Please choose from the following Login types: AppDev, AppRepair, FblRep, RBEOL!");
    TestStepFail("INFO","The LoginType is not valid!");
    TestStepFail("INFO","Please choose from the following Login types: AppDev, AppRepair, FblRep, RBEOL!");
  }  
}

testcase DiagSessionCtrl (char sessionName[])
{
    
    int sessionId;
    
    if(0 == strncmp("Default", sessionName, strlen(sessionName)))
      {
//        write ("Debug == > sessionName is: %s", sessionName);
        TestStep("INFO","The sessionName is: %s", sessionName);
        sessionId = 0x01;
        changeSession(sessionId);   
      }
    else if(0 == strncmp("Extended", sessionName, strlen(sessionName)))
    {
//      write ("Debug == > sessionName is: %s", sessionName);
      TestStep("INFO","The sessionName is: %s", sessionName);
      sessionId = 0x03;
      changeSession(sessionId);   
    }
    else if(0 == strncmp("EOL", sessionName, strlen(sessionName)))
    {
//      write ("Debug == > sessionName is: %s", sessionName);
      TestStep("INFO","The sessionName is: %s", sessionName);
      sessionId = 0x40;
      changeSession(sessionId);
    }
    else if(0 == strncmp("Development", sessionName, strlen(sessionName)))
    {
//      write ("Debug == > sessionName is: %s", sessionName);
      TestStep("INFO","The sessionName is: %s", sessionName);
      sessionId = 0x4f;
      changeSession(sessionId);   
    }
    else if(0 == strncmp("Programming", sessionName, strlen(sessionName)))
    {
//      write ("Debug == > sessionName is: %s", sessionName);
      TestStep("INFO","The sessionName is: %s", sessionName);
      sessionId = 0x02;
      changeSession(sessionId);   
    }
    else
    {
//       write ("The sessionName is not valid! %s",sessionName);  
//       write ("Please choose from the following sessionName types: Default, Extended, EOL, Development, Programming!");
       TestStepFail("INFO","The sessionName is not valid!");
       TestStepFail("INFO","Please choose from the following sessionName types: Default, Extended, EOL, Development, Programming!");
    }
    putvalue(EnvTesterPresentOnOff,1);
}

testcase SaveSignalValue (char EnvvarName[])
{
    StoredSignalValue = getValue (EnvvarName);
}

testcase RestoreSignalValue (char EnvvarName[])
{
    putValue (EnvvarName, StoredSignalValue);
}

testcase WaitForMessage (char MessageName[], long Timeout)
{
    dword MessageID;
    MessageID = GetMessageID(MessageName);

	write("ID= %x", MessageID);
    
    WaitForMessageFunction(MessageID, Timeout);

}

void WaitForMessagefunction(dword MessageID, long Timeout)
{
  long result =0;
/* if(MessageID == 0x312)
  {
    //result= TestWaitForMessage(DM_MSB_SysSt, Timeout);
  }
  else if(MessageID == 0x170)
  {
    //result= TestWaitForMessage(SCU_Local_Info, Timeout);
  }
 else if(MessageID == 0x20F)
  {
    //result= TestWaitForMessage(XPU_ESP_LKACtrl, Timeout);
  }
 else if(MessageID == 0x90)
  {
    result= TestWaitForMessage(RDR_Status, Timeout);
  }
  	else
	{
		result = TestWaitForMessage(MessageID, Timeout);      
	} */
	
  result = TestWaitForMessage(MessageID, Timeout);
  
  if (result == 1)
	{
		//Signal with expected value arrived!      
		TestStepPass("INFO","The message arrived");
	}
	else if (result == 0)
	{ 
		//Timeout occured!       
		TestStepFail("INFO","The message has not arrived within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Constraint violation!");
	}
	else
	{
		TestStepFail("INFO","General error!");
	}
  
}  

testcase Wait(long Time)
{
	TestWaitForTimeout(Time);
}

testcase SetEnvVar(char Name[], char Value[], long WaitTime)
{
    function_SetEnvVar(Name, Value, WaitTime);
} 
function_SetEnvVar(char Name[], char Value[], long WaitTime)
{
    int intValue;
	float floatValue;
	
	if(1 == str_match_regex(Value, "^(\\d+)$")) //int
	{
		intValue = atol(Value);
		strtod(Value, floatValue);
		putValue(Name, intValue);
		putValue(Name, floatValue);
        TestStepPass("Passed","The %s envvar (int) value was set to %s .", Name, Value);	
	}
	else if(1 == str_match_regex(Value, "^(\\d+(\\.\\d+)?)$")) //float
	{
		strtod(Value, floatValue);
		putValue(Name, floatValue);
        TestStepPass("Passed","The %s envvar (float) value was set to %s .", Name, Value);	
	}
	else //string
	{
		putValue(Name, Value);
        TestStepPass("Passed","The %s envvar (string) value was set to %s .", Name, Value);	
	}
	if(WaitTime == 0) //Handling to avoid infinite loop
	{
		TestWaitForTimeout(1);
	}
	else
	{
		TestWaitForTimeout(WaitTime);
	}
}
void CreateByteString (byte response[], long offset,long responseLength)
{
    char intString[1023];
    char catString[10];
    int i=0;
    long dataLength;

    snprintf(byteString, elcount(byteString), "");
    dataLength = responseLength;

    for(i=offset; i < dataLength;i++)
    {
        ltoa(response[i], intString, 16);

        if( 1==strlen(intString) )
        {
            snprintf(catString, elcount(catString), "0");
            strncat(catString, intString, elcount(catString));
            strncpy(intString, catString, elcount(intString));
        }
       
        strncat(byteString, intString, elcount(byteString));
    }

//    write("Debug ==> Created byte string - %s", byteString);
}

on timer Act20ms
{
   /* DSDL.byte(0) = 0x11;
    DSDL.byte(0) = 0x02;
    DSDL.byte(0) = 0x36;
    DSDL.byte(0) = 0x02;
    DSDL.byte(0) = 0x99;
    DSDL.byte(0) = 0x3E;
    DSDL.byte(0) = 0x00;
    DSDL.byte(0) = 0x00;
    output(DSDL);*/
}


testcase RequestResponseTimeElapsed(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
    
	RequestResponseTimeElapsedFn(Request, Response, CompareMode, aTime1, aTime2);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Measures the time interval between a sent request and an expected response.
//!
//! \note	This testcase sends a diagnostic request and waits for a specific response.
//! 		Measures the time interval between the first sent request and the awaited response.
//! 		This time interval is compared to an expected time interval.
//!
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used.
//! \param  char aTime1 is the low threshold of the expected time interval in ms.
//! \param  char aTime2 is the high threshold of the expected time interval in ms.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void RequestResponseTimeElapsedFn(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
	byte responsePending;
	long result;
	long timeOutValue;
	int numberRPs;
	float startTime1;
	float startTime2;
	float endTime;
	int respOk;
	int i;
	int telapsed_req_res;
	float time1;
	float time2;
 
	//Init
	respOk = 0;
	endTime = 0;
	i = 0;
	time1 = 0;
	time2 = 0;
  
	time1 = atodbl(aTime1);
	time2 = atodbl(aTime2);
    
	responsePending = 0;
	numberRPs = 0;
	timeOutValue = 5000;
	telapsed_req_res = 0;
	
	
	
  
	//Check the validity of the compare mode
	if( ! (0 == strncmp("Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("None", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) 
		|| 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual", CompareMode,strlen(CompareMode))|| 0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode))))
	{
		TestStepFail("INFO","The CompareMode '%s' is not valid!", CompareMode);
		TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed!");
	}
	else
	{
		//The compare mode is valid
		    
		//Set timer (t20ms) to 20ms
		setTimer(t20ms, 20);
		//Store start time
		startTime1 = timeNow()/100.0;
  
		//START check the response from the camera: 
		do
		{ 
			if( (endTime - startTime2)/100.0 < 20.0 && (i != 0)) //
		{
			TestWaitForTextEvent("Minimum time delay is reached!", 2);
		}
		else if(  timeToElapse(t10ms) > 0 )
		{
			//long timeToElapse(mstimer t) (Form 2)			
			TestWaitForTextEvent("Maximum time delay is reached!", 5);
		}
      
  		CharArray2Byte(Request);              // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
  		TestStep("INFO","REQUEST: %s (The compare mode is: %s)", Request, CompareMode);
      
                //OSEKTL_ActivateAck(1);
  		OSEKTL_DataReq(RqTxData, ByteSize);   //Sending out Request in a RxTxData global byte array
		//setType (0x7B9,0x74F);
       // setType (0x18DAF1B5,0x18DAB5B0); //Modified the CAN-IDs for Honda.
		setTimer(t20ms, 20);
		startTime2 = timeNow()/100.0;
      
		//Wait for the message from the camera
		responsePending = 0;
		result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
                endTime = timeNow()/100.0;
      
		// if elapsed time more than 20ms, start 10ms counter
		telapsed_req_res = endTime - startTime2;
		
		if( (telapsed_req_res)/100.0 >= 20.0 )
	    {
		    setTimer(t10ms,10); // set timer (t10ms) to 10ms
	    }
      
		if(result == 0)
		{  
			//If no response is received
			responseMatching(CompareMode, Response, numberRPs, "Noresponse", result);
		}
		else if(result == 1)
		{    
			//If response is received
			//Negative branch starts
			if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID ) 
			{ 
				respOk = 0;
				if( RsRxIntData[2] == 0x78 )
				{
					TestStep("INFO","Response Pending received from ECU");
					responsePending = 1;
					numberRPs++;
					timeOutValue = 10000;
				}
				else
				{
					//TestStep("INFO","Negative Response from ECU!");
					responseMatching(CompareMode, Response, numberRPs, "NRC", result);
				}
			}
			//Positive branch starts
			if( RsRxIntData[0] == (SID + 0x40) )  
			{
				//TestStep("INFO","Positive Response from ECU!");
				respOk = responseMatching(CompareMode, Response, numberRPs, "response", result);
			}	
		}
		i++;
	        }while( ((responsePending == 1) && (numberRPs < 24)) || ((respOk != 1) && ((endTime - startTime1) < 35000.0)) );  //Handling of pending response  and maximum testcase duration
	        }
		if( responsePending == 1 )
		{
			TestStepFail("INFO","Timeout while waiting for diag response!");
		}
		
		
		
		//if(qTime <= 100)
		//{
			//telapsed_req_res = telapsed_req_res - 10;
		//	endTime = endTime - 10.0;
		//}

  //Evaluation of test result
	TestStep("INFO","Start Time [ms]: %f", startTime1);
	TestStep("INFO","End Time [ms]: %f", (endTime - telapsed_req_res));
	TestStep("INFO","Elapsed Time [ms]: %.0f",(endTime - startTime1 - telapsed_req_res) );
  
	if((endTime - startTime1 - telapsed_req_res) >= 35000.0)
	{
		testStepFail("INFO", "TestStep timeout!");
	}
	else if(((endTime  - startTime1 - telapsed_req_res) >= time1) && ((endTime - telapsed_req_res - startTime1) <= time2))
	{
		testStepPass("INFO", "Elapsed time is in the expected range!");
	}
	else
	{
		testStepFail("INFO", "Elapsed time is out of the expected range!");
	}
}

int responseMatching(char CompareMode[], char Response[], int NumberRPs, char MessageFormat[], long Result)
{
	if(Result == 1)
	{
		TestStep("INFO","EXPECTED: %s", Response);
		TestStep("INFO","RECEIVED: %s", byteString);
		//Message received, Compare mode is equal
		if(0 == strncmp("Equal", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
			{
				TestStepPass("INFO","Expected %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is regexp
		else if(0 == strncmp("Regexp", CompareMode,strlen(CompareMode)))
		{   
			if(1 == str_match_regex(byteString, Response))
			{
				TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is not equal
		else if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)))
		{
			if(0 != strncmp(byteString, Response, strlen(Response)) || strlen(byteString) != strlen(Response))
			{
				TestStepPass("INFO","Not equal %s received as expected!", MessageFormat);
				return 1;
			}
			else
			{      
				TestStepFail("INFO","Equal %s is received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is suppressed (equal or regexp)
		else if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp("response", MessageFormat,strlen(MessageFormat)))
			{
				if(NumberRPs > 0)
				{
					if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
					{
						if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
						{
							TestStepPass("INFO","Expected %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","Unexpected %s received after response pending!", MessageFormat);
							return 0;
						}
					}
					else
					{
						if(1 == str_match_regex(byteString, Response))
						{
							TestStepPass("INFO","Expected substring in %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","There is not expected substring after response pending in %s!", MessageFormat);
							return 0;
						}
					}
				}
				else
				{
					TestStepFail("INFO","Response received without response pending!");
					return 0;
				}
			}
			else
			{
				if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
				{
					if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
					{
						TestStepPass("INFO","Expected %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","Unexpected %s received!", MessageFormat);
						return 0;
					}
				}
				else
				{
					if(1 == str_match_regex(byteString, Response))
					{
						TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","There is not expected substring in %s!", MessageFormat);
						return 0;
					}
				}	
			}
		}
		//Message received, Compare mode is regexpNoFailed
		else if(0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode)))
		{   
			if(1 == str_match_regex(byteString, Response))
			{
				TestStep("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStep("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepFail("INFO","Response arrived but it was NOT expected!");
			return 0;
		}
	}
	else
	{
		//Message does not received, Compare mode is suppressed (equal or regexp)
		if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(NumberRPs == 0)
			{
				TestStepPass("INFO","No response pending and no response are received as expected!");
				return 1;
			}
			else
			{
				TestStepFail("INFO","No response is received after response pending!");
				return 0;
			}
		}
		//Message does not received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepPass("INFO","Response did not arrive as expected!");
			return 1;
		}
		//Message does not received, Compare mode is RegexpNoFailed
		else if(0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode)))
		{
			TestStep("INFO","Response did not arrive.");
			return 0;
		}
		//Message does not received, Compare mode is not supported here
		else
		{
			TestStepFail("INFO","Timeout while waiting for diag response");
			return 0;
		}
	}
}

testcase setenv_CRC_BZ (char Name[] ,int Value , int WaitTime )
{
  write("qwerty");
 putValue(Name, Value);
}

//- -----------------------------------------------------------------------------------------------
//! \teststep Send $2 Events.
//! \testresponse - . 
//- -----------------------------------------------------------------------------------------------
testcase Check_Eventmessage_failure(char MsgEnvVar[],int Nrofevents) // Nrofevents=Nrofevents-1
{
  int i=0;
for(i=0;i<Nrofevents;i++)
{
putValue(MsgEnvVar, 1);
testwaitfortimeout(50);
putValue(MsgEnvVar, 0);
}
}
//Alternative method
testcase Check_Cyclemessage_failure(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
  Check_Cyclemessage_failureFn( Request,  Response,  CompareMode,  aTime1,  aTime2);
} 
void Check_Cyclemessage_failureFn(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
  long aTime_1;
  long aTime_2;
  long aTime_3;
  long aTime_4;
  long aTime_5;
  float startTime;
	float Endtime;
  aTime_1=atol(aTime1);
  aTime_2=atol(aTime2);
  aTime_3=aTime_1-5;
  aTime_4=aTime_2-aTime_3;  
  startTime= timeNow()/100.0;
  testwaitfortimeout(aTime_3); 
  TestStep("INFO","check DTC after [ms]: %d", aTime_3);
  RequestResponseCompareLogic(Request, "5906.*", "Regexp");
  testwaitfortimeout(aTime_4);
  TestStep("INFO","check DTC after [ms]: %d", aTime_4+aTime_3);
  RequestResponseCompareLogic(Request,Response, "Regexp");
  Endtime= timeNow()/100.0;
  //TestStep("INFO","startTime [ms]: %f", startTime); 
  //TestStep("INFO","Endtime [ms]: %f", Endtime);
  //write("shyla %d",aTime_3);
  //TestStep("INFO","Elapsed time [ms]: %f", (Endtime-startTime));
    //TestStep("INFO","aTime_3 [ms]: %d", aTime_3);
    //TestStep("INFO","aTime_3t [ms]: %f", aTime_4);
  
}

//DLC check
testcase Check_CyclemessageDLC_failure(char EnDLCEnvVar[],char DLCEnvVar[],char Request[], char DTCActiveResponse[],char DTCPassiveResponse[], char CompareMode[], int MessageDLC, int maxQT)
{
  Check_CyclemessageDLC_failureFn( EnDLCEnvVar, DLCEnvVar, Request,  DTCActiveResponse, DTCPassiveResponse,  CompareMode,  MessageDLC ,maxQT);
}
void Check_CyclemessageDLC_failureFn(char EnDLCEnvVar[],char DLCEnvVar[],char Request[], char DTCActiveResponse[],char DTCPassiveResponse[], char CompareMode[], int MessageDLC,int maxQT)
{
  int DLC;
  int temp_DLC;
  temp_DLC=MessageDLC-1;
  DLC=MessageDLC;
  putValue(EnDLCEnvVar, 1);
  while (MessageDLC)
  {
   DLC = DLC-1;
   //write("DLC %d",DLC);
   putValue(DLCEnvVar, DLC);
   if(DLC==temp_DLC)
   {
    testwaitfortimeout(maxQT);
   }
   TestStep("INFO","DTC @ invalid DLC: %d", DLC);
   RequestResponseCompareLogic(Request,DTCActiveResponse,CompareMode);
   if (DLC==0)
  {
     putValue(EnDLCEnvVar, 0);
     testwaitfortimeout(maxQT);
     TestStep("INFO","DTC @ valid DLC: %d", MessageDLC);
     RequestResponseCompareLogic(Request,DTCPassiveResponse,CompareMode); 
     break;
  }   
  } 
}

// DTC check using counters
testcase Check_Counetr_failure(char MsgEnvVar[],char Request[], char Response[], char CompareMode[],int Nrofevents) // Nrofevents=Nrofevents-1
{
  int i=0;
for(i=0;i<Nrofevents;i++)
{
putValue(MsgEnvVar, 1);
testwaitfortimeout(100);
putValue(MsgEnvVar, 0);
TestStep("INFO","No of Event =: %d", i+1);
RequestResponseCompareLogic(Request,Response, CompareMode);
}
}


testcase Check_waitformessage_failure(char Msgname[],char Request[], char Response[], char CompareMode[],int Nrofevents) // Nrofevents=Nrofevents-1
{
  int i=0;
for(i=0;i<Nrofevents;i++)
{
 dword MessageID;
 MessageID = GetMessageID(Msgname);
 //write("ID= %x", MessageID);   
 WaitForMessageFunction(MessageID, 5000);
TestStep("INFO","Number of times message %s received = %d",Msgname, i+1);
//RequestResponseCompareLogic(Request,Response, CompareMode);
}
//if (Nrofevents==1)
//{
//testwaitfortimeout(10);  
//}
//testwaitfortimeout(10);
RequestResponseCompareLogic(Request,Response, CompareMode);
}



testcase ignition_cycles_10()
{
int i=0;
for(i=0;i<10;i++)
{

	putvalue(EnvTesterPresentOnOff, 1);
	RequestResponseCompareLogic("1003", "5003003200c8", "Equal");
    testwaitfortimeout(1000);
	RequestResponseCompareLogic("1101", "5101", "Equal");
	testwaitfortimeout(3000);
	RequestResponseCompareLogic("190209", "590209c1518708.*", "Regexp");
	putvalue(EnvTesterPresentOnOff, 0);
}
}

testcase ignition_cycles_9()
{
int i=0;

putvalue(EnvTesterPresentOnOff, 1);
for(i=0;i<9;i++)
{
putvalue(EnvTesterPresentOnOff, 1);
	RequestResponseCompareLogic("1003", "5003003200c8", "Equal");
    testwaitfortimeout(1000);
	RequestResponseCompareLogic("1101", "5101", "Equal");
	testwaitfortimeout(3000);
	RequestResponseCompareLogic("190209", "590209c1518708.*", "Regexp");
	putvalue(EnvTesterPresentOnOff, 0);
putvalue(EnvTesterPresentOnOff, 0);
}
}

