/*@!Encoding:1252*/
/*@!Encoding:1252*/

variables
{  
  int seq = 0;
char buffer[1]={61};
char empty_buffer[255];
//msTimer   Tm_RBEOL_manual_write;


  
    byte      emptyString[4098];
    //byte    TesterPresentOnOff=0;
    byte      DiagSession=0;
   
   	//Transmit
    const int txSize = 4096;
	byte 	  TxDataBuffer[txSize];
   	int       TxLength;
    byte      TxDataBuffer_temp[3]={22,22,22};
   
   
    //Receive
    const int rxSize = 4098;
	byte 	  RxDataBuffer[rxSize];
   	int  	  RxBufferIndex;
   	int  	  RxLength_CAN;        
    char      hexaStr[6];
    	char temp1[5];
    int asd;	
    byte      didval[4098];

    // Variables for Requests
	int 	  DirectTxDataLen  = 0;
   	int   	  CurrentDiagServ  = 0;
	int		  SId              = 0;
   	float 	  RespTime         = 0.0;

    // Variables for Requests
    int transmitSeqNum = 0;
    long transmintRemainBytes = 0;
    dword glbHandler;
    char reqCharBuffer[1024];
    byte fileWriteBuffer[4096];

    //Constants for Diag Switch
    const int TESTER_PRESENT_ON = 0;
    const int TESTER_PRESENT_OFF= 1;
	const int DIS_NOR_MSG_TX 	= 2;
	const int EN_NOR_MSG_TX		= 3;
	const int ECU_ID			= 4;
	const int ECU_DEV_ST    	= 5;
	const int READ_DTC_BY_ST    = 6;
	const int READ_DTC_PASS     = 13;
	const int CLEAR_DTC			= 7;
	const int RD_CAMERA_LEFT    = 8;
	const int RD_CAMERA_RIGHT   = 9;
	const int RD_SW_VER         = 10;
	const int TEST				= 11;
	const int DIRECT_RQ			= 12;
	const int RD_SERIAL_NR      = 14;
	const int RESET             = 15;
	const int START_IR_TEST     = 16;
	const int STOP_IR_TEST      = 17;
	const int START_IMG_TEST    = 18;
	const int STOP_IMG_TEST     = 19;
	const int GET_SYS_RUNTIME	= 20;
	const int RESET_RUNTIME		= 21;
	const int SHOW_ENG_INFO		= 22;
	const int ENV_DATA			= 23;
	const int RD_CAN_SIG		= 24;
	const int RD_TEMP    		= 25;
	const int RD_CALIB_DATA     = 26;
	const int RD_ECU_ST			= 27;
	const int RD_TEMP_PROF		= 28;
    const int SKIP_CALIB		= 29;
	const int CALIB_SHIFT_UP	= 30;
	const int CALIB_SHIFT_DOWN	= 31;
	const int CALIB_SHIFT_LEFT	= 32;
	const int CALIB_SHIFT_RIGHT = 33;
	const int CALIB_DATA_SAVE   = 34;
	const int RD_MAX_CALIB_DATA = 35;
	const int CALIB_AUTO        = 36;
	const int CALIB_DATA_DEL    = 37;
	const int READ_HIST_DTC    =  38;
	const int CLEAR_HIST_DTC	= 39;
	const int HIST_ENV_DATA		= 40;
	const int START_CAM_ON		= 41;
	const int START_CAM_OFF		= 42;
	const int RQ_RES_CALIB_AUTO	= 43;
	const int RQ_RES_SELFTEST	= 44;
	const int RQ_RES_CHECKSUM	= 45;
	const int DIAG_SESSION_ON	= 46;
    const int READ_HIST_DTC_BY_ST    = 47;
    const int FINGERPRINT       = 48;
    const int PROGDATE          = 49;
    const int SEEDNKEYREQUEST   = 50;
    const int SEEDNKEYFBLREQUEST     =51;
    const int SEEDNKEYRESP          = 52; 
    const int SEEDNKEYJLREOLREQUEST  =53;
  const int SEEDNKEYJLRRESP        =54;
  const int SEEDNKEYRBEOLREQUEST = 55;//M.I..
  const int SEEDNKEYFBLDYNAMICREQUEST = 56;
  const int SEEDNKEYJLRDYNAMICREQUEST = 57;
  const int SEEDNKEYJLRREQUEST    =58;  
  const int SEEDNKEYRBEOLRESP = 59;
  const int ACT_PLANT_MODE_1       =60;
  const int ACT_PLANT_MODE_2       =61;  
   // const int SEEDRBEOLREQUEST   = 52; it will be implemented after Release X055
    const int SEEDNKEYREPROGREQUEST = 59;
    
    const int SEEDNKEYRBOLREQUESTWRITEKEY = 81;//M.I.
    const int P_MODE_ACT_P1 = 82;
    const int P_MODE_ACT_P2 = 83;

    const int  READ_EWB_ACT =94;
    const int  READ_DEACT_FUNC =55;
    const int  PRE_WRITE =56;
    const int  DEACT_FUNC_FLA =57;
    const int  DEACT_FUNC_CCP =58;
    const int  DEACT_FUNC_VZE =59;
    const int  ACT_EWB_VZE =60;
    const int  ACT_EWB_VZF =61;
    const int  ACT_EWB_EHR =62;
    const int  ACT_EWB_FLA =63;
    const int  ACT_EWB_MOD =64;
    const int  ACT_EWB_HCA =65;
    const int  ACT_EWBs = 79; //MI 

    const int  READ_MASK_FAULT_CLASS =66; 
    const int  WRITE_MASK_FAULT_CLASS =67; 
    const int  READ_MASK_ERR_RCTN =68; 
    const int  WRITE_MASK_ERR_RCTN =69; 

    const int  READ_BAP_PERS =70; 
    const int  WRITE_BAP_PERS =71; 

    const int  READ_V_THRESHOLD_MAINBEAM_ON =72; 
    const int  WRITE_V_THRESHOLD_MAINBEAM_ON =73; 
    const int  READ_V_THRESHOLD_MAINBEAM_OFF =74; 
    const int  WRITE_V_THRESHOLD_MAINBEAM_OFF =75; 

    const int MINICODEREQUEST = 76;
    const int PRE_WRITE_MINICODE = 77;
    const int SEEDNKEYREPROGREQUESTWRITEKEY = 78;
   
    const int SEEDNKEYREQUESTUNLOCKONE = 84;
    const int SEEDNKEYREQUESTUNLOCKTWO = 85;
    const int DUMPEEPROMSEQ = 86;


     long copiedBytes ;

//Anpassung Identifiers  all starting with 0x05
const int EWB_VZE_ID=0x32;
const int EWB_VZF_ID=0x33;
const int EWB_EHR_ID=0x34;
const int EWB_HCA_ID=0x35;
const int EWB_MOD_ID=0x36;
const int EWB_FLA_ID=0x37;
const int DEACT_CCP_ID= 0x30;
const int DEACT_FLA_ID= 0x19;
const int DEACT_VZE_ID= 0x18;
const int MASK_FAULT_CLASS_ID= 0x3C;
const int MASK_ERR_RCTN_ID= 0x3B;
const int BAP_PERS_ID= 0x44;

//Anpassung Identifiers  all starting with 0x3B
const int V_THRESHOLD_MAINBEAM_OFF_ID= 0x23;
const int V_THRESHOLD_MAINBEAM_ON_ID= 0x24;

//Anpassung Identifiers  all starting with 0x09 //MI
const int EWBs_ID=0x02; //MI


    //Stringbuffer
    char 	  Stringbuffer[4098];
   	char	  StringAux[4098];	


    //read dtc variables
   	dword 	  errorDTC[256];
   	dword 	  errorStatus[256]; 
   	int  	  CurrentDTC = 0;
   	int  	  NrOfReadDTC ;   
	
	dword 	  errorHistDTC[256];
   	byte 	  errorHistStatus[256]; 
   	int  	  CurrentHistDTC = 0;
   	int  	  NrOfHistDTC;  
   	int  	  NrOfReadHistDTC;   

  
	// Tester Present Handling
   	msTimer   TesterPresentTimer;
   	const int TesterPresentTime = 1000;
   	const int FirstTesterPresentTime = 20;
  	   
   message   DIAG_Phy_Req_CAN msgDiagRequest = {
   				dword(0) = 0xffffffff,
   				dword(4) = 0xffffffff}; 

   
    message    DIAG_Function_Req ReqDiagMsgGlobal = {
   				dword(0) = 0xffffffff,
   				dword(4) = 0xffffffff}; 
   	   
   	mstimer   TesterPresentTimeOutTimer;
   	const int TesterPresentTimeOutTime = 4000;
  	 
   	int 	  DiagActive = 0;       
  
  //  msTimer   secur;
    
    msTimer   UpdateRuntime;
	const int UpdateCycle = 1000;
  int dynamicKeyLen;



     //to doors-automate-tests

    int readTimeValue;          //elapsed time counter (ms)
    char DTCValue [255];        //internal container for error codes  
    msTimer readDtcTimer;       //for repeat the reading process
    int CNTR_VALUE=200;         //default timer resolution (ms)
    char readString[255];       //to store the read DTC command
    byte readRequest[255];      //to store the read DTC command
    int requestSize;            //
    char msString[30];          //for the information string
    byte ErrValue [4098];       //the representation of RxDataBuffer
    char ErrString [2048];      //the characteric representation of RxDataBuffer
    char tempString [2048];     //for internal use

    

	 
    //Seed&key
    msTimer     FingerPrint;
    msTimer     ProgDate;
    msTimer     SeednKeyReq;
    msTimer     MinicodeReq;
    msTimer     ActPMode;
    msTimer sectimer1;
    msTimer sectimer2;
    msTimer Act_plant_mode;
    // RBEOL Security Unlock
    byte sendKey[1024];
    char seedList[600][600];
    char keyList[2048][2048];
    char seedListJLR[600][600];
    char keyListJLR[2048][2048];
    int DynamicFlag = 0;
    char DynamicKey[2052];
    int securityType = SEEDNKEYREQUEST;
    int securityTypeJLR = SEEDNKEYJLRREQUEST;
    int bin, c_index; 
    int challenge[64], position_one[24], position_two[24];
    byte input[8];
    int init_array[24] = {1,0,0,1,0,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1};
    byte resultarray[6] = {0x27,0,0,0,0,0};
    byte resultarra[5] = {0x27,0,0,0,0};
    byte securityresponse[128];
    
    int k=0;
    int j;
    //end
    byte Fingerprint[9]={0x2e,0xf1,0x98,0x01,0x02,0x03,0x04,0x05,0x06};
    byte ProgrammingDate[6]={0x2e,0xf1,0x99,0x19,0x01,0x09};
    byte SeednKeyRequest[2]={0x27,0x03};
    byte SeednKeyFBLRequest[2] = {0x27,0x61};
    byte SeednKeyJLREOLRequest[2] = {0x27,0x01};
    byte SeednKeyReprogRequest[2]={0x27,0x10};
    byte SeednKeyRBEOLRequest[2]={0x27,0x61}; //M.I.
    byte MinicodeRequest[2]= {0x27,0x21};
    dword seedReprogValue,  keyLowReprogValue, keyUpperReprogValue;
    dword keyReprogValue;
    dword authKey;
    byte     pufferEOL[10]={0,0,0,0,0,0,0,0,0,0};
    dword keyMaxReprogValue = 0xFFFFFFFF; 
    byte SeednKeyRequestOne[2]={0x27,0x01};
    byte SeednKeyRequestTwo[2]={0x27,0x02};
     byte SeednKeyRequestFbl[2]={0x27,0x01};
    byte AppKeyConst[4] = {0x52, 0x7F, 0x63, 0x74};
    byte sec_key[4], seed_1[4], seed_2[4], sec_key1[4], sec_key2[4];
    int temp_sec_key;
    byte SecurityBuffer[1];
    byte Serialnumextract[3]={0x22,0xf1,0x8c};
    byte returnKey[4], seedArray[4], notseedArray[4];
    dword V[2];
    dword num_rounds = 2, sum = 0, i = 0; 
    dword v0,v1;
    dword delta = 0x9E3779B9;

    byte whichlogin=0;
    dword result=0; 
        long seed, keyy;
    const long  MASK = 0x43424335;
    
        
}


on envVar EnvSendBuffer_2     
{
     if ( getValue (this) )
   {
      DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
      StartDiagService( DIRECT_RQ );
   }
}

void StartDiagService( byte ServiceId )
{ 
    int i;
    byte buffer[1];
    long switchEWBsValue = 0x00;

   CurrentDiagServ = ServiceId;
    
         putValue (EnvReqStatus_CAN_1, "...");
         putValue (EnvRespTime_CAN_1, 0.0);
    

   //Diag Switch
   switch ( ServiceId )
   {
        case TESTER_PRESENT_OFF:
            //msgDiagRequest.byte(0) = 0x02;
            //msgDiagRequest.byte(1) = 0x10;
            //msgDiagRequest.byte(2) = 0x01;   //Default session

            cancelTimer (TesterPresentTimer);
            //ReqDiagMsgGlobal.CAN = SEND_CAN;        

          //output (msgDiagRequest);
      
          //  putValue (EnvReqStatus_CAN_1, "OK");
        break;

        case TESTER_PRESENT_ON:
            //msgDiagRequest.byte(0) = 0x02;
            //msgDiagRequest.byte(1) = 0x10;
            //msgDiagRequest.byte(2) = 0x03;	//Extended diag session
            


            cancelTimer (TesterPresentTimer);
            setTimer (TesterPresentTimer, FirstTesterPresentTime);

            //msgDiagRequest.CAN = SEND_CAN;        

          //output (msgDiagRequest);
      
            //putValue (EnvReqStatus_CAN_1, "OK");

        break;

      
      case DIAG_SESSION_ON:
           TxDataBuffer[0] = 0x10;
            TxDataBuffer[1] = 0x03;	//Extended diag session
            
            TxLength = 2;  
            TransmitTxBuffer();
            
      break;
      
      
      case READ_DTC_BY_ST: 

         TxDataBuffer[0] = 0x19;
         TxDataBuffer[1] = 0x02;
         TxDataBuffer[2] = 0x09;  
       
         TxLength = 3; 
         TransmitTxBuffer();
         

      break;      


      case READ_DTC_PASS:

         TxDataBuffer[0] = 0x19;
         TxDataBuffer[1] = 0x02;
         TxDataBuffer[2] = 0x08;  
    
         TxLength = 3;  
         TransmitTxBuffer();
      break;



      case CLEAR_DTC: 
         TxDataBuffer[0] = 0x14;
         TxDataBuffer[1] = 0xFF;  
         TxDataBuffer[2] = 0xFF;
         TxDataBuffer[3] = 0xFF;   

         TxLength = 4;
         TransmitTxBuffer();
      break;


      case DIRECT_RQ: 
         TxLength = DirectTxDataLen;
         TransmitTxBuffer();
      break;

      case READ_HIST_DTC_BY_ST: 
         TxDataBuffer[0] = 0x19;
         TxDataBuffer[1] = 0x02;
         TxDataBuffer[2] = 0x08;  //passive
 //        TxDataBuffer[2] = 0x10;  //untested
   //    TxDataBuffer[3] = 0x00;
         
         TxLength = 3;  //4
         TransmitTxBuffer();
      break;  

      case P_MODE_ACT_P1:
      
        //1) Send part1 request "80 FA 31 03 30 05"
        TxDataBuffer[0] = 0x80;
        TxDataBuffer[1] = 0xFA;
        TxDataBuffer[2] = 0x31;  
        TxDataBuffer[3] = 0x03;  
        TxDataBuffer[4] = 0x30;  
        TxDataBuffer[5] = 0x05;  
       
        TxLength = 6; 
        TransmitTxBuffer();
        
      break;  
      
      case P_MODE_ACT_P2:
      
        //2) Send part2 request "80 FA 11 08"
        TxDataBuffer[0] = 0x80;
        TxDataBuffer[1] = 0xFA;
        TxDataBuffer[2] = 0x11;  
        TxDataBuffer[3] = 0x08;  
        
        TxLength = 4; 
        TransmitTxBuffer();
        break; 
    // RBEOL Security unlock
    case ACT_PLANT_MODE_1:
          TxDataBuffer[0] = 0x80;
          TxDataBuffer[1] = 0xB5;
          TxDataBuffer[2] = 0x28;  
          TxDataBuffer[3] = 0xC3;
          TxDataBuffer[4] = 0x1E;  
          TxDataBuffer[5] = 0xFD;          
 
          TxLength = 6;  
          TransmitTxBuffer();
        break;

      case ACT_PLANT_MODE_2:
          TxDataBuffer[0] = 0x80;
          TxDataBuffer[1] = 0xB5;
          TxDataBuffer[2] = 0x7C;  
          TxDataBuffer[3] = 0x68;

          TxLength = 4;  
          TransmitTxBuffer();
        break;          
    
    case SEEDNKEYJLRREQUEST: 
         
          putValue(EnvTxData_2,SeednKeyJLREOLRequest);
          DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
          TxLength = DirectTxDataLen;
          TransmitTxBuffer();
          break; 
      
      case SEEDNKEYJLREOLREQUEST: 
         
          putValue(EnvTxData_2,SeednKeyJLREOLRequest);
          DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
          TxLength = DirectTxDataLen;
          TransmitTxBuffer();
          break; 
      
      case SEEDNKEYFBLREQUEST: 
         
          putValue(EnvTxData_2,SeednKeyFBLRequest);
          DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
          TxLength = DirectTxDataLen;
          TransmitTxBuffer();
          break; 
        
      case SEEDNKEYFBLDYNAMICREQUEST:
        
          putValue(EnvTxData_2,SeednKeyFBLRequest);
          DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
          TxLength = DirectTxDataLen;
          TransmitTxBuffer();
          break;
        
      case SEEDNKEYJLRDYNAMICREQUEST:
        
          putValue(EnvTxData_2,SeednKeyJLREOLRequest);
          DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
          TxLength = DirectTxDataLen;
          TransmitTxBuffer();
          break;

    case SEEDNKEYJLRRESP: 
        
       putValue(EnvTxData_2,sendKey);
       DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
       TransmitTxBuffer();
           
    break;   

    case FINGERPRINT: 
         
        putValue(EnvTxData_2,Fingerprint);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
        setTimer(ProgDate,200);
    break; 

    
    case PROGDATE: 
    
        putValue(EnvTxData_2,ProgrammingDate);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
         switch ( whichlogin)
         {
             case 1:
             case 2:
                setTimer(SeednKeyReq,200);
             break;
             case 5:
             case 6:
                setTimer ( MinicodeReq, 200);
             break;
        }

    break; 

    case SEEDNKEYREQUEST: 
         
        putValue(EnvTxData_2,SeednKeyRequest);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
       
    break; 

    case SEEDNKEYREPROGREQUEST: 
         
        putValue(EnvTxData_2,SeednKeyReprogRequest);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
      
    break;

    case SEEDNKEYRBEOLREQUEST: 
         
        putValue(EnvTxData_2,SeednKeyRBEOLRequest);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
      
    break;

   
    
    case SEEDNKEYREPROGREQUESTWRITEKEY: 
         
        putValue(EnvTxData_2,SeednKeyReprogRequest);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
      
    break; 


    case SEEDNKEYREQUESTUNLOCKONE: 
             
        putValue(EnvTxData_2,SeednKeyRequestOne);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
      
    break;
            
//  case SERIALNUMBEREXTRACT:   
//putValue(EnvTxData_2,Serialnumextract);
//       DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
//      TxLength = DirectTxDataLen;
//        TransmitTxBuffer();
//	 break;
	
	//    case SEEDNKEYREQUESTUNLOCKFBL: 
//                
//        putValue(EnvTxData_2,Seednkeyrequestunlockfbl);
//        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
//        TxLength = DirectTxDataLen;
//        TransmitTxBuffer();
     

    case SEEDNKEYREQUESTUNLOCKTWO: 
                
        putValue(EnvTxData_2,SeednKeyRequestFbl);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
      
    break;
  
     case  MINICODEREQUEST : 
        if (whichlogin == 5)   // Plant
        {
            MinicodeRequest[1]= 0x03; 
      
        }
        else 
        {
             MinicodeRequest[1]= 0x21;  // Development
        }
        putValue(EnvTxData_2,MinicodeRequest);
        DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
        TxLength = DirectTxDataLen;
        TransmitTxBuffer();
         
     break; 


     //  case SEEDRBEOLREQUEST: 
         
       //    TxDataBuffer[0] = 0x23;
       //    TxDataBuffer[1] = 0x88;
       //    TxDataBuffer[2] = 0x01;  
       //    TxDataBuffer[3] = 0x00;  
       //    TxDataBuffer[4] = 0x00;
         
       //  TxLength = 5;  //4
      //   TransmitTxBuffer();
        
    //  break; 
     
     case SEEDNKEYRESP: 
            putValue(EnvTxData_2,resultarray);
            DirectTxDataLen = getValue( EnvTxData_2, TxDataBuffer );
            TxLength = DirectTxDataLen;
            TransmitTxBuffer();
           
    break; 

    case  READ_EWB_ACT:

         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] = 0x05;
         TxDataBuffer[2] = EWB_VZE_ID; 
         TxDataBuffer[3] = 0x05;
         TxDataBuffer[4] = EWB_VZF_ID; 
         TxDataBuffer[5] = 0x05;
         TxDataBuffer[6] = EWB_EHR_ID;
         TxDataBuffer[7] = 0x05;
         TxDataBuffer[8] = EWB_HCA_ID;
         TxDataBuffer[9] = 0x05;
         TxDataBuffer[10] = EWB_MOD_ID;
         TxDataBuffer[11] = 0x05;
         TxDataBuffer[12] = EWB_FLA_ID;
         TxDataBuffer[13] = 0x09; //MI
         TxDataBuffer[14] = EWBs_ID; //MI
    
         TxLength = 15;  
         TransmitTxBuffer();
         break; 
   /*
   case  READ_DEACT_FUNC:  
         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = DEACT_FLA_ID; 
         TxDataBuffer[3] =  0x05;
         TxDataBuffer[4] = DEACT_VZE_ID; 
         TxDataBuffer[5] = 0x05;
         TxDataBuffer[6] = DEACT_CCP_ID;
         TxLength = 7;  
         TransmitTxBuffer();
  break;




   case  PRE_WRITE : 
        SetControlForeColor("Anpassungen", "PrepareWriteControl", MakeRGB(0,192,0));
            
        putvalue(EnvDirectSend_2,"104F");
     
        putvalue(EnvLogIn106A3,1);
        // Set tester present 
        putvalue(EnvTesterPresentOnOff_2, 1);
        break;
   */

      case  PRE_WRITE_MINICODE : 
        SetControlForeColor("Anpassungen", "PrepareWriteControlMinicode", MakeRGB(0,192,0));
            
        putvalue(EnvDirectSend_2,"104F");
     
        putvalue(EnvMinicode_Dev,1);
        // Set tester present 
        putvalue(EnvTesterPresentOnOff_2, 1);
      
   break;
            
   /*
   case  DEACT_FUNC_FLA:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = DEACT_FLA_ID; 
         TxDataBuffer[3] = getValue(EnvDeactivate_FLA_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;

   case  DEACT_FUNC_VZE:
         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = DEACT_VZE_ID; 
         TxDataBuffer[3] = getValue(EnvDeactivate_VZE_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;

   case  DEACT_FUNC_CCP:
         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = DEACT_CCP_ID;
         TxDataBuffer[3] = getValue(EnvDeactivate_CCP_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
        
   break;
    
    case  ACT_EWB_VZE:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = EWB_VZE_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_EWB_VZE_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;

case  ACT_EWB_VZF:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = EWB_VZF_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_EWB_VZF_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;
    */        

    case  ACT_EWB_EHR:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = EWB_EHR_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_EWB_EHR_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;
    case  ACT_EWB_FLA:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = EWB_FLA_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_EWB_FLA_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;
    case  ACT_EWB_MOD:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = EWB_MOD_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_EWB_MOD_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;
    case  ACT_EWB_HCA:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = EWB_HCA_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_EWB_HCA_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
    break;

    //MI
    case  ACT_EWBs:

         if (getValue(EnvActivate_EWBs_Value) == 1)
         {
            switchEWBsValue = 0xFF;
         }
         else
         {
            switchEWBsValue = 0x00;
         }   

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x09;
         TxDataBuffer[2] = EWBs_ID; 
         TxDataBuffer[3] = switchEWBsValue; 
         TxLength= 4; 
         TransmitTxBuffer();
    break;

     case  READ_MASK_FAULT_CLASS:
 
         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = MASK_FAULT_CLASS_ID; 
         TxLength = 3;  
         TransmitTxBuffer();
        
    break;
    case  WRITE_MASK_FAULT_CLASS:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] = 0x05;
         TxDataBuffer[2] = MASK_FAULT_CLASS_ID; 
       
         i = getValue(EnvMaskFaultClass1_Value, buffer); 
        TxDataBuffer[3] = buffer[0];
        i = getValue(EnvMaskFaultClass2_Value, buffer);
        TxDataBuffer[4] = buffer[0]; 
         i = getValue(EnvMaskFaultClass3_Value, buffer); 
        TxDataBuffer[5] = buffer[0];
        i= getValue(EnvMaskFaultClass4_Value, buffer); 
        TxDataBuffer[6] = buffer[0];
        TxLength = 7;  
        TransmitTxBuffer();
     break;

     
       case   READ_MASK_ERR_RCTN:
 
         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = MASK_ERR_RCTN_ID; 
         TxLength = 3;  
         TransmitTxBuffer();
        
    break;
    case  WRITE_MASK_ERR_RCTN :

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = MASK_ERR_RCTN_ID; 
         i = getValue(EnvMaskErrorReactDev_Value, buffer); 
        TxDataBuffer[3] = buffer[0];
          TxLength= 4; 
         TransmitTxBuffer();
    break;

    case  WRITE_BAP_PERS:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = BAP_PERS_ID; 
         TxDataBuffer[3] = getValue(EnvActivate_BAP_Pers_Value); 
         TxLength= 4; 
         TransmitTxBuffer();
     break;

      case  READ_BAP_PERS:
 
         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] =  0x05;
         TxDataBuffer[2] = BAP_PERS_ID;  
         TxLength = 3;  
         TransmitTxBuffer();
        
    break;
    case  WRITE_V_THRESHOLD_MAINBEAM_ON:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x3B;
         TxDataBuffer[2] = V_THRESHOLD_MAINBEAM_ON_ID; 
         result=getValue(EnvV_Schwelle_FLA_ein_Value);
         TxDataBuffer[3] =  (result >>8 );
         TxDataBuffer[4] =  result & 0xff;
         TxLength= 5; 
         TransmitTxBuffer();
     break;

      case READ_V_THRESHOLD_MAINBEAM_ON:
 
         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] =  0x3B;
         TxDataBuffer[2] = V_THRESHOLD_MAINBEAM_ON_ID;
         TxLength = 3;  
         TransmitTxBuffer();
        
    break;
     case  WRITE_V_THRESHOLD_MAINBEAM_OFF:

         TxDataBuffer[0] = 0x2E;
         TxDataBuffer[1] =  0x3B;
         TxDataBuffer[2] = V_THRESHOLD_MAINBEAM_OFF_ID; 
         result=getValue(EnvV_Schwelle_FLA_aus_Value);
         TxDataBuffer[3] =  (result >>8 );
         TxDataBuffer[4] =  result & 0xff;
         TxLength= 5; 
         TransmitTxBuffer();
     break;

      case READ_V_THRESHOLD_MAINBEAM_OFF:
 
         TxDataBuffer[0] = 0x22;
         TxDataBuffer[1] =  0x3B;
         TxDataBuffer[2] = V_THRESHOLD_MAINBEAM_OFF_ID;
         TxLength = 3;  
         TransmitTxBuffer();
        
    break;
}


}   
long str2byte(char src[], byte dest[])
{
  int i;
  byte temp;
  long bufferSize;
  long length;
  length = strlen(src);
  length = length/2;
  bufferSize = elcount(RxDataBuffer);
  //write(" CAN length %d",length);
  for(i=0;i<length;i++){
    temp = src[i<<1];
    if(temp <= '9') temp -= '0';
    else if (temp <= 'Z' ) temp = temp +10 - 'A';
    else temp = temp + 10 - 'a';
    dest[i] = temp << 4;
    temp = src[(i<<1)+1];
    if(temp <= '9') temp -= '0';
    else if (temp <= 'Z' ) temp = temp +10 - 'A';
    else temp = temp + 10 - 'a';
    dest[i] += temp;
    //write(" CAN temp %d",temp);
  }
  return length;
}
long str2byte1(char src[], byte dest[])
{
  int i;
  byte temp;
  long bufferSize;
  long length;
  length = strlen(src);
  length = length/2;
  bufferSize = elcount(RxDataBuffer);
  //write(" CAN length %d",length);
  for(i=0;i<length;i++){
    temp = src[i<<1];
    if(temp <= '9') temp -= '0';
    else if (temp <= 'Z' ) temp = temp +10 - 'A';
    else temp = temp + 10 - 'a';
    dest[i] = temp << 4;
    temp = src[(i<<1)+1];
    if(temp <= '9') temp -= '0';
    else if (temp <= 'Z' ) temp = temp +10 - 'A';
    else temp = temp + 10 - 'a';
    dest[i] += temp;
    //write(" CAN temp %d",temp);
  }
  return length;
}

void TransmitTxBuffer (void)
{ 	


	// OSEK TP supports up to 4095 bytes per transmission
	if (TxLength >= 4096)
		TxLength = 4095;
	

	//Fault Injections
	if (getvalue(EnvCFDoubleDelay)!=0)
		{
			OSEKTL_FI_DoubleCF (getvalue(EnvCFNr), getvalue(EnvCFDoubleDelay));
			write ("FI Fault Double CF"); 
		}


	if (getvalue(EnvCFDrop)==1)
	{
			OSEKTL_FI_DropCF(getvalue(EnvCFNr));
			write ("FI Fault Drop CF Nr %i",getvalue(EnvCFNr));
	}

	
 

	if (getvalue(EnvCFDelay)!=0)
	{
		OSEKTL_FI_DelayCF(getvalue(EnvCFNr),getvalue(EnvCFDelay));
	}
    
	// Empty Value for EnvRxData to avoid showing old values

    	putValue( EnvRxData_CAN_1,emptyString,0);
        putValue(EnvRxDataLen_CAN_1,0);
        putvalue (EnvDirectReceive_1,""); // delete old value from receive 
  


	    OSEKTL_DataReq( TxDataBuffer, TxLength ); 
		
		putValue( EnvTxData_2, TxDataBuffer, TxLength );



	SId = TxDataBuffer[0];

}

OSEKTL_DataCon(long status)
{
	if (status != 0) 
	{
		RespTime = ( (float) timeNow() * (-1.0) );	
       	
	}
	else
	{
		write("Tx error, status is %d", status);
	}
}

OSEKTL_DataInd( long rxCount )
{
   
    int i;
   
   
	/* Get received data */
   
	OSEKTL_GetRxData( RxDataBuffer, elcount(RxDataBuffer) );
 
    if (RxDataBuffer[0]!=127) // response different than Response Pending
	    {  
              TxLength=0;
        }
     //to save the RxDataBuffer into ErrValue[] for EnvSetReadDTC
    for (i=0;i<rxCount;i++)
        {
            ErrValue[i]=RxDataBuffer[i];
        }
    //Convert binary ErrValue[] to string ErrString[]
    FillErrString(rxCount);

    RespTime += timeNow();
    RespTime /= 100;

    if (RxDataBuffer[0]!=127)
    {
    //      write("DATA Ind for MPC");		//debugging
            putValue( EnvRespTime_CAN_1, RespTime);
            putValue( EnvRxData_CAN_1, RxDataBuffer, rxCount );
	        putValue( EnvRxDataLen_CAN_1, rxCount );
            getvalue(EnvRxData_CAN_1,TxDataBuffer);
//            for (i=0;i<getvalue(EnvRxData_CAN_1,TxDataBuffer);i++)
//            {
//                write(" CAN %x",TxDataBuffer[i]);
//            }
        
    
        EvaluateRxData( rxCount );
    }
else {
  putValue( EnvRespTime_CAN_1, RespTime);
            putValue( EnvRxData_CAN_1, RxDataBuffer, rxCount );
	        putValue( EnvRxDataLen_CAN_1, rxCount );
            getvalue(EnvRxData_CAN_1,TxDataBuffer);
EvaluateResponse();
}
}

OSEKTL_ErrorInd(int error)
{
long FI_ID ;

    if (!OSEKTL_GetRxId())
    {	
    switch( error )
	{
		case 1: 	
			write(" Error (%d): Timeout while waiting for CF",  error );
			putValue( EnvReqStatus_CAN_1, "Timeout while waiting for CF" );
			putValue( EnvRespTime_CAN_1, OSEKTL_GetTimeoutCF() );	
		break;

		case 2: 	
			write(" Error (%d): Timeout while waiting for FC",  error ); 
			putValue( EnvReqStatus_CAN_1, "Timeout while waiting for FC" );
			putValue( EnvRespTime_CAN_1, OSEKTL_GetTimeoutFC() );			
		break;

		case 3:
		 	write(" Error (%d): Wrong Sequence Number",  error );
			putValue( EnvReqStatus_CAN_1, "Wrong Sequence Number" );
		break;

		case 4:
		 	write(" Error (%d): TP_DLL busy",  error ); 
			putValue( EnvReqStatus_CAN_1, "TP_DLL busy" );
		break;

		case 5:
		 	write(" Error (%d): Unexpected PDU",  error ); 
			putValue( EnvReqStatus_CAN_1, "Unexpected PDU" );
		break;

		case 6:
		 	write(" Error (%d): Timeout while trying to send a CAN frame",  error );
			putValue( EnvReqStatus_CAN_1, "Timeout while trying to send a CAN frame" );
		break;

		case 7:
		 	write(" Error (%d): Too many FCs: WFT Overrun",  error ); 
			putValue( EnvReqStatus_CAN_1, "To many flow control: WFT Overrun" );
		break;
		
		case 8:
			write(" Error (%d):Receiver buffer overflow",  error ); 
			putValue( EnvReqStatus_CAN_1, "Receiver buffer overflow" );
		break;

		case 9:
			write(" Error (%d): Wrong parameter",  error ); 
			putValue( EnvReqStatus_CAN_1, "Wrong parameter" );
		break;
		
		default: 	
			write(" Error (%d): unknown error",  error ); 
			putValue( EnvReqStatus_CAN_1, "unknown error" );
		break;
	}
    }

}

OSEKTL_FI_PreSend( word msgDlc[], byte data[])
{  
	int Correct_CFValue;


	if( OSEKTL_FI_IsFC())
	{
		if (getvalue(EnvFC_FalsePCIon))
		{
		 data[0]= getvalue(EnvFC_PCIValue);
		}
	}
	else
	{  //CFs False PCI
		switch (getvalue(EnvCFNr))
			{
					case 1:
						Correct_CFValue=0x21;
					break;
					case 2:
						Correct_CFValue=0x22;
					break;
					case 3:
						Correct_CFValue=0x23;
					break;
					case 4:
						Correct_CFValue=0x24;
					break;
					case 5:
						Correct_CFValue=0x25;
					break;
					case 6:
						Correct_CFValue=0x26;
					break;
					case 7:
						Correct_CFValue=0x27;
					break;
					case 8:
						Correct_CFValue=0x28;
					break;
					case 9:
						Correct_CFValue=0x29;
					break;

			}
		if (getvalue(EnvCF_FalsePCIon)&& data[0]==Correct_CFValue) 
		{	 write ("false PCI in CF  ");
 		data[0]= getvalue(EnvCF_PCIValue);
		}

  
 
	}





	
}

OSEKTL_FirstFrameIndication( long source, long target, long length) 
{ 


// Do not react to Requests from another tester (VAS-Tester...)
    if ( TxLength ==0 )
    {	OSEKTL_SetUseFC(0);
    	//write ("Request was sent from other tester, Canoe Tester is not sending  FC");

    }

    else
    { 
           	OSEKTL_SetUseFC( GetValue( EnvUseFC ) );
   //     	write ("Request was sent from CANOE, sending  FC, for TX length = %i ",TxLength);
    }

//Fault Injections 
	if (getvalue(EnvFCDoubleOn)==1)
		{	OSEKTL_FI_DoubleFC (getvalue(EnvFCNr));
			write ("FI-Double FC  Nr %d",getvalue(EnvFCNr));
		}


}

void EvaluateRxData( int Length )
{
   int      DtcNr;  
   int      i, j;
   dword    k;
   dword    auxRT;
   float    convert_rad_grad = 57.295779513082320876798154814105;
   char     Seed[1024];
   Byte     Seed_2[4];
   Byte     Const_1[4];
   Byte     key_1[4];
   Byte     key_2[4];
   Byte     key_0[4];
   dword    resultarray_32[6]={0,0,0,0,0,0};
   byte     puffer[10]={0,0,0,0,0,0,0,0,0,0};

   dword    REP_RBA_CBB_AKEY_VALUE  = 0x41916668;
   dword    REP_RBA_CBB_BKEY_VALUE = 0x12774118;
   dword    REP_RBA_CBB_CKEY_VALUE = 0x86905668;
   dword    REP_RBA_CBB_DKEY_VALUE = 0x10371229;


   dword    WERK_RBA_CBB_AKEY_VALUE  = 0x52917768;  //Minicode 2703/2704
   dword    WERK_RBA_CBB_BKEY_VALUE = 0x12774118;   // Porsche
   dword    WERK_RBA_CBB_CKEY_VALUE = 0x86905668;  // Porsche
   dword    WERK_RBA_CBB_DKEY_VALUE = 0x21482338;  // Porsche

   dword    DEV_RBA_CBB_AKEY_VALUE  = 0x46947376; //Minicode 2721/2722
   dword    DEV_RBA_CBB_BKEY_VALUE = 0x12774118;  // Porsche
   dword    DEV_RBA_CBB_CKEY_VALUE = 0x86905668;  // Porsche
   dword    DEV_RBA_CBB_DKEY_VALUE = 0x45982573;   // Porsche

   dword    RBEOLPin = 0x42444441; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
   dword    PMARequest = 0x80FA1108; //Plant mode activation part request
   
   byte Xor[4]={0xE6,0xF7,0xC0,0xAA}; //XOR Array
   byte Cal[4]={0,0,0,0}; //Calculation Array

    dword    keytemp;
    char    buffer[50],tempbuffer[50];
    Byte    ByteValue[1];
    int     IdentifierId;
    int     IdentifierValue;
  
  //RBEOL security unlock
   byte     buffer2[128];
   byte securityRespBuffer[1100];
   char pufferStr[2200];
   char temp[5];
   char IMBuffer[4];
   int responseLen;
   int seedStartByte;
    
EvaluateResponse( );  


   switch ( CurrentDiagServ )  
   {
    case DUMPEEPROMSEQ:
      if(RxDataBuffer[0] == 0x75){
        transmitSeqNum = 1;
        snprintf(reqCharBuffer,elcount(reqCharBuffer),"36%.2x",transmitSeqNum);
        TxLength = str2byte(reqCharBuffer,TxDataBuffer);
        TransmitTxBuffer();
        glbHandler = OpenFileWrite ("eeprom.bin",3);
      }else if(RxDataBuffer[0] == 0x76){
        write("36 res length %d, bytes remain %d", Length, transmintRemainBytes);
        transmitSeqNum += 1;
        if(transmitSeqNum>0xff) transmitSeqNum = 0;
        transmintRemainBytes = transmintRemainBytes - (Length - 2);
        for(i=0;i<Length-2;i++){
          fileWriteBuffer[i] = RxDataBuffer[i+2];
        }
        fileWriteBinaryBlock(fileWriteBuffer, Length - 2, glbHandler);
        if(transmintRemainBytes>0){
          snprintf(reqCharBuffer,elcount(reqCharBuffer),"36%.2x",transmitSeqNum);
          TxLength = str2byte(reqCharBuffer,TxDataBuffer);
          TransmitTxBuffer();
        }
        else{
          fileClose(glbHandler);
          TxLength = str2byte("37",TxDataBuffer);
          TransmitTxBuffer();
        }
      }else{
        
      }
    break;
      
      case READ_DTC_BY_ST:  
      case READ_DTC_PASS: 
         if ( RxDataBuffer[0] == 0x59 )
         {
            RxBufferIndex  = 3;
            NrOfReadDTC    = (Length - 3)/4;  
            DtcNr        = 1; 
            
            putValue (EnvDtcInEmPresent , 0);
            for (i = 0; i < NrOfReadDTC; i++)
            {
                  errorDTC[DtcNr]      = (dword)RxDataBuffer[RxBufferIndex++] << 16;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++] << 8;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++]; 
 
                // Bescos new Function Look for a particular DTC in EM, Flag for found : EnvDtcInEmPresent
  
                snprintf (buffer, 49, "%06x", errorDTC[DtcNr]);
                getValue(EnvDtcLookForInEm,tempbuffer);
                if  ( strncmp(buffer,tempbuffer,strlen(tempbuffer))== 0)  //equal
                {
                    putValue (EnvDtcInEmPresent , 1);
                }

            // 	write(" buffer %s: tembuffer  %s ",  buffer,tempbuffer );
               errorStatus[DtcNr++] = RxDataBuffer[RxBufferIndex++];
			   
            }
            if ( (NrOfReadDTC == 0) )
            {
                   putValue (EnvReqStatus_CAN_1, "No DTCs");
            }else{
                   putValue (EnvReqStatus_CAN_1, "All DTCs received");
            }

               CurrentDTC = 1;
               ShowDTCs();
               
            
            }
    break; 




	case READ_HIST_DTC:  
         if ( RxDataBuffer[0] == 0x71 )
         {
            RxBufferIndex  = 2;
            NrOfHistDTC        = RxDataBuffer[RxBufferIndex++];
            NrOfReadHistDTC    = (Length - 3)/3;
            DtcNr        = 1; 
         
            for (i = 0; i < NrOfReadHistDTC; i++)
            {
               errorHistDTC[DtcNr]      = (dword)RxDataBuffer[RxBufferIndex++] << 8;
               errorHistDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++];
               errorHistStatus[DtcNr++] = RxDataBuffer[RxBufferIndex++];
	            }
         
         	EvaluateResponse();

            if ( (NrOfReadHistDTC == NrOfHistDTC) && (NrOfHistDTC) )
            {
               
                    putValue (EnvReqStatus_CAN_1, "All Historical DTCs received");
               
               CurrentHistDTC = 1;
            // ShowHistDTCs();
            }
            else if ( NrOfReadHistDTC != NrOfHistDTC )
            { 
                
                    putValue (EnvReqStatus_CAN_1, "Nr. of Hist DTCs != Data");
               CurrentHistDTC = 1;
            // ShowHistDTCs();
            }

            if ( (NrOfHistDTC == 0) && (NrOfReadHistDTC == NrOfHistDTC) )
            {
               
                    putValue (EnvReqStatus_CAN_1, "No Historical DTCs");
            }

         }
        
      break; 
      
            
        case SEEDNKEYJLRREQUEST: 
            getvalue(EnvRxData_CAN_1,buffer2);
            bin = 0x80;
            c_index=0;
            input[0] = buffer2[2];
            input[1] = buffer2[3];
            input[2] = buffer2[4];
            input[3] = 0xef ;
            input[4] = 0xad;
            input[5] = 0x9c;
            input[6] = 0xc9;
            input[7] = 0x08;
            write("in resp code ");
                        
            write("seed%x%x%x",buffer2[2],buffer2[3],buffer2[4]);
            for(i = 0; i < 24; i++)
            {
                position_one[i]=init_array[i];
            }

            for(i = 0; i < 8; i++)
            {
                for(j = 7; j >= 0; j--)
                {
                    challenge[c_index + j] = input[i] & bin;
                    if(challenge[c_index + j] > 0)
                    {
                        challenge[c_index + j] = 1;
                    }
                    bin = bin >> 1;
                }
                bin = 0x80;
                c_index+=8;
            }
            
            for(i = 0; i < 64; i++)
            {
                position_two[23] = challenge[i] ^ position_one[0];
                for(j = 0; j < 23; j++)
                {
                    position_two[j] = position_one[j+1];
                }
                for(j = 0; j < 24; j++)
                {
                    if(j == 3 || j == 5 || j == 12 || j == 15 || j == 20)
                    {
                        position_one[j] = position_two[j] ^ position_two[23];
                    }
                    else
                    {
                        position_one[j] = position_two[j];
                    }
                }        
            }
            
            resultarra[0] = 0x27;
            resultarra[1] = SeednKeyJLREOLRequest[1] + 1;
            resultarra[2] = (byte)((position_one[11] * 8 + position_one[10] * 4 + position_one[9] *2 + position_one[8]) * 16 + (position_one[7] * 8 + position_one[6] * 4 + position_one[5] *2 + position_one[4]));
            resultarra[3] = (byte)((position_one[15] * 8 + position_one[14] * 4 + position_one[13] *2 + position_one[12]) * 16 + (position_one[23] * 8 + position_one[22] * 4 + position_one[21] *2 + position_one[20]));
            resultarra[4] = (byte)((position_one[3] * 8 + position_one[2] * 4 + position_one[1] *2 + position_one[0]) * 16 + (position_one[19] * 8 + position_one[18] * 4 + position_one[17] *2 + position_one[16]));
            write(" key cal %x%x%x%x%x",resultarra[0],resultarra[1],resultarra[2],resultarra[3],resultarra[4]);
            StartDiagService( SEEDNKEYRBEOLRESP);
            break;

    case SEEDNKEYFBLREQUEST: 
        
        securityRespBuffer[0]='\0';
        responseLen = getvalue(EnvRxData_CAN_1,securityRespBuffer);        
        strncpy(pufferStr,"",elcount(pufferStr));
        strncpy(Seed,"",elcount(Seed));
            
        for(i=0;i<responseLen;i++)
        {
          ltoa(securityRespBuffer[i],IMBuffer,16);
          
          if( strlen( IMBuffer ) == 1 )
    			{
    				 IMBuffer[1] = IMBuffer[0];
             IMBuffer[0] = '0';
             strncat(pufferStr,IMBuffer,elcount(pufferStr));
    			}
    		  else
    			{
    				 strncat(pufferStr,IMBuffer,elcount(pufferStr));
    			}
          
        }		
		if(responseLen == 167)
		{
			seedStartByte = 6;
		}
		else 
		{
			seedStartByte = 6;
		}
        substr_cpy(Seed,pufferStr,seedStartByte,-1,elcount(Seed));
        if(securityRespBuffer[0] != 0x7F)
        {
          putValue(Env_Doip_Security_SeedOutput_1,Seed);
        }
        toUpper(Seed,Seed,elcount(Seed));
        //write("%s", seedList[2]);     
        for(i=0;i<100;i++)
        {
          
          if(strncmp(seedList[i],Seed, elcount(Seed))==0)
          {
            break;
          }
          else if(100== i+1)
          {
            write("The Security XML doesnt have the required seed - key pair ");
            i = -1;
            break;
          }
        }
        sendKey[0]='\0';
        
        if(i!=-1)
        {
          
        sendKey[0]=0x27;
        sendKey[1]=SeednKeyFBLRequest[1]+1;      
        k=2;  
        strncpy(temp, "0x",3);
        j=0;
        TxLength = (strlen(keyList[i])/2)+2;
        while(j<strlen(keyList[i]))
        {
          temp[2]=keyList[i][j];
          temp[3]=keyList[i][j+1];
          temp[4]=0;
          sendKey[k]=atol(temp);
          k++;
          j+=2;
        }
        sendKey[k]='\0';
        
        StartDiagService( SEEDNKEYJLRRESP);    
        
        }
        else
        {
          putValue(Env_Doip_SecurityMode_Output_1,"Seed Not found in XML");
        }
         break; 
      
	  //response   
    
        
        
        
	  case SEEDNKEYFBLDYNAMICREQUEST:
        
            responseLen = getvalue(EnvRxData_CAN_1,securityRespBuffer);
            for(i=0;i<responseLen;i++)
            {
              ltoa(securityRespBuffer[i],IMBuffer,16);
              if( strlen( IMBuffer ) == 1 )
			        {
				        IMBuffer[1] = IMBuffer[0];
                IMBuffer[0] = '0';
                strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
		          else
			        {
				        strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
              
            }
            substr_cpy(Seed,pufferStr,4,-1,elcount(Seed));
            
            if(securityRespBuffer[0] != 0x7F)
            {
             putValue(Env_Doip_Security_SeedOutput_1,Seed);
             setTimer(sectimer1,1000);
            }
            
            DynamicFlag = 1;
            break;  
        
      case SEEDNKEYREQUEST:
      
          
            getvalue(EnvRxData_CAN_1,puffer);
           
          // New Calculation of Reprog Key in BL for Release X060 onwards:
            
            resultarray[0] = 0x27 ;
            resultarray[1] = SeednKeyFBLRequest[1] + 1;

            for (i = 2; i <6 ; i++)
            {
            	resultarray_32[i]=puffer [i];
            }

			seedReprogValue = resultarray_32[5] |
							  (resultarray_32[4] << 8) |
							  (resultarray_32[3] << 16) |
							  (resultarray_32[2] << 24);

			keyReprogValue = seedReprogValue;

        
    
       		for(j = 0; j <7 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + REP_RBA_CBB_AKEY_VALUE;
	       		// write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - REP_RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		/* Rotate Right by 10 */
 	       			keyLowReprogValue = keyReprogValue & (0x000003FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 22;
 	    			keyReprogValue = keyReprogValue >> 10;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       				keyReprogValue = keyReprogValue ^ REP_RBA_CBB_BKEY_VALUE;
    			}
    			else
    			{
 	    		/* Rotate Left by 13 */
 	    		    keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			        keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		       		keyReprogValue      = keyReprogValue ^ REP_RBA_CBB_CKEY_VALUE;
		    	}
      		}
 
        	keyReprogValue = keyReprogValue - REP_RBA_CBB_DKEY_VALUE;

		  /* Key Algo end */
			    //write(" final  keyReprogValue %lx",keyReprogValue );    
  
        	resultarray[5] = (byte)(keyReprogValue & 0xff);
			resultarray[4] = (byte)((keyReprogValue >> 8) & 0xff);
			resultarray[3] = (byte)((keyReprogValue >> 16) & 0xff);
			resultarray[2] = (byte)((keyReprogValue >> 24) & 0xff);

           StartDiagService (SEEDNKEYRESP);
         
      break;
            
            
      case SEEDNKEYREQUESTUNLOCKONE: 
   
            //Calculate  key after receiving seed
           getvalue(EnvRxData_CAN_1,puffer);
//Aquire 4 byte seed from ECU
           //Calculate the key
           seed_1[0]=puffer[2];	seed_1[1]=puffer[3];	seed_1[2]=puffer[4];	seed_1[3]=puffer[5];

           write("Seed value %x %x %x %x", seed_1[0], seed_1[1], seed_1[2], seed_1[3]);
//Perform Bit-wise Ex- OR of the seed with a constant
           sec_key1[0] = seed_1[0]^AppKeyConst[0];
           sec_key1[1] = seed_1[1]^AppKeyConst[1];
           sec_key1[2] = seed_1[2]^AppKeyConst[2];
           sec_key1[3] = seed_1[3]^AppKeyConst[3];

           write("Sec key 1 value %x %x %x %x", sec_key1[0], sec_key1[1], sec_key1[2], sec_key1[3]);
//Rotate seed by 16-bits to obtain seed2
           seed_2[3] = ((seed_1[0]>>7)&0x01)|((seed_1[0]>>5)&0x02)|((seed_1[0]>>3)&0x04)|((seed_1[0]>>1)&0x008)|((seed_1[0]<<1)&0x010)|((seed_1[0]<<3)&0x020)|((seed_1[0]<<5)&0x040)|((seed_1[0]<<7)&0x80);
           seed_2[2] = ((seed_1[1]>>7)&0x01)|((seed_1[1]>>5)&0x02)|((seed_1[1]>>3)&0x04)|((seed_1[1]>>1)&0x008)|((seed_1[1]<<1)&0x010)|((seed_1[1]<<3)&0x020)|((seed_1[1]<<5)&0x040)|((seed_1[1]<<7)&0x80);          
           seed_2[1] = ((seed_1[2]>>7)&0x01)|((seed_1[2]>>5)&0x02)|((seed_1[2]>>3)&0x04)|((seed_1[2]>>1)&0x008)|((seed_1[2]<<1)&0x010)|((seed_1[2]<<3)&0x020)|((seed_1[2]<<5)&0x040)|((seed_1[2]<<7)&0x80);        
           seed_2[0] = ((seed_1[3]>>7)&0x01)|((seed_1[3]>>5)&0x02)|((seed_1[3]>>3)&0x04)|((seed_1[3]>>1)&0x008)|((seed_1[3]<<1)&0x010)|((seed_1[3]<<3)&0x020)|((seed_1[3]<<5)&0x040)|((seed_1[3]<<7)&0x80);
           //seed_1[2];
           //seed_2[1] = seed_1[3];
           //seed_2[2] = seed_1[0];
           //seed_2[3] = seed_1[1];

          write("Seed value 2 %x %x %x %x", seed_2[0], seed_2[1], seed_2[2], seed_2[3]);

//Perform Bit-wise Ex- OR of the seed with same constant
           sec_key2[0] = seed_2[0]^AppKeyConst[0];
           sec_key2[1] = seed_2[1]^AppKeyConst[1];
           sec_key2[2] = seed_2[2]^AppKeyConst[2];
           sec_key2[3] = seed_2[3]^AppKeyConst[3];

           write("Sec key 2 value %x %x %x %x", sec_key2[0], sec_key2[1], sec_key2[2], sec_key2[3]);
//Add key1 and key2 and discard the final carry if any to obtain the key.
           temp_sec_key = sec_key1[3] + sec_key2[3];
           sec_key[3] = (temp_sec_key&0xFF);
           temp_sec_key = sec_key1[2] + sec_key2[2]+((temp_sec_key&0x100)>>8);
           sec_key[2] = (temp_sec_key&0xFF);
           temp_sec_key = sec_key1[1] + sec_key2[1]+((temp_sec_key&0x100)>>8);
           sec_key[1] = (temp_sec_key&0xFF);
           temp_sec_key = sec_key1[0] + sec_key2[0]+((temp_sec_key&0x100)>>8);
           sec_key[0] = (temp_sec_key&0xFF);
           write("Sec key value %x %x %x %x", sec_key[0], sec_key[1], sec_key[2], sec_key[3]);

             //Frame and send the calculated key with service 27 02             
            resultarray[5]=sec_key[3];
            resultarray[4]=sec_key[2];
            resultarray[3]=sec_key[1];
            resultarray[2]=sec_key[0];
			      resultarray[1]=0x02;
            resultarray[0]=0x27;
            whichlogin=0;   
          StartDiagService( SEEDNKEYRESP);

      break;
            
            // FBL Security Unlock
            
           case SEEDNKEYREQUESTUNLOCKTWO: 
//   
//            //Copy received data to local Buffer                
//             getvalue(EnvRxData_CAN_1,puffer);
//                                     
//            //Aquire 4 bytes of seed from ECU          
//            seedArray[0]=puffer[2];	seedArray[1]=puffer[3];	seedArray[2]=puffer[4];	seedArray[3]=puffer[5];
//
//           write("Seed value %x %x %x %x", seedArray[0], seedArray[1], seedArray[2], seedArray[3]);
//
//		      seed = ((seedArray[0] * 0x1000000) | (seedArray[1] *  0x10000) | (seedArray[2] * 0x100) | (seedArray[3]));
//          if(seed!=0)
//          {
//            for(i=0;i<35;i++)
//            {
//              if(seed & 0x80000000)
//              {
//                seed = seed<<1;
//                seed = seed^MASK_Application;
//              }
//              else
//              {
//                seed = seed<<1;
//              }
//            }
//            keyy = seed;
//          }
//          returnKey[0] =  (keyy & 0xFF000000) >> 24;
//          returnKey[1] =  (keyy & 0x00FF0000) >> 16;
//          returnKey[2] =  (keyy & 0x0000FF00) >> 8;
//          returnKey[3] =  (keyy & 0x000000FF); 
//		   
//		   
//           write("return key value %x %x %x %x", returnKey[0], returnKey[1], returnKey[2], returnKey[3]);
//                
//           
//            //Frame and send the calculated key with service 27 02             
//            resultarray[5]=returnKey[3];
//            resultarray[4]=returnKey[2];
//            resultarray[3]=returnKey[1];
//            resultarray[2]=returnKey[0];
//			      resultarray[1]=0x02;
//            resultarray[0]=0x27;
//            whichlogin=0;   
//            StartDiagService( SEEDNKEYRESP);

			//Calculate  key after receiving seed
			getvalue(EnvRxData_CAN_1,puffer);
			//Aquire 4 byte seed from ECU
			//Calculate the key
			seed_1[0]=puffer[2];	seed_1[1]=puffer[3];	seed_1[2]=puffer[4];	seed_1[3]=puffer[5];

			write("Seed value %x %x %x %x", seed_1[0], seed_1[1], seed_1[2], seed_1[3]);
			//Perform Bit-wise Ex- OR of the seed with a constant
			sec_key1[0] = seed_1[0]^AppKeyConst[0];
			sec_key1[1] = seed_1[1]^AppKeyConst[1];
			sec_key1[2] = seed_1[2]^AppKeyConst[2];
			sec_key1[3] = seed_1[3]^AppKeyConst[3];

			write("Sec key 1 value %x %x %x %x", sec_key1[0], sec_key1[1], sec_key1[2], sec_key1[3]);
			//Rotate seed by 16-bits to obtain seed2
			seed_2[3] = ((seed_1[0]>>7)&0x01)|((seed_1[0]>>5)&0x02)|((seed_1[0]>>3)&0x04)|((seed_1[0]>>1)&0x008)|((seed_1[0]<<1)&0x010)|((seed_1[0]<<3)&0x020)|((seed_1[0]<<5)&0x040)|((seed_1[0]<<7)&0x80);
			seed_2[2] = ((seed_1[1]>>7)&0x01)|((seed_1[1]>>5)&0x02)|((seed_1[1]>>3)&0x04)|((seed_1[1]>>1)&0x008)|((seed_1[1]<<1)&0x010)|((seed_1[1]<<3)&0x020)|((seed_1[1]<<5)&0x040)|((seed_1[1]<<7)&0x80);          
			seed_2[1] = ((seed_1[2]>>7)&0x01)|((seed_1[2]>>5)&0x02)|((seed_1[2]>>3)&0x04)|((seed_1[2]>>1)&0x008)|((seed_1[2]<<1)&0x010)|((seed_1[2]<<3)&0x020)|((seed_1[2]<<5)&0x040)|((seed_1[2]<<7)&0x80);        
			seed_2[0] = ((seed_1[3]>>7)&0x01)|((seed_1[3]>>5)&0x02)|((seed_1[3]>>3)&0x04)|((seed_1[3]>>1)&0x008)|((seed_1[3]<<1)&0x010)|((seed_1[3]<<3)&0x020)|((seed_1[3]<<5)&0x040)|((seed_1[3]<<7)&0x80);
			//seed_1[2];
			//seed_2[1] = seed_1[3];
			//seed_2[2] = seed_1[0];
			//seed_2[3] = seed_1[1];

			write("Seed value 2 %x %x %x %x", seed_2[0], seed_2[1], seed_2[2], seed_2[3]);

			//Perform Bit-wise Ex- OR of the seed with same constant
			sec_key2[0] = seed_2[0]^AppKeyConst[0];
			sec_key2[1] = seed_2[1]^AppKeyConst[1];
			sec_key2[2] = seed_2[2]^AppKeyConst[2];
			sec_key2[3] = seed_2[3]^AppKeyConst[3];

			write("Sec key 2 value %x %x %x %x", sec_key2[0], sec_key2[1], sec_key2[2], sec_key2[3]);
			//Add key1 and key2 and discard the final carry if any to obtain the key.
			temp_sec_key = sec_key1[3] + sec_key2[3];
			sec_key[3] = (temp_sec_key&0xFF);
			temp_sec_key = sec_key1[2] + sec_key2[2]+((temp_sec_key&0x100)>>8);
			sec_key[2] = (temp_sec_key&0xFF);
			temp_sec_key = sec_key1[1] + sec_key2[1]+((temp_sec_key&0x100)>>8);
			sec_key[1] = (temp_sec_key&0xFF);
			temp_sec_key = sec_key1[0] + sec_key2[0]+((temp_sec_key&0x100)>>8);
			sec_key[0] = (temp_sec_key&0xFF);
			write("Sec key value %x %x %x %x", sec_key[0], sec_key[1], sec_key[2], sec_key[3]);

            //Frame and send the calculated key with service 27 02             
            resultarray[5]=sec_key[3];
            resultarray[4]=sec_key[2];
            resultarray[3]=sec_key[1];
            resultarray[2]=sec_key[0];
			resultarray[1]=0x02;
            resultarray[0]=0x27;
            whichlogin=0; 
			
			if(RxDataBuffer[0] == 0x67 &&  RxDataBuffer[1] == 0x01)
			{
				StartDiagService(SEEDNKEYRESP);
			}
      break;
      
      case SEEDNKEYJLRDYNAMICREQUEST:
        
            responseLen = getvalue(EnvRxData_CAN_1,securityRespBuffer);
            for(i=0;i<responseLen;i++)
            {
              ltoa(securityRespBuffer[i],IMBuffer,16);
              if( strlen( IMBuffer ) == 1 )
			        {
				        IMBuffer[1] = IMBuffer[0];
                IMBuffer[0] = '0';
                strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
		          else
			        {
				        strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
              
            }
            substr_cpy(Seed,pufferStr,4,-1,elcount(Seed));
            
             if(securityRespBuffer[0] != 0x7F)
            {
             putValue(Env_Doip_Security_SeedOutput_1,Seed);
             setTimer(sectimer1,1000);
            }
            
            DynamicFlag = 2;
            break;
            
      case SEEDNKEYJLREOLREQUEST: 
        
    responseLen = getvalue(EnvRxData_CAN_1,securityRespBuffer);
    strncpy(pufferStr,"",elcount(pufferStr));
    strncpy(Seed,"",elcount(Seed));
        
    for(i=0;i<responseLen;i++)
    {
      ltoa(securityRespBuffer[i],IMBuffer,16);
      
      if( strlen( IMBuffer ) == 1 )
			{
				 IMBuffer[1] = IMBuffer[0];
         IMBuffer[0] = '0';
         strncat(pufferStr,IMBuffer,elcount(pufferStr));
			}
		  else
			{
				 strncat(pufferStr,IMBuffer,elcount(pufferStr));
			}
    
    }
    write("%s",pufferStr);
    substr_cpy(Seed,pufferStr,4,-1,elcount(Seed));
    
    if(securityRespBuffer[0] != 0x7F)
    {
      putValue(Env_Doip_Security_SeedOutput_1,Seed);
    }
    
    toUpper(Seed,Seed,elcount(Seed));
          
    for(i=0;i<100;i++)
    {
      if(strncmp(seedListJLR[i],Seed, elcount(Seed))==0)
      {
        break;
      }
      else if(100== i+1)
      {
        write("The Security XML doesnt have the required seed - key pair ");
        i = -1;
        break;
      }
    }
    
    if(i!=-1)
    {
    sendKey[0]=0x27;
    sendKey[1]=SeednKeyJLREOLRequest[1]+1;
    k=2;  
    
    strncpy(temp, "0x",3);
    j=0;
    TxLength = (strlen(keyListJLR[i])/2)+2;
    
    while(j<strlen(keyListJLR[i]))
    {
      temp[2]=keyListJLR[i][j];
      temp[3]=keyListJLR[i][j+1];
      temp[4]=0;
      sendKey[k]=atol(temp);
      k++;
      j+=2;
    }
    sendKey[k]='\0';    
    StartDiagService( SEEDNKEYJLRRESP);
    }
     break;    
   //end
    
//      case SEEDNKEYREQUESTUNLOCKTWO:
//            //Calculate  key after receiving seed
//           getvalue(EnvRxData_CAN_1,puffer);
//           
//                //int seedlength = 4;
//                //byte t_crc = 0xFF;
//
//          /*      t_crc = 0xFF;
//                //calculate the Key
//                byte_buf[0]=puffer[2];	byte_buf[1]=puffer[3];	byte_buf[2]=puffer[4];	byte_buf[3]=puffer[5];	
//                CalculateCrc8 ();
//                byte_buf[0] = t_crc;
//                t_crc = 0xFF;
//
//                CalculateCrc8 ();
//                sec_key[0] = t_crc;
//                t_crc = 0xFF;
//
//                byte_buf[0]=puffer[2]; 	byte_buf[1]=sec_key[0];	
//                CalculateCrc8 ();
//                sec_key[1] = t_crc;
//                t_crc = 0xFF;
//						
//            //crc8(&t_crc, seedlength, byte_buf);
//            //key[1] = crc8(&t_crc, seedlength, byte_buf);;
//			byte_buf[1]=puffer[3]; 	byte_buf[2]=sec_key[1];				
//            CalculateCrc8 ();
//            sec_key[2] = t_crc;
//            t_crc = 0xFF;
//
//        	byte_buf[2]=puffer[4]; 	byte_buf[3]=sec_key[2];	
//            CalculateCrc8 ();
//            sec_key[3] = t_crc;
//            //t_crc = 0xFF;
//
//                //result=puffer[2]*0x1000000+puffer[3]*0x10000+puffer[4]*0x100+puffer[5] + getValue(EnvDevLoginValue);
// 
//               
//            resultarray[5]=sec_key[3];
//            resultarray[4]=sec_key[2];
//            resultarray[3]=sec_key[1];
//            resultarray[2]=sec_key[0];
//			resultarray[1]=0x04;
//            resultarray[0]=0x27;
//            whichlogin=0;       */
//          StartDiagService( SEEDNKEYRESP);
//
//    break;
     

        case MINICODEREQUEST: 
            //Calculate  key after receiving seed
           
            getvalue(EnvRxData_CAN_1,puffer);
            resultarray[0] = 0x27 ;
           
            for (i = 2; i <6 ; i++)
            {
            	resultarray_32[i]=puffer [i];
            }

			seedReprogValue = resultarray_32[5] |
							  (resultarray_32[4] << 8) |
							  (resultarray_32[3] << 16) |
							  (resultarray_32[2] << 24);

		

         	write(" seed Value %lx: ",  seedReprogValue);    
    
            switch ( whichlogin )    
            {
                case 5:         // plant
                     resultarray[1] = 0x04 ;
                    CalculateKey (seedReprogValue,WERK_RBA_CBB_AKEY_VALUE,WERK_RBA_CBB_BKEY_VALUE,WERK_RBA_CBB_CKEY_VALUE,WERK_RBA_CBB_DKEY_VALUE);

                break;

                case 6 :         //dev
                  resultarray[1] = 0x22 ;
                    CalculateKey (seedReprogValue,DEV_RBA_CBB_AKEY_VALUE,DEV_RBA_CBB_BKEY_VALUE,DEV_RBA_CBB_CKEY_VALUE,DEV_RBA_CBB_DKEY_VALUE);

                 break;
            }
           
  
        	resultarray[5] = (byte)(keyReprogValue & 0xff);
			resultarray[4] = (byte)((keyReprogValue >> 8) & 0xff);
			resultarray[3] = (byte)((keyReprogValue >> 16) & 0xff);
			resultarray[2] = (byte)((keyReprogValue >> 24) & 0xff);
            
            StartDiagService( SEEDNKEYRESP);
        
      break;

      case SEEDNKEYREPROGREQUEST:
      
          
            getvalue(EnvRxData_CAN_1,puffer);
           
          // New Calculation of Reprog Key in BL for Release X060 onwards:
            
            resultarray[0] = 0x27 ;
            resultarray[1] = 0x12 ;

            for (i = 2; i <6 ; i++)
            {
            	resultarray_32[i]=puffer [i];
            }

			seedReprogValue = resultarray_32[5] |
							  (resultarray_32[4] << 8) |
							  (resultarray_32[3] << 16) |
							  (resultarray_32[2] << 24);

			keyReprogValue = seedReprogValue;

        
    
       		for(j = 0; j <7 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + REP_RBA_CBB_AKEY_VALUE;
	       		// write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - REP_RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		/* Rotate Right by 10 */
 	       			keyLowReprogValue = keyReprogValue & (0x000003FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 22;
 	    			keyReprogValue = keyReprogValue >> 10;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       				keyReprogValue = keyReprogValue ^ REP_RBA_CBB_BKEY_VALUE;
    			}
    			else
    			{
 	    		/* Rotate Left by 13 */
 	    		    keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			        keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		       		keyReprogValue      = keyReprogValue ^ REP_RBA_CBB_CKEY_VALUE;
		    	}
      		}
 
        	keyReprogValue = keyReprogValue - REP_RBA_CBB_DKEY_VALUE;

		  /* Key Algo end */
			    //write(" final  keyReprogValue %lx",keyReprogValue );    
  
        	resultarray[5] = (byte)(keyReprogValue & 0xff);
			resultarray[4] = (byte)((keyReprogValue >> 8) & 0xff);
			resultarray[3] = (byte)((keyReprogValue >> 16) & 0xff);
			resultarray[2] = (byte)((keyReprogValue >> 24) & 0xff);

           StartDiagService (SEEDNKEYRESP);
         
      break;

      case SEEDNKEYREPROGREQUESTWRITEKEY:
      
          
            getvalue(EnvRxData_CAN_1,puffer);
           
          // New Calculation of Reprog Key in BL for Release X060 onwards:
            
            resultarray[0] = 0x27 ;
            resultarray[1] = 0x12 ;

            for (i = 2; i <6 ; i++)
            {
            	resultarray_32[i]=puffer [i];
            }

			seedReprogValue = resultarray_32[5] |
							  (resultarray_32[4] << 8) |
							  (resultarray_32[3] << 16) |
							  (resultarray_32[2] << 24);

			keyReprogValue = seedReprogValue;

        
    
       		for(j = 0; j <7 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + REP_RBA_CBB_AKEY_VALUE;
	       		// write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - REP_RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		/* Rotate Right by 10 */
 	       			keyLowReprogValue = keyReprogValue & (0x000003FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 22;
 	    			keyReprogValue = keyReprogValue >> 10;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       				keyReprogValue = keyReprogValue ^ REP_RBA_CBB_BKEY_VALUE;
    			}
    			else
    			{
 	    		/* Rotate Left by 13 */
 	    		    keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			        keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		       		keyReprogValue      = keyReprogValue ^ REP_RBA_CBB_CKEY_VALUE;
		    	}
      		}
 
        	keyReprogValue = keyReprogValue - REP_RBA_CBB_DKEY_VALUE;

		  /* Key Algo end */
			    write(" final  keyReprogValue %lx",keyReprogValue );
                putValue( EnvWriteLoginKey, keyReprogValue );    
           
      break;

     case SEEDNKEYRBOLREQUESTWRITEKEY:
      
          
            getvalue(EnvRxData_CAN_1,pufferEOL);
      
            resultarray[0] = 0x27 ;
            resultarray[1] = 0x62 ;
            
            for (i = 2; i <6 ; i++)
            {
            	resultarray[i]=pufferEOL [i];
            }

			authKey = resultarray[5] |
							  (resultarray[4] << 8) |
							  (resultarray[3] << 16) |
							  (resultarray[2] << 24);    

               
          authKey = authKey & RBEOLPin; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
          authKey = authKey | PMARequest; //Plant mode activation part request
      
          resultarray[5] = (byte)(authKey & 0xff);
    	  resultarray[4] = (byte)((authKey >> 8) & 0xff);
    	  resultarray[3] = (byte)((authKey >> 16) & 0xff);
    	  resultarray[2] = (byte)((authKey >> 24) & 0xff);

		  StartDiagService (SEEDNKEYRESP); 
           
      break;

	 case  READ_EWB_ACT: // works only for long response always,more Ids at the same time
            
        for (i = 2; i <Length ; i=i+3)
            {
                //Byte(1) = =0x05 by all identifiers
                IdentifierId  = RxDataBuffer[i];
                IdentifierValue  = RxDataBuffer[i+1];
                EvaluateIdentifier(IdentifierId,IdentifierValue);
              
             }
    break;
//      case  READ_DEACT_FUNC: // works only for long response always,more Ids at the same time
//            
//        for (i = 2; i <Length ; i=i+3)
//            {
//                //Byte(1) = =0x05 by all identifiers
//                IdentifierId  = RxDataBuffer[i];
//                IdentifierValue  = RxDataBuffer[i+1];
//                EvaluateIdentifier(IdentifierId,IdentifierValue);
//              
//             }
//     break;

        case  READ_MASK_FAULT_CLASS: 
       
                //Byte(1) = =0x05 by all identifiers
               ByteValue[0]= RxDataBuffer[3];
               putValue (EnvMaskFaultClass1_Value,ByteValue);
               ByteValue[0]= RxDataBuffer[4];
               putValue (EnvMaskFaultClass2_Value,ByteValue);
               ByteValue[0]= RxDataBuffer[5];
               putValue (EnvMaskFaultClass3_Value,ByteValue);
               ByteValue[0]= RxDataBuffer[6];
               putValue (EnvMaskFaultClass4_Value,ByteValue);
       break;

        case  READ_MASK_ERR_RCTN: 
          //Byte(1) = =0x05 by all identifiers
               ByteValue[0]= RxDataBuffer[3];
               putValue (EnvMaskErrorReactDev_Value,ByteValue);
          
         break;

        case  READ_BAP_PERS: 
            
                //Byte(1) = =0x05 
                IdentifierId  = RxDataBuffer[2];
                IdentifierValue  = RxDataBuffer[3];
                EvaluateIdentifier(IdentifierId,IdentifierValue);
       break;
       
               
        case  READ_V_THRESHOLD_MAINBEAM_ON :
           //Byte(1) = =0x3B 
           result= ( (dword)RxDataBuffer[3] << 8 ) | ( (dword)RxDataBuffer[4] & 0xff ) ;
           putValue (EnvV_Schwelle_FLA_ein_Value,result);
        break;

        case  READ_V_THRESHOLD_MAINBEAM_OFF: 
         //Byte(1) = =0x3B 
            result= ( (dword)RxDataBuffer[3] << 8 ) | ( (dword)RxDataBuffer[4] & 0xff ) ;
           putValue (EnvV_Schwelle_FLA_aus_Value,result);
         break;


     case RESET: 
     case START_IR_TEST: 
	 case STOP_IR_TEST: 
     case START_IMG_TEST: 
	 case STOP_IMG_TEST: 
	 case CALIB_AUTO:         
  	 case SKIP_CALIB:
	 case CALIB_SHIFT_UP:
	 case CALIB_SHIFT_DOWN:
	 case CALIB_SHIFT_LEFT:
	 case CALIB_SHIFT_RIGHT:
	 case CALIB_DATA_SAVE:
	 case CALIB_DATA_DEL:
	 case TESTER_PRESENT_ON:
     case TESTER_PRESENT_OFF:
     case DIS_NOR_MSG_TX: 
	 case EN_NOR_MSG_TX: 
	 case CLEAR_DTC: 
     case CLEAR_HIST_DTC: 
	 case SHOW_ENG_INFO:
     case DIRECT_RQ:

    break;

 
   }

}  

int EvaluateResponse()
{  
   int ret; 
   
   ret = 0;

   if ( RxDataBuffer[0] == 0x7F )
   {
   
      switch ( RxDataBuffer[2] ) 
      {
         case 0x10: 
            putValue (EnvReqStatus_CAN_1, "General reject");
         break;

         case 0x11: 
            putValue (EnvReqStatus_CAN_1, "Service not supported");
         break;

         case 0x12: 
            putValue (EnvReqStatus_CAN_1, "SubFunction Not Supported");
         break;

         case 0x13: 
            putValue (EnvReqStatus_CAN_1, " InCorrect Message Length-invalid Format");
         break;

         case 0x21: 
            putValue (EnvReqStatus_CAN_1, "Busy Repeat Request");
         break;

         case 0x22: 
            putValue (EnvReqStatus_CAN_1, "Conditions Not Correct");
         break;

     //    case 0x23: 
     //       putValue (EnvReqStatus_CAN_1, "Routine not complete");
     //    break;

         case 0x24: 
           putValue (EnvReqStatus_CAN_1, "Request Sequence Error");
         break;

         case 0x26: 
            putValue (EnvReqStatus_CAN_1, "Failure Prevents Execution of requested action");
         break;

         case 0x31: 
            putValue (EnvReqStatus_CAN_1, "Request Out Of Range");
         break;

         case 0x33: 
            putValue (EnvReqStatus_CAN_1, "Security Access Denied");
         break;

         case 0x35: 
            putValue (EnvReqStatus_CAN_1, "Invalid key");
         break;

         case 0x36: 
            putValue (EnvReqStatus_CAN_1, "Exceed number of attempts");
         break;

         case 0x37: 
            putValue (EnvReqStatus_CAN_1, "Time delay not expired");
         break;

         case 0x78: 
            putValue (EnvReqStatus_CAN_1, "Request Correctly Received-Response Pending");
            // Wait
			ret = 0; 
		 break;

      //   case 0x80: 
      //      putValue (EnvReqStatus_CAN_1, "Service not supported in active mode");
      //   break;

         case 0x7E: 
             putValue (EnvReqStatus_CAN_1, "SubFunction Not Supported In Active Diagnostic Session");
    	 break;

         case 0x7F: 
             putValue (EnvReqStatus_CAN_1, "Service Not Supported In Active Diagnosic Session");
    	 break;
             
         case 0x83: 
             putValue (EnvReqStatus_CAN_1, "Condition not correct - Engine running");
    	 break;
         
         case 0x88: 
             putValue (EnvReqStatus_CAN_1, "Vehicle Speed Too High");
    	 break;

         case 0x89: 
             putValue (EnvReqStatus_CAN_1, "Negative Response:ESP_v_Signal<= 50 km/h");
    	 break;


         default:   
            putValue (EnvReqStatus_CAN_1, "Negative Response: Acknowledge not defined");
         break;
         }
   }
   else
   {
      /*if ( RxDataBuffer[0] == ( SId + 0x40 ) )        
      {
         // Positive response
         
                 putValue (EnvReqStatus_CAN_1,"OK! Positive response");
    
    
    	 ret = 1; 
      }
      else                      
      {
         
           putValue (EnvReqStatus_CAN_1 ,"Unknown response");
		 
         ret = 0; 
      }*/
	  if ( RxDataBuffer[0] != ( SId + 0x40 ) )        
      {
         // Positive response
         putValue (EnvReqStatus_CAN_1 ,"Unknown response");
    	 ret = 0; 
      }
      else                      
      {
         
         putValue (EnvReqStatus_CAN_1,"OK! Positive response");
         ret = 1; 
      }
   }

   return ( ret ); 
}

On EnvVar EnvReadErrors_2
{
//    if (!getvalue(EnvBVSDPC))
//    {    
        if ( getValue ( this ) )
        {
            ClearDtcDisplay();
            StartDiagService( READ_DTC_BY_ST );
        }
//    }
}

void GetDtcName (dword error,int DTC_or_historical)
{	
	char DTCText [256];
    long res;
   

    // Hole DTC Beschreibung aus Tabelle
  
    if (getValue (EnvDllRxId_Copy_1) == 0x76B)
    {
        //res=GetDTCdescription_BVS(error, DTCText);
    }else{
         //res=GetDTCdescription_Kamera(error, DTCText);
    }
  
    if(res == 0) // DTC in Tabelle nicht gefunden
    {
        snprintf( DTCText, 255,"Unknown Error: %d",error);
    }

 	if (DTC_or_historical==1)  //ReadDTC
		{
			putValue (EnvDtcName_2, DTCText); 
            Display_DTC_MID_Name(error);     
		}  else {  // Read Historical DTCs							
	    	putValue (EnvHistDtcName, DTCText);   
		}
}

void ClearDtcDisplay (void)
{
   
   NrOfReadDTC = 0;
   CurrentDTC  = 0;

   ShowDTCs();
}

void ShowDTCs (void)
{
   char buffer[50];
   long buffer_dec;
   
   if ( CurrentDTC > NrOfReadDTC )
   {
      CurrentDTC = NrOfReadDTC;
   } 
   else if ( (CurrentDTC < 1) && (NrOfReadDTC) )
   {
      CurrentDTC = 1;
   }
   else if ( (CurrentDTC < 0) && (!NrOfReadDTC) )
   {
      CurrentDTC = 0;
   } 
   
   snprintf (buffer, 49, "%02d/%02d", CurrentDTC, NrOfReadDTC);
   putValue (EnvDtcPosition_2, buffer);  
   
   if ( CurrentDTC )
   {
      // DTC No
      snprintf (buffer, 49, "%06x",   errorDTC[CurrentDTC]);
      putValue (EnvDtcNr_2, buffer);
      // convert DTC No. from hex to dec
      snprintf (buffer, 49, "0x%06x", errorDTC[CurrentDTC]);
      buffer_dec = atol(buffer);
      putValue (EnvDtcNr_dec_2, buffer_dec);
      //DTC Status
      snprintf (buffer, 49, "%02x", errorStatus[CurrentDTC]);
      putValue (EnvDtcState_2, buffer);
      GetDtcName (errorDTC[CurrentDTC],1);
      

   }
   else
   {
      putValue (EnvDtcNr_2,     "----");
      putValue (EnvDtcState_2,  "--");
      putValue (EnvDtcName_2,   "----");
	  putValue( EnvEnvDataDisplay_2, "------"  );
   } 
}

On EnvVar EnvClearErrors_2
{
   if ( getValue( this ) )
   {
      StartDiagService( CLEAR_DTC );
	  ClearDtcDisplay();
    }
}

on timer UpdateRuntime
{
	StartDiagService( GET_SYS_RUNTIME );
	SetTimer( UpdateRuntime, UpdateCycle);
}

void GetSupplier(byte Code, char Supplier[])
{
   switch ( Code )
   {
	  case 0x03: 
	  	strncpy(Supplier,"Bosch",10);
	  break; 

      default:   
	  	strncpy(Supplier,"Error!!",10);
      break; 
   }
}

EvaluateEnvData()
{
  snprintf( StringAux,99,"Environment data:                ");
  strncpy( Stringbuffer, StringAux,255);

  switch( ( (word)RxDataBuffer[2] << 8 ) | (word)RxDataBuffer[3] )
  {  

    
  
    default:
    {
    }
    break;
  }

  putValue( EnvEnvDataDisplay_2, Stringbuffer);

}

on envVar EnvDtcCountDown_2
{


        if ( getValue (this) )
        {
            CurrentDTC--;
            ShowDTCs(); 
        }

}

on envVar EnvDtcCountUp_2
{


        if ( getValue (this) )
        {
            CurrentDTC++;
            ShowDTCs(); 
        }

}

on envVar EnvTesterPresentOnOff_2
{
    if(getvalue(this))
    {
        StartDiagService( TESTER_PRESENT_ON );
    }
    else
    {
        StartDiagService( TESTER_PRESENT_OFF );
        SetControlForeColor("Anpassungen", "PrepareWriteControl", MakeRGB(255,0,0));
    }
  
        

    /*
        if (getvalue(this))
        {    
            if (TesterPresentOnOff==0) 
            {
                StartDiagService( TESTER_PRESENT_ON );
                TesterPresentOnOff=1;
            }
        }
        else
        {
            if (TesterPresentOnOff==1) 
            {
                StartDiagService( TESTER_PRESENT_OFF );    
                TesterPresentOnOff=0;
            }
        }
    */
}

on timer TesterPresentTimer
{
   
   ReqDiagMsgGlobal.byte(0) = 0x02;
   ReqDiagMsgGlobal.byte(1) = 0x3E;
   ReqDiagMsgGlobal.byte(2) = 0x80;
      
   //msgDiagRequest.CAN = SEND_CAN;

   // transmit message
   output (ReqDiagMsgGlobal);
   
   // reStart timer
   setTimer (TesterPresentTimer, TesterPresentTime);
} 

on timer TesterPresentTimeOutTimer
{
   write (" tester present timer expired - switch off diagnostics");
   putValue (EnvDiagOnOff, 0);
}

on envVar EnvDiagSession_2
{
//    if (!getvalue(EnvBVSDPC))
//    {
        if (getvalue(this))
        {
            if (DiagSession==0)
            {
                StartDiagService( DIAG_SESSION_ON );
                putvalue(EnvTesterPresentOnOff_2,1);
                DiagSession=1;
            }
        }
        else
        {
            if (DiagSession==1)
            {
                putvalue(EnvTesterPresentOnOff_2,0);
                DiagSession=0;
            }
        }
//    }
        
}

on preStart
{
   /*if(0!= ReadDTCTableFile_BVS("c:\\Kamera.csv"))
        write("Fehler beim Lesen der CSV-Datei fr BVS");*/
	 char absPath[256];
   //getAbsFilePath("\\pc_mpc2_model\\Kamera.csv", absPath, 256);
 
   	//if(0!= ReadDTCTableFile_Kamera(absPath))
    //write("Fehler beim Lesen der CSV-Datei fr Kamera");
	 //char DTC_File_Path[250];
   char absPathsecurity[250];
    //SetupIp();
    //putValue (Env_Doipsend, "");
  
    //getAbsFilePath("cs_BJEV\\cs_BJEV_models\\stereo.csv", absPath, 256);
    getAbsFilePath("\\..\\cs\\cs_ta\\ECU Unlock Security.xml", absPathsecurity, 256);
  
    ParseSecurityXML(absPathsecurity);
}

on start
{ 
    byte buffer[1]={0xFF};

    OSEKTL_SetTimeoutAs(70);
    OSEKTL_SetTimeoutAr(70);
    OSEKTL_SetTimeoutBs(150);
    OSEKTL_SetTimeoutBr(150);
    OSEKTL_SetTimeoutCr(60);

    ConfigTP1();
       // Default Suche nach DTC 000124
                putValue ( EnvDtcLookForInEm , "000124");

             //default Values for Fault Classes
                putValue (EnvMaskFaultClass1_Value, buffer,1);
                putValue (EnvMaskFaultClass2_Value, buffer,1);
                putValue (EnvMaskFaultClass3_Value, buffer,1);
                putValue (EnvMaskFaultClass4_Value, buffer,1);
                buffer[0]=0xAA;
                putValue (EnvMaskErrorReactDev_Value, buffer,1);
                SetControlForeColor("Anpassungen", "PrepareWriteControl", MakeRGB(255,0,0));
    
    // working EOL Calibration String that can be used to test the EOL-Kalibrierung
    putValue(EnvEOLString, "2e25f4840f9a0fc308d8089c08b4088c192c47181630192c35e81630192c47180f50192c35e80f50"); 
    putValue(Env2E_extrinsic, "2e09b74e204e204e2004b0"); 
    
    
}

on envVar EnvDllTxId_Copy_1

{ 	OSEKTL_SetTxId( GetValue( EnvDllTxId_Copy_1 ) );
	//write("TX Id: %X",  OSEKTL_GetTxId() );		//debugging
}

on envVar EnvDllRxId_Copy_1
{	OSEKTL_SetRxId( GetValue( this ) );
	//write("RX Id: %X",  OSEKTL_GetRxId() );    	//debugging

}

on envVar EnvDllSTMin
{
	OSEKTL_SetSTMIN(getvalue(this));
	//write("STmin: %d",OSEKTL_GetSTMIN() );	//debugging




}

on envVar EnvDllBlockSize

{
	OSEKTL_SetBS(getvalue(this));
	write("BS: %d",OSEKTL_GetBS() );

}

on envVar EnvECUAdress
{
	write("Atention, ECU Adress has been changed!");    

}

on envVar EnvFCDelay
{
	
	OSEKTL_SetFCDelay(getValue(this));
}

on envVar EnvTransfer
{
	TxLength = getValue(this);
}

on envVar EnvUseFC

{
	OSEKTL_SetUseFC(getvalue(this));

	write("EnvUseFC: %d",OSEKTL_IsUseFC() );



}

on envVar EnvWaitingState
{
  OSEKTL_SetWaiting(getValue(this));
write ("Tester sends wait = %d",OSEKTL_GetWaiting());
}

void ConfigTP1()
{

	OSEKTL_SetNrmlMode();
	OSEKTL_FI_Enable(); //Enable Fault Injection for Transport Layer Tests

	// Normal Addressing
	OSEKTL_SetTxId( GetValue( EnvDllTxId_Copy_1 ) );
	//write("TX Id: %X",  OSEKTL_GetTxId() );	//debugging

	OSEKTL_SetRxId( GetValue( EnvDllRxId_Copy_1 ) );
	//write("RX Id: %X",  OSEKTL_GetRxId() );	//debugging    

	// Flow Control
	OSEKTL_SetBS( GetValue( EnvDllBlockSize ) );
	//write("BS: %d",OSEKTL_GetBS() );		//debugging

	OSEKTL_SetSTMIN( GetValue( EnvDllSTMin ) );
	//write("STmin: %d",OSEKTL_GetSTMIN() );	//debugging

	OSEKTL_SetUseFC( GetValue( EnvUseFC ) );
	//write("FC timeout: %d",OSEKTL_GetTimeoutFC() );	//debugging

//	PutValue( EnvCAN, SEND_CAN );
	OSEKTL_SetCAN( 1 );


}

on envVar EnvDiagTxDefaultValues_2
{

//TxDataBuffer = 


switch (getvalue(EnvDiagTxDefaultValues_2))
{
    
	case 0x1: 
    // vehicle Manufacturer SparePartNumber DataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x87;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;  
	
    case 0x2: 
    // system SupplierIdentifier DataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x8A;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;  
	
	case 0x3: 
    // System Name DataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x97;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;  
	
	case 0x4: 
    // systemSupplier ECU Hardware Version Number DataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x93;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break; 
	
	case 0x5: 
    // SystemSupplierECUSoftwareVersionNumberDataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x95;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;  	
	
	case 0x6: 
    // ECU Serial Number DataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x8C;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;	
	
	case 0x7: 
    //VIN DataIdentifier
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x90;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;		
	
	case 0x8: 
    //read SWF ingerprint
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x5B;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;	
	
	case 0x9: 
    //ECU Manufacturing Date
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x8B;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;	
	
	case 0x10: 
    //Configuration Date
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x99;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;	
	
	case 0x11: 
    //Vehicle Manufacturer ECU Software Version Number
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x89;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;	
/*    case 0x5: 
    // Diagnosemodus
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x86;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x4: 
    // VW ECU Serial Number
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x8C;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x5: 
    // SystemNameOrEngineType
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x97;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x6: 
    // ASAM/ODXFileIdentifier 
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x9E;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x7: 
    // ASAM/ODXFileVersion
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA2;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x8: 
    // VWECUHardwareVersionNumber
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA3;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x9: 
    // VWWorkshopSystemName
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xAA;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0xA: 
    // VW Variant CodingValue
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x06;
    TxDataBuffer_temp[2]=0x00;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0xB: 
    // VWTesterCodingInformation
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x06;
    TxDataBuffer_temp[2]=0x01;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0xC: 
    // Anzahl der Programmierversuche
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x04;
    TxDataBuffer_temp[2]=0x07;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0xD: 
    // Anzahl der Parametrierversuche
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x04;
    TxDataBuffer_temp[2]=0x09;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0xE: 
    // Anz. erfolg. Parametrierversuche
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x04;
    TxDataBuffer_temp[2]=0x0A;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0xF: 
    // max. Anz. d. mglichen Updateprogrammierungen
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x04;
    TxDataBuffer_temp[2]=0x0F;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x10: 
    // Identifikation der angeschlossenen Komponenten
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x2a;
    TxDataBuffer_temp[2]=0x30;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x11: 
    // Werkstattcode u. Datum d. letzten Updateprog. der SW Module
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x5B;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x12: 
    // Baugruppen und Seriennummer
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x79;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x13: 
    // Datum der letzten Codierung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x7B;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x14: 
    // Fazit Identifikation
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x7C;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x15: 
    // Identifikation der Parametrierung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x82;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x16: 
    // Diagnosemodus
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x86;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x17: 
    // Herstellungsdatum
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0x04;
    TxDataBuffer_temp[2]=0x8B;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x18: 
    // Fahrgestellnummer
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x90;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x19: 
    // Werkstattcode der Anpassung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x9A;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x1A: 
    // Datum der letzten Anpassung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0x9B;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x1B: 
    // Teilnummer des Parametersatzes
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA0;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x1C: 
    // Version des Parametersatzes
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA1;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x1D: 
    // Fahrzeugausstattungscode
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA4;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x1E: 
    // Werkstattcode der Codierung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA5;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x1F: 
    // Werkstattcode der Parametrierung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA8;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x20: 
    // Datum der Parametrierung
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xA9;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x21: 
    // Versionen der Softwaremodule
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xAB;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x22: 
    // Anzahl der mglichen Zugriffsberechtigungen
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xAE;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x23: 
    // Status der Programmierbarkeit
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xDF;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x24: 
    // Konsistenz der EEPROM Daten
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xE0;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;

    case 0x25: 
    // Bauzustandsdokumentation
    TxDataBuffer_temp[0]=0x22;
    TxDataBuffer_temp[1]=0xf1;
    TxDataBuffer_temp[2]=0xAC;
    putValue( EnvTxData_2, TxDataBuffer_temp, 3 );
    break;*/

    case 0x0: 
    // Empty Box
    putValue( EnvTxData_2, emptyString, 0 );
    break;
}


}

On EnvVar EnvReadPassiveErrors_2
{
 //   if (!getvalue(EnvBVSDPC))
 //   {    
        if ( getValue ( this ) )
        {
            ClearDtcDisplay();
            StartDiagService( READ_DTC_PASS );
        }
 //   }
}

on envVar EnvClearBuffer_CAN_1
{
    if(getValue(this)){
        putvalue(EnvRxData_CAN_1,emptyString,0);
    }
}

on timer readDtcTimer
{
    int i;
    readTimeValue+=CNTR_VALUE;

    if (readTimeValue < 1000)   //try to read until 1000ms
    {
        //putValue(EnvDirectSend_2,readString);
		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
        TransmitTxBuffer();


        strncpy(DTCValue,ErrString,strlen(ErrString)+1);
        //write("At %f DTCValue=%s",timeNowFloat()/100000,DTCValue);

        // if NOT "Busy Repeat Request", NOT "OK", NOT "Response Pending"
        if ( strncmp(DTCValue,"7f1921",6)!=0 &&     
             strncmp(DTCValue,"54",2)    !=0 &&
             strncmp(DTCValue,"7f1978",6)!=0 &&
             strlen(DTCValue)            !=0 )      
        {
            putValue(EnvErrValueOutput,DTCValue);
        } 
        else
        {
            //else (if "Busy...") do nothing
        }

        setTimer(readDtcTimer,CNTR_VALUE);
    }
    else  // time elapsed
    {
        cancelTimer(readDtcTimer);
        if (getValue(EnvErrValueOutput,DTCValue)==0)
        {
            putValue(EnvErrValueOutput,"No answer received.");
        }

        //syncronise the environmental variables
        putValue(EnvErrValueOutput,DTCValue);
        write("***At %f EnvErrValueOutput= %s",timeNowFloat()/100000,DTCValue);

    }

}

FillErrString (int length)
{
        //to create string representation of (bin)ErrValue[] in (char)ErrString[]

        char temp[3];
        int i;
        strncpy(ErrString,"",0);
        if (length!=0)
        {
        for (i=0;i<length;i++) 
            {
            strncpy(tempString,"",0);
            ltoa(ErrValue[i],temp,16);
            if (strlen(temp)==1) strncpy(tempString,"0",2);
            strncat(tempString,temp,(strlen(tempString)+strlen(temp))+1);
            //if (i<10) write("%d.%s->%s",i,temp,tempString);
            strncat(ErrString,tempString,strlen(tempString)+strlen(ErrString)+1);
            }
        length=0;
        //write("***At %f ErrString= %s",timeNowFloat()/100000,ErrString);
        }


}

on envVar EnvLogIn106A3
{

   if ( getValue (this) )
   {
    
     setTimer(FingerPrint,200);
      whichlogin=1;
     putvalue(EnvLogIn106A3,0); // Reset Value for next use
      
   }
  

   
}

on envVar EnvLogIn4E87
{

   if ( getValue (this) )
   {
    
     setTimer(FingerPrint,200);
     whichlogin=2;
     putvalue(EnvLogIn4E87,0); // Reset Value for next use
      
   }
    

}

on timer FingerPrint
{
StartDiagService( FINGERPRINT );
}

on timer SeednKeyReq
{
StartDiagService( SEEDNKEYREQUEST );
}

on timer ProgDate
{
StartDiagService( PROGDATE );
}

on envVar EnvRBEOL_1
{
   
   if ( getValue (this) )
   {
        StartDiagService( ACT_PLANT_MODE_1 );
        setTimer(Act_plant_mode,500);
    }
}

on envVar EnvLogInReprog
{


   if ( getValue (this) )
   {
        whichlogin=3;
       StartDiagService( SEEDNKEYREPROGREQUEST );
       putvalue(EnvLogInReprog,0); // Reset Value for next use
   }
  
      
   

}

on envVar EnvActPMode
{
    if ( getValue (this) )
    {
        StartDiagService( P_MODE_ACT_P1 ); //send part 1
        setTimer(ActPMode,200); //wait and send part2
        
        Putvalue(EnvActPMode,0); // Reset Value for next use
    }
}

on envVar EnvSetReadDTC
{
    int i;

    getValue(this,readString);

    if (strlen(readString)!=0) {

        //initialization
        requestSize = getValueSize(EnvSetReadDTC);
        strncpy(DTCValue,"",255);
        readTimeValue=0;
        putValue(EnvErrValueOutput,"");
        for (i=0;i<2048;i++) ErrValue[i]=0;
        write("***At %fs (timer=%ims) request= %s",timeNowFloat()/100000,CNTR_VALUE,readString);

        //start timer at first time
        setTimer(readDtcTimer,CNTR_VALUE);

    } //end if
    //putValue(EnvDirectSend_2,readString);

	//getValue(EnvSetReadDTC,readString);
	if( strlen(readString) == 0 )
	{
		//write("Variable neu initialisiert");
		//putValue(EnvSendBuffer_2,0);
	}
	else
	{
		strncpy(tempString, "0x",3);

		for(i=0; i<= requestSize-3; i+=2)
		{
			tempString[2] = readString[i];
			tempString[3] = readString[i+1];
			tempString[4] = 0;
			readRequest[i/2] = atol( tempString );
		}
		//putValue(EnvTxData_2, TransmitBuffer, length);
		//putValue(EnvTransfer, length);
		//putValue(EnvSendBuffer_2,1);

		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
        TransmitTxBuffer();
	}

    putValue(EnvSetReadDTC,"");

}

on envVar EnvFuncRequest_1
{
	char buffer[201];
	char buffer2[201]="0x";
  	int size, length,i;

 
	getValue( EnvFuncRequest_1, buffer);
	size=getValueSize( EnvFuncRequest_1 );


   if (size >2)   // String not empty, 1Byte minimum
    {  
	    for(i=0; i<= size-3; i+=2)
	    {
		    buffer2[2] = buffer[i];
		    buffer2[3] = buffer[i+1];
		    buffer2[4] = 0;
		    ReqDiagMsgGlobal.byte(1+i/2) = atol( buffer2 );
	    }
	    length = (size - 1)/2;
	    ReqDiagMsgGlobal.byte(0)=length;
	    output(ReqDiagMsgGlobal);
        //getvalue(EnvFuncRequestLast, buffer);
      //  Write ("%s", buffer);
      putvalue (EnvFuncRequest_1,"");
    	putValue( EnvRxData_CAN_1,emptyString,0);
        putValue(EnvRxDataLen_CAN_1,0);
        putvalue (EnvDirectReceive_1,""); // delete old value from receive    

    }
    OSEKTL_SetUseFC( GetValue( EnvUseFC ) );

}

on envVar Env_Get_Signal
{

    char temp[255];
    char numChar[10];
    float value;

    getValue(this,temp);

    if (strlen(temp)>0) {

        //The getSignal(char[]) function needs CANoe7.1 or higher
        value=getSignal(temp);
        ltoa(value,numChar,10);

        putValue(Env_Get_Signal_Result,numChar);
        putValue(Env_Get_Signal,"");
    }


}

on envVar Env_Get_Signal_NotNull
{
	char temp[255];
    char numChar[10];
    float value;

    getValue(this,temp);

    if (strlen(temp) > 0) {

        //The 'getSignal(char[])' function works only with CANoe7.1 or higher
        value=getSignal(temp);
        
		if (0 != value)	{
			
			putValue(Env_Get_Signal_NotNull_Result,"1");
        }

		else {
		
			putValue(Env_Get_Signal_NotNull_Result,"0");
        }

		putValue(Env_Get_Signal_NotNull,"");
		
    }

}

on envVar EnvActivate_EWB_lesen
{
    if(getValue(this)){
        StartDiagService( READ_EWB_ACT);
    }
}

EvaluateIdentifier(int Identifier,int Value)
{

    Switch (Identifier)
    {
    case  EWB_VZE_ID:
        putValue (EnvActivate_EWB_VZE_Value,Value);
    break;
   
    case EWB_VZF_ID:
        putValue (EnvActivate_EWB_VZF_Value,Value);
    break;

    case EWB_EHR_ID:
        putValue (EnvActivate_EWB_EHR_Value,Value);
    break;

     case EWB_HCA_ID:
        putValue (EnvActivate_EWB_HCA_Value,Value);
    break;

    case EWB_MOD_ID:
        putValue (EnvActivate_EWB_MOD_Value,Value);
    break;

     case EWB_FLA_ID:
        putValue (EnvActivate_EWB_FLA_Value,Value);
    break;
            
    case DEACT_CCP_ID:
        putValue (EnvDeactivate_CCP_Value,Value);
    break;
    
    case DEACT_FLA_ID:
        putValue (EnvDeactivate_FLA_Value,Value);
    break;

    case DEACT_VZE_ID:
        putValue (EnvDeactivate_VZE_Value,Value);
    break;

   case BAP_PERS_ID:
        putValue (EnvActivate_BAP_Pers_Value,Value);
    break;

 

    
    
     
  
    }
}

on envVar EnvDeactivate_Functions_lesen
{
    if(getValue(this)){
        StartDiagService( READ_DEACT_FUNC );
    }
}

on envVar EnvDeactivate_FLA_schreiben
{
    if(getValue(this)){
        StartDiagService( DEACT_FUNC_FLA);
    }            
}

on envVar EnvDeactivate_CCP_schreiben
{
    if(getValue(this)){
        StartDiagService( DEACT_FUNC_CCP);
    }
}

on envVar EnvDeactivate_VZE_schreiben
{
    if(getValue(this)){
        StartDiagService( DEACT_FUNC_VZE);
    }
}

on envVar Env_Compare_Signal_2
{

    char temp_1[255];
    char temp_2[255];
    char numChar[10];
    float value_1;
    float value_2;

    getValue(Env_Compare_Signal_1,temp_1);
    getValue(this,temp_2);

    //putValue(Env_Compare_Signal_Results,"Error");

    if ((strlen(temp_1)>0) && (strlen(temp_2)>0)) {

        //The getSignal(char[]) function needs CANoe7.1 or higher
        value_1=getSignal(temp_1);
        value_2=getSignal(temp_2);

        write( "%s = %f",temp_1, value_1 );
        write( "%s = %f",temp_2, value_2 );
        write("-------------------------");

        if( value_1 == value_2 )
        {
            putValue(Env_Compare_Signal_Results,"1");
        }
        else
        {
            putValue(Env_Compare_Signal_Results,"0");
        }

        putValue(Env_Compare_Signal_1,"");
        putValue(Env_Compare_Signal_2,"");
        
    }

}

on envVar Env_Get_Signal_Signum
{
    char signalname[255];
    float value = 0;

    if (getValue (this, signalname)) {
        value = getSignal (signalname);
        if (value < 0) {
            putValue (Env_Get_Signal_Signum_Result, "-");
            write ("INFO: Env_Get_Signal_Signum is negative.");
        }
        else if (value > 0)
        {
            putValue (Env_Get_Signal_Signum_Result, "+");
            write ("INFO: Env_Get_Signal_Signum is positive.");
        }
        else {
            putValue (Env_Get_Signal_Signum_Result, "Z");
            write ("INFO: Env_Get_Signal_Signum is zero.");
        }
    }
    putValue(Env_Get_Signal,"");
}

on envVar Env_Get_Signal_Float
{

    char temp[255];
    char numChar[10];
    float value;

    if (getValue(this,temp)) {

        //The getSignal(char[]) function needs CANoe7.1 or higher
        value=getSignal(temp);

        putValue(Env_Get_Signal_Float_Result,value);
        putValue(Env_Get_Signal_Float,"");
    }
}

on envVar Env_Get_Signal_Alter
{
    char signalname[255];
    float value1 = 0;
    float value2 = 0;

    if (getValue (this, signalname)) {
        value1 = getValue (Env_Get_Signal_Float_Result);
        value2 = getSignal (signalname);
        write ("INFO: Old value = %4.4f", value1);
        write ("INFO: New value = %4.4f", value2);

        if (value2 < value1) {
            putValue (Env_Get_Signal_Alter_Result, "-");
            write ("INFO: Alteration is negative.");
        }
        else if (value2 > value1)
        {
            putValue (Env_Get_Signal_Alter_Result, "+");
            write ("INFO: Alteration is positive.");
        }
        else {
            putValue (Env_Get_Signal_Alter_Result, "Z");
            write ("INFO: Alteration is zero.");
        }
    }
    putValue (this, "");
}

on envVar EnvPrepare_Write
{
    if ( getValue (this) )
    {
        StartDiagService(PRE_WRITE);
    }
}

on envVar EnvActivate_EWB_VZE_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWB_VZE);
    }
}

on envVar EnvActivate_EWB_VZF_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWB_VZF);
    }
}

on envVar EnvActivate_EWB_EHR_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWB_EHR);
    }
}

on envVar EnvActivate_EWB_MOD_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWB_MOD);
    }       
}

on envVar EnvActivate_EWB_HCA_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWB_HCA);
    }
}

on envVar EnvActivate_EWB_FLA_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWB_FLA);
    }
}

on envVar EnvMaskErrorReactDev_lesen
{
    if(getValue(this)){
        StartDiagService( READ_MASK_ERR_RCTN);
    }
}

on envVar EnvMaskErrorReactDev_schreiben
{
    if(getValue(this)){
        StartDiagService( WRITE_MASK_ERR_RCTN);
    }
}

on envVar EnvMaskFaultClasses_lesen
{
    if(getValue(this)){
        StartDiagService( READ_MASK_FAULT_CLASS);
    }
}

on envVar EnvMaskFaultClasses_schreiben
{
    if(getValue(this)){
        StartDiagService( WRITE_MASK_FAULT_CLASS);
    }
}

on envVar EnvActivate_BAP_Pers_schreiben
{
    if(getValue(this)){
        StartDiagService( WRITE_BAP_PERS);
    }
}

on envVar EnvActivate_BAP_Pers_lesen
{
    if(getValue(this)){
         StartDiagService( READ_BAP_PERS);
    }
}

on envVar EnvV_Schwelle_FLA_ein_lesen
{
    if(getValue(this)){
        StartDiagService( READ_V_THRESHOLD_MAINBEAM_ON);
    }
}

on envVar EnvV_Schwelle_FLA_ein_schreiben
{
    if(getValue(this)){
        StartDiagService( WRITE_V_THRESHOLD_MAINBEAM_ON);
    }
}

on envVar EnvV_Schwelle_FLA_aus_lesen
{
    if(getValue(this)){
        StartDiagService( READ_V_THRESHOLD_MAINBEAM_OFF);
    }
}

on envVar EnvV_Schwelle_FLA_aus_schreiben
{
    if(getValue(this)){
        StartDiagService( WRITE_V_THRESHOLD_MAINBEAM_OFF);
    }
}

on envVar EnvActivate_BAP_HCA_Einschalt_schreiben
{
    if(getValue(this)){
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x2E;
        TxDataBuffer[1] = 0x05;
        TxDataBuffer[2] = 0x41; 
        TxDataBuffer[3] = getValue(EnvActivate_BAP_HCA_Einschalt_Value); 
        TxLength= 4; 
        TransmitTxBuffer();
    }
}

on envVar EnvActivate_BAP_HCA_StWheelVibration_schreiben
{
    if(getValue(this)){
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x2E;
        TxDataBuffer[1] = 0x05;
        TxDataBuffer[2] = 0x43; 
        TxDataBuffer[3] = getValue(EnvActivate_BAP_HCA_StWheelVibration_Value); 
        TxLength= 4; 
        TransmitTxBuffer();
    }
}

on envVar EnvActivate_BAP_HCA_WarningTime_schreiben
{
    if(getValue(this)){
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x2E;
        TxDataBuffer[1] = 0x3B;
        TxDataBuffer[2] = 0x61; 
        TxDataBuffer[3] = getValue(EnvActivate_BAP_HCA_WarningTime_Value); 
        TxLength= 4; 
        TransmitTxBuffer();
    }
}

on envVar EnvActivate_BAP_HCA_Systemmode_schreiben
{
    if(getValue(this)){
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x2E;
        TxDataBuffer[1] = 0x05;
        TxDataBuffer[2] = 0x42; 
        TxDataBuffer[3] = getValue(EnvActivate_BAP_HCA_Systemmode_Value); 
        TxLength= 4; 
        TransmitTxBuffer();
    }
}

on envVar EnvActivate_BAP_HCA_Einschalt_lesen
{
    if(getValue(this)){ // press
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x22;
        TxDataBuffer[1] = 0x05;
        TxDataBuffer[2] = 0x41; 
        TxLength= 3; 
        TransmitTxBuffer();
    }
    else{ // release
        putValue(EnvActivate_BAP_HCA_Einschalt_Value, RxDataBuffer[3]);
    }
}

on envVar EnvActivate_BAP_HCA_StWheelVibration_lesen
{
    if(getValue(this)){ // press
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x22;
        TxDataBuffer[1] = 0x05;
        TxDataBuffer[2] = 0x43; 
        TxLength= 3; 
        TransmitTxBuffer();
    }
    else{ // release
        putValue(EnvActivate_BAP_HCA_StWheelVibration_Value, RxDataBuffer[3]);
    }
}

on envVar EnvActivate_BAP_HCA_Systemmode_lesen
{
    if(getValue(this)){ // press
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x22;
        TxDataBuffer[1] = 0x05;
        TxDataBuffer[2] = 0x42; 
        TxLength= 3; 
        TransmitTxBuffer();
    }
    else{ // release
        putValue(EnvActivate_BAP_HCA_Systemmode_Value, RxDataBuffer[3]);
    }
}

on envVar EnvActivate_BAP_HCA_WarningTime_lesen
{
    if(getValue(this)){ // press
        putValue (EnvReqStatus_CAN_1, "...");
        putValue (EnvRespTime_CAN_1, 0.0);
        TxDataBuffer[0] = 0x22;
        TxDataBuffer[1] = 0x3B;
        TxDataBuffer[2] = 0x61; 
        TxLength= 3; 
        TransmitTxBuffer();
    }
    else{ // release
        putValue(EnvActivate_BAP_HCA_WarningTime_Value, RxDataBuffer[3]);
    }
}

on envVar EnvMinicode_Plant
{


   if ( getValue (this) )
   {
        whichlogin=5;
        setTimer(FingerPrint,0);
     //  StartDiagService( MINICODEREQUEST );
       putvalue(this,0); // Reset Value for next use
   }
  
      
   

}

on envVar EnvMinicode_Dev
{


   if ( getValue (this) )
   {
        whichlogin=6;
        setTimer(FingerPrint,0);
       // StartDiagService( MINICODEREQUEST );
       putvalue(this,0); // Reset Value for next use
   }
  
      
   

}

void ParseSecurityXML(char nameOfFile[])
{
  dword fileHandle;
  char buffer[10000];
  char FileBuffer[150000];
  int filePos;
  int key_type = 0;
  int staticPosStart;
  int staticPosEnd;
  char staticBuffer[50000];
  int seedPosStart;
  int seedPosEnd;
  int staticPos=0;
  int i;
  
  fileHandle =  openFileRead (nameOfFile,0);
  while (fileGetStringSZ(buffer,elcount(buffer),fileHandle)!=0)
  {
    strncat(FileBuffer, buffer, elcount(FileBuffer));
  }
  fileClose (fileHandle);
  if(strstr(FileBuffer,"0x61\" key_type=\"static")!=-1)
  {
    filePos = strstr(FileBuffer,"dia_sub_function=\"0x61\" encrypted=\"no\"");
    if(filePos!=-1)
    {
      staticPosStart = strstr_off(FileBuffer,filePos,"<SEEDS>")+7;
      staticPosEnd = strstr_off(FileBuffer,filePos,"</KEYS>");
      substr_cpy(staticBuffer, FileBuffer, staticPosStart,staticPosEnd-staticPosStart,elcount(staticBuffer));
	    i=0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<SEED>")+6;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</SEED>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(seedList[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(seedList));
        i++;
        staticPos = seedPosEnd;
		
      }
      i=0;
	    staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<KEY>")+5;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</KEY>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(keyList[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(keyList));
        i++;
        staticPos = seedPosEnd;
		
      }
    }
    
    securityType = SEEDNKEYFBLREQUEST;
    
    
  }
  else if(strstr(FileBuffer,"0x61\" key_type=\"dynamic")!=-1)
  {
    securityType = SEEDNKEYFBLDYNAMICREQUEST;
  }
  else if(strstr(FileBuffer,"0x61\" key_type=\"conventional")!=-1)
  {
    securityType = SEEDNKEYREQUEST;
  }
  else
  {
    write("The Security XML is not as per standards. Conventional mode is active");
  }
  
  //****** For JLR Security Unlock *******
  if(strstr(FileBuffer,"0x01\" key_type=\"static")!=-1)
  {
    filePos = strstr(FileBuffer,"dia_sub_function=\"0x01\" encrypted=\"no\"");
    if(filePos!=-1)
    {
      staticPosStart = strstr_off(FileBuffer,filePos,"<SEEDS>")+7;
      staticPosEnd = strstr_off(FileBuffer,filePos,"</KEYS>");
      substr_cpy(staticBuffer, FileBuffer, staticPosStart,staticPosEnd-staticPosStart,elcount(staticBuffer));
	    i=0;
      staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<SEED>")+6;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</SEED>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(seedListJLR[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(seedListJLR));
        i++;
        staticPos = seedPosEnd;
		
      }
      i=0;
	  staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<KEY>")+5;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</KEY>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(keyListJLR[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(keyListJLR));
        i++;
        staticPos = seedPosEnd;
		
      }
    }
    
    securityTypeJLR = SEEDNKEYJLREOLREQUEST;
    
  }
  else if(strstr(FileBuffer,"0x01\" key_type=\"dynamic")!=-1)
  {
    securityTypeJLR = SEEDNKEYJLRDYNAMICREQUEST;
  }
  else if(strstr(FileBuffer,"0x01\" key_type=\"conventional")!=-1)
  {
    securityTypeJLR = SEEDNKEYJLRREQUEST;
  }
  else
  {
    write("The Security XML is not as per standards. Conventional mode is active");
  }
  
  
  
}

CalculateKey (dword SeedValue,dword RBA_CBB_AKEY_VALUE, dword RBA_CBB_BKEY_VALUE, dword RBA_CBB_CKEY_VALUE, dword RBA_CBB_DKEY_VALUE)
{

        int      j;
        dword    keytemp;
      
        
        	keyReprogValue = SeedValue;

        	for(j = 0; j <8 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + RBA_CBB_AKEY_VALUE;
	       		// write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		/* Rotate Right by 10 */
 	       			keyLowReprogValue = keyReprogValue & (0x000001FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 23;
 	    			keyReprogValue = keyReprogValue >> 9;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       				keyReprogValue = keyReprogValue ^ RBA_CBB_BKEY_VALUE;

             	}
    			else
    			{
 	    		/* Rotate Left by 13 */
 	    		    keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			        keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		       		keyReprogValue      = keyReprogValue ^ RBA_CBB_CKEY_VALUE;

                }
           }
 
           keyReprogValue = keyReprogValue - RBA_CBB_DKEY_VALUE;
              
           
            /* Key Algo end */
			 //   write(" final  keyReprogValue %lx",keyReprogValue ); 
}

on timer ActPMode
{
    StartDiagService( P_MODE_ACT_P2 );
}

on timer MinicodeReq
{
    StartDiagService( MINICODEREQUEST );
}
on timer Act_plant_mode
{
           StartDiagService( ACT_PLANT_MODE_2 );
  
}
on timer sectimer1
{
  putValue(Env_Doip_SecurityMode_Output_1,"");
  setTimer(sectimer2,500);
}
on timer sectimer2
{
  putValue(Env_Doip_SecurityMode_Output_1,"Click the button to enter dynamic Key");
  setTimer(sectimer1,1000);
}


on envVar EnvPrepare_Write_Minicode
{
    if ( getValue (this) )
    {
        StartDiagService(PRE_WRITE_MINICODE);
    }
}

on envVar EnvLogInReprogWriteKey
{


   if ( getValue (this) )
   {
        whichlogin=3;
       StartDiagService( SEEDNKEYREPROGREQUESTWRITEKEY );
       putvalue(EnvLogInReprogWriteKey,0); // Reset Value for next use
   }
  
      
   

}

on envVar EnvActivate_EWBs_schreiben
{
    if(getValue(this)){
        StartDiagService( ACT_EWBs);
    }
}
//on timer secur
//{
//     StartDiagService( SEEDNKEYREQUESTUNLOCKONE );
//}

on envVar EnvLogInLevel1_1
{
                   
    if ( getValue (this) )
   {
     whichlogin=4;
     StartDiagService( SEEDNKEYREQUESTUNLOCKONE );
     //putvalue(EnvRBEOL_1,0); // Reset Value for next use
  
    }
}

on envVar EnvLogInLevel2_1
{
                   
    if ( getValue (this) )
   {
     whichlogin=4;
     StartDiagService( SEEDNKEYREQUESTUNLOCKTWO );
     //putvalue(EnvRBEOL,0); // Reset Value for next use
  
    }
}
on envVar Env_ActPMode_1_1
{
  
       if(getValue(this))
      {
        StartDiagService(ACT_PLANT_MODE_1);
      }
  
}

on envVar Env_ActPMode_2_1
{
  
       if(getValue(this))
      {
        StartDiagService(ACT_PLANT_MODE_2);
      }
  
}

On envVar Env_Security_Dynamic_Unlock_1
{
  if(getValue(this))
  {
    DynamicKeySend();
  }
}

on envVar Env_Security_DynamicInput_1
{
  //DynamicKeySend();
}

// CA RBEOL security unlock
on envVar Env_MPC3_EOL_unlock_1
{
   if ( getValue (this) )
    {
      //getValue(Env_Doip_Security_SubFunction_1,SecurityBuffer);
      SecurityBuffer[0]=0x61;
      SeednKeyFBLRequest[1] = SecurityBuffer[0];
      if(securityType == SEEDNKEYFBLDYNAMICREQUEST)
      {
        putValue(Env_Doip_SecurityMode_Output_1,"Dynamic Security Mode");
        StartDiagService( SEEDNKEYFBLDYNAMICREQUEST );
      }
      else if(securityType == SEEDNKEYFBLREQUEST)
      {
        putValue(Env_Doip_SecurityMode_Output_1,"Static Security Mode");
        StartDiagService( SEEDNKEYFBLREQUEST );
      }
      else
      {
        putValue(Env_Doip_SecurityMode_Output_1,"Conventional Security Mode");
        StartDiagService( SEEDNKEYREQUEST );
      }
    }
}

On envVar Dynamic_Unlock_1
{
  if (getValue(this))
  {
    putValue(Env_Doip_SecurityMode_Output_1, "Dynamic Security Mode");
    StartDiagService(SEEDNKEYFBLDYNAMICREQUEST);
  }
}




void DynamicKeySend()
{
  if(DynamicFlag == 1 ||DynamicFlag == 2)
  {
    cancelTimer(sectimer1);
    cancelTimer(sectimer2);
    putValue(Env_Doip_SecurityMode_Output_1,"Dynamic Security Mode Active");
    dynamicKeyLen = getValue(Env_Security_DynamicInput_1,DynamicKey);
    sendKey[0]=0x27;
    if(DynamicFlag == 1)
    {
      sendKey[1]=SeednKeyFBLRequest[1]+1;
    }
    else if(DynamicFlag == 2)
    {
      sendKey[1]=SeednKeyJLREOLRequest[1]+1;
    }
    k=2;  
    
    strncpy(temp1, "0x",3);
    
    for(j=0;j<dynamicKeyLen;j+=2)
    {
      temp1[2]=DynamicKey[j];
      temp1[3]=DynamicKey[j+1];
      temp1[4]=0;
      sendKey[k]=atol(temp1);
      k++;
     // write("%d",k);
    }
    
    TxLength = (dynamicKeyLen/2)+2;
    StartDiagService( SEEDNKEYJLRRESP);
   
    DynamicFlag = 0;
    putValue(Env_Security_DynamicInput_1,"");
  }
  
}
Display_DTC_MID_Name (dword error)
{
switch(error)
    {
    case 0xA20016:
        putValue (EnvDtcName_2, "Control Module Input Power Low");
        putValue (EnvMidName, "Control Module Input Power Low");
	  break;
     case 0xA20B17:
        putValue (EnvDtcName_2, "DTC_ECU_INTERNAL_VOLTAGE_HIGH");
        putValue (EnvMidName, "DTC_ECU_INTERNAL_VOLTAGE_HIGH");
	  break;
     case 0xA20B16:
        putValue (EnvDtcName_2, "DTC_ECU_INTERNAL_VOLTAGE_LOW");
        putValue (EnvMidName, "DTC_ECU_INTERNAL_VOLTAGE_LOW");
	  break;
    case 0xA20C45:
        putValue (EnvDtcName_2, "DTC_ECU_SW_FAILURE");
        putValue (EnvMidName, "DTC_ECU_SW_FAILURE");
	  break;
    case 0xA20D54:
        putValue (EnvDtcName_2, "DTC_ECU_SW_TEMPORARY_FAILURE");
        putValue (EnvMidName, "DTC_ECU_SW_TEMPORARY_FAILURE");
	  break;
    case 0xA20E60:
        putValue (EnvDtcName_2, "DTC_ECU_TEMPERATURE_OVER_MAXIMUM");
        putValue (EnvMidName, "DTC_ECU_TEMPERATURE_OVER_MAXIMUM");
	  break;
    case 0xA20F32:
        putValue (EnvDtcName_2, "DTC_CALIBRATION_INPUT_FAILURE");
        putValue (EnvMidName, "DTC_CALIBRATION_INPUT_FAILURE");
	  break;
    case 0xA20117:
        putValue (EnvDtcName_2, "Control Module Input Power High");
        putValue (EnvMidName, "Control Module Input Power High");
	  break;
	  
    case 0xD78088:
        putValue (EnvDtcName_2, "Private CAN BUSOFF");
        putValue (EnvMidName, "Private CAN BUSOFF");
	  break;
	  case 0xD78188:
        putValue (EnvDtcName_2, "Public CAN BUSOFF");
        putValue (EnvMidName, "Public CAN BUSOFF");
	  break;
  case 0xD78287:
        putValue (EnvDtcName_2, "Lost Communication with SAS");
        putValue (EnvMidName, "Lost Communication with SAS");
	  break;
	  case 0xD78283:
        putValue (EnvDtcName_2, "SAS_CRCCheck failure");
        putValue (EnvMidName, "SAS_CRCCheck failure");
	  break;
	  case 0xD78282:
        putValue (EnvDtcName_2, "SAS_RollingCounter failure");
        putValue (EnvMidName, "SAS_RollingCounter failure");
	  break;
	  case 0xD78387:
        putValue (EnvDtcName_2, "Lost Communication with ESP");
        putValue (EnvMidName, "Lost Communication with ESP");
	  break;
    case 0xD78386:
        putValue (EnvDtcName_2, " ESP_DLC_Failure");
        putValue (EnvMidName, " ESP_DLC_Failure");
	  break;
	  case 0xD78383:
        putValue (EnvDtcName_2, "ESP_CRCCheck failure");
        putValue (EnvMidName, "ESP_CRCCheck failure");
	  break;
	  case 0xD78382:
        putValue (EnvDtcName_2, "ESP_RollingCounter failure");
        putValue (EnvMidName, "ESP_RollingCounter failure");
	  break;
	  case 0xD78487:
        putValue (EnvDtcName_2, "Lost Communication with TCU");
        putValue (EnvMidName, "Lost Communication with TCU");
	  break;
	  case 0xD78483:
        putValue (EnvDtcName_2, "TCU_CRCCheck failure");
        putValue (EnvMidName, "TCU_CRCCheck failure");
	  break;
	  case 0xD78482:
        putValue (EnvDtcName_2, "TCU_RollingCounter failure");
        putValue (EnvMidName, "TCU_RollingCounter failure");
	  break;
	  case 0xD78587:
        putValue (EnvDtcName_2, "Lost Communication with EMS");
        putValue (EnvMidName, "Lost Communication with EMS");
	  break;
	  case 0xD78583:
        putValue (EnvDtcName_2, "EMS_CRCCheck failure");
        putValue (EnvMidName, "EMS_CRCCheck failure");
	  break;
	  case 0xD78582:
        putValue (EnvDtcName_2, "EMS_RollingCounter failure");
        putValue (EnvMidName, "EMS_RollingCounter failure");
	  break;
	  case 0xD78687:
        putValue (EnvDtcName_2, "Lost Communication with EPS");
        putValue (EnvMidName, "Lost Communication with EPS");
	  break;
	  case 0xD78683:
        putValue (EnvDtcName_2, "EPS_CRCCheck failure");
        putValue (EnvMidName, "EPS_CRCCheck failure");
	  break;
	  case 0xD78682:
        putValue (EnvDtcName_2, "EPS_RollingCounter failure");
        putValue (EnvMidName, "EPS_RollingCounter failure");
	  break;
	  case 0xD78787:
        putValue (EnvDtcName_2, "Lost Communication with HU");
        putValue (EnvMidName, "Lost Communication with HU");
	  break;
	  case 0xD78783:
        putValue (EnvDtcName_2, "HU_CRCCheck failure");
        putValue (EnvMidName, "HU_CRCCheck failure");
	  break;
	  case 0xD78782:
        putValue (EnvDtcName_2, "HU_RollingCounter failure");
        putValue (EnvMidName, "HU_RollingCounter failure");
	  break;
      case 0xD79087:
         putValue (EnvDtcName_2, "Lost Communication with IMS");
         putValue (EnvMidName, "Lost Communication with IMS");
		break;
    

    case 0xD79287:
        putValue (EnvDtcName_2, "Lost Communication with MFS");
        putValue (EnvMidName, "Lost Communication with MFS");
	  break;
    case 0xD79283:
        putValue (EnvDtcName_2, "GW_MFS_CRCCheck failure");
        putValue (EnvMidName, "GW_MFS_CRCCheck failure");
	  break;
    case 0xD79282:
        putValue (EnvDtcName_2, "GW_MFS_RollingCounter failure");
        putValue (EnvMidName, "GW_MFS_RollingCounter failure");
	  break;
    case 0xD79387:
        putValue (EnvDtcName_2, "Lost Communication with LCDAR");
        putValue (EnvMidName, "Lost Communication with LCDAR");
	  break;
     case 0xD79383:
        putValue (EnvDtcName_2, "LCDAR_CRCCheck failure");
        putValue (EnvMidName, "LCDAR_CRCCheck failure");
	  break;
    case 0xD79382:
        putValue (EnvDtcName_2, "LCDAR_RollingCounter failure");
        putValue (EnvMidName, "LCDAR_RollingCounter failure");
	  break;
     case 0xD79487:
        putValue (EnvDtcName_2, "Lost Communication with SRS");
        putValue (EnvMidName, "Lost Communication with SRS");
	  break;
    case 0xD79587:
        putValue (EnvDtcName_2, "Lost Communication with BCM");
        putValue (EnvMidName, "Lost Communication with BCM");
	  break;
     case 0xD79187:
        putValue (EnvDtcName_2, "Lost Communication with MRR(Private CAN)");
        putValue (EnvMidName, "Lost Communication with MRR(Private CAN)");
	  break;
    case 0xD79186:
        putValue (EnvDtcName_2, "MRR DLC Failure");
        putValue (EnvMidName, "MRR DLC Failure");
	  break;
    case 0xD79183:
        putValue (EnvDtcName_2, "MRR(Private CAN)_CRCCheck failure");
        putValue (EnvMidName, "MRR(Private CAN)_CRCCheck failure");
	  break;
    case 0xD79182:
        putValue (EnvDtcName_2, "MRR_RollingCounter failure");
        putValue (EnvMidName, "MRR_RollingCounter failure");
	  break;
    
	  case 0xD783F0:
        putValue (EnvDtcName_2, "ESP speed is invalid");
        putValue (EnvMidName, "ESP speed is invalid");
	  break;
	  case 0xD783F2:
        putValue (EnvDtcName_2, "ESP wheel speed direction data is invalid");
        putValue (EnvMidName, "ESP wheel speed direction data is invalid");
	  break;
	  case 0xD783F3:
        putValue (EnvDtcName_2, "ESP wheel speed valid data signal is Invalid");
        putValue (EnvMidName, "ESP wheel speed valid data signal is Invalid");
	  break;
	  case 0xD783F4:
        putValue (EnvDtcName_2, "ESP Wheel speed pulse signal Invalid");
        putValue (EnvMidName, "ESP Wheel speed pulse signal Invalid");
	  break;
	  case 0xD783F5:
        putValue (EnvDtcName_2, "YawRate signal is invalid");
        putValue (EnvMidName, "YawRate signal is invalid");
	  break;
	  case 0xD783F6:
        putValue (EnvDtcName_2, "MasCylBrakePressure is invalid");
        putValue (EnvMidName, "MasCylBrakePressure is invalid");
	  break;
	  case 0xD783F7:
        putValue (EnvDtcName_2, "ESP_LatAccel signal is invalid");
        putValue (EnvMidName, "ESP_LatAccel signal is invalid");
	  break;
	  case 0xD783F8:
        putValue (EnvDtcName_2, "ESP_LongAccel signal is invalid");
        putValue (EnvMidName, "ESP_LongAccel signal is invalid");
	  break;
    case 0xD783F9:
        putValue (EnvDtcName_2, "ESP_TCSFailStatus is invalid");
        putValue (EnvMidName, "ESP_TCSFailStatus is invalid");
	  break;
	  case 0xD785F0:
        putValue (EnvDtcName_2, "EMS_EngineSpeed signal is invalid");
        putValue (EnvMidName, "EMS_EngineSpeed signal is invalid");
	  break;
	  case 0xD785F1:
        putValue (EnvDtcName_2, "EMS_AccPedal signal is invalid");
        putValue (EnvMidName, "EMS_AccPedal signal is invalid");
	  break;
     case 0xD785F2:
        putValue (EnvDtcName_2, "EMS_EngineStatus signal is invalid");
        putValue (EnvMidName, "EMS_EngineStatus signal is invalid");
	  break;
	  case 0xD784F0:
        putValue (EnvDtcName_2, "TCU_ShiftinProgressValid signal is invalid");
        putValue (EnvMidName, "TCU_ShiftinProgressValid signal is invalid");
	  break;
	  case 0xD784F1:
        putValue (EnvDtcName_2, "GearShiftPosition is invalid");
        putValue (EnvMidName, "GearShiftPosition is invalid");
	  break;
	  case 0xD784F2:
        putValue (EnvDtcName_2, "TCU ActualGear Signal is Invalid");
        putValue (EnvMidName, "TCU ActualGear Signal is Invalid");
	  break;
	  case 0xD782F0:
        putValue (EnvDtcName_2, "SAS_SASFailure signal is invalid");
        putValue (EnvMidName, "SAS_SASFailure signal is invalid");
	  break;
	  case 0xD782F1:
        putValue (EnvDtcName_2, "SteeringAngle is invalid");
        putValue (EnvMidName, "SteeringAngle is invalid");
	  break;
	  case 0xD782F2:
        putValue (EnvDtcName_2, "SAS_Calibrated signal is invalid");
        putValue (EnvMidName, "SAS_Calibrated signal is invalid");
	  break;
	  case 0xD782F3:
        putValue (EnvDtcName_2, "SAS_TrimmingSts is invalid");
        putValue (EnvMidName, "SAS_TrimmingSts is invalid");
	  break;
	  case 0xD782F4:
        putValue (EnvDtcName_2, "SAS_SteeringAngleSpeed signal is invalid");
        putValue (EnvMidName, "SAS_SteeringAngleSpeed signal is invalid");
	  break;
	  case 0xD787F0:
        putValue (EnvDtcName_2, "HU_NavSpeedLimit signal invalid ");
        putValue (EnvMidName, "HU_NavSpeedLimit signal invalid ");
	  break;
    case 0xD787F1:
        putValue (EnvDtcName_2, "HU_SpeedLimitDistance signal invalid ");
        putValue (EnvMidName, "HU_SpeedLimitDistance signal invalid ");
	  break;
	  case 0xD788F0:
        putValue (EnvDtcName_2, "BCM_LowBeamStatus signal is invalid");
        putValue (EnvMidName, "BCM_LowBeamStatus signal is invalid");
	  break;
	  case 0xD788F1:
        putValue (EnvDtcName_2, "BCM_HighBeamStatus signal is invalid");
        putValue (EnvMidName, "BCM_HighBeamStatus signal is invalid");
	  break;
	  case 0xD788F2:
        putValue (EnvDtcName_2, "BCM_FrontFoglampStatus signal is invalid");
        putValue (EnvMidName, "BCM_FrontFoglampStatus signal is invalid");
	  break;
	  case 0xD788F3:
        putValue (EnvDtcName_2, "BCM_AutoHeadlightSts signal is invalid");
        putValue (EnvMidName, "BCM_AutoHeadlightSts signal is invalid");
	  break;
    case 0xD786F0:
        putValue (EnvDtcName_2, "EPS_MinSafetyTorsionBarTorq signal is invalid");
        putValue (EnvMidName, "EPS_MinSafetyTorsionBarTorq signal is invalid");
	  break;
    case 0xD786F2:
        putValue (EnvDtcName_2, "EPS_ActualTorsionBarTorq signal is invalid");
        putValue (EnvMidName, "EPS_ActualTorsionBarTorq signal is invalid");
	  break;
    case 0xD786F3:
        putValue (EnvDtcName_2, "EPS_MeasuredTorsionBarTorque signal is invalid");
        putValue (EnvMidName, "EPS_MeasuredTorsionBarTorque signal is invalid");
	  break;
    case 0xD786F5:
        putValue (EnvDtcName_2, "EPS_LatCtrlAvailabilityStatus signal is invalid");
        putValue (EnvMidName, "EPS_LatCtrlAvailabilityStatus signal is invalid");
	  break;
    case 0xD786F7:
        putValue (EnvDtcName_2, "EPS_ConcussAvailabilityStatus signal is invalid");
        putValue (EnvMidName, "EPS_ConcussAvailabilityStatus signal is invalid");
	  break;
    case 0xD790F0:
        putValue (EnvDtcName_2, "IMS_DistractionStatus signal is invalid");
        putValue (EnvMidName, "IMS_DistractionStatus signal is invalid");
	  break;
    case 0xD790F2:
        putValue (EnvDtcName_2, "IMS_DrowsinessStatus is invalid");
        putValue (EnvMidName, "IMS_DrowsinessStatus is invalid");
	  break;
    case 0xD790F5:
        putValue (EnvDtcName_2, "IMS_IMSStatus is invalid");
        putValue (EnvMidName, "IMS_IMSStatus is invalid");
	  break;
    case 0xD792F0:
        putValue (EnvDtcName_2, "GW_MFS_IACCenable_switch_signal is invalid");
        putValue (EnvMidName, "GW_MFS_IACCenable_switch_signal is invalid");
	  break;
    case 0xD792F1:
        putValue (EnvDtcName_2, "GW_MFS_DiagInfoSW_28C is invalid");
        putValue (EnvMidName, "GW_MFS_DiagInfoSW_28C is invalid");
	  break;
     case 0xD791F0:
        putValue (EnvDtcName_2, "Invalid Data Received From MRR(Private CAN)");
        putValue (EnvMidName, "Invalid Data Received From MRR(Private CAN)");
	  break;
	  case 0xA20297:
        putValue (EnvDtcName_2, "DTC_Sensor_blindness_failure");
        putValue (EnvMidName, "DTC_Sensor_blindness_failure");
	  break;
	  case 0xA20398:
        putValue (EnvDtcName_2, "DTC_ECU_Temperature_Over_Operation");
        putValue (EnvMidName, "DTC_ECU_Temperature_Over_Operation");
	  break;
	  case 0xA20649:
        putValue (EnvDtcName_2, "DTC_ECU_INTERNAL_HW_FAILURE");
        putValue (EnvMidName, "DTC_ECU_INTERNAL_HW_FAILURE");
	  break;
	  case 0xA20762:
        putValue (EnvDtcName_2, "DTC_DATASET_ERROR");
        putValue (EnvMidName, "DTC_DATASET_ERROR");
	  break;
	  case 0xA20855:
        putValue (EnvDtcName_2, "DTC_Vehicle_Configuration_Failure");
        putValue (EnvMidName, "DTC_Vehicle_Configuration_Failure");
	  break;
	  case 0x52F449:
        putValue (EnvDtcName_2, "DTC_Internal_electronic_failure");
        putValue (EnvMidName, "DTC_Internal_electronic_failure");
	  break;
	  case 0xA20949:
        putValue (EnvDtcName_2, "DTC_ECU_SUPERVISION_FAILURE");
        putValue (EnvMidName, "DTC_ECU_SUPERVISION_FAILURE");
	  break;
	  case 0xA20A84:
        putValue (EnvDtcName_2, "DTC_CALIBRATION_ONLINE_OUT_OF_RANGE");
        putValue (EnvMidName, "DTC_CALIBRATION_ONLINE_OUT_OF_RANGE");
	  break;
	  case 0xA20A85:
        putValue (EnvDtcName_2, "DTC_CALIBRATION_INITIAL_OUT_OF_RANGE");
        putValue (EnvMidName, "DTC_CALIBRATION_INITIAL_OUT_OF_RANGE");
	  break;
	  case 0xA20A63:
        putValue (EnvDtcName_2, "DTC_CALIBRATION_RUNTIME_FAILURE");
        putValue (EnvMidName, "DTC_CALIBRATION_RUNTIME_FAILURE");
	  break;
	  case 0xA20A54:
        putValue (EnvDtcName_2, "DTC_MISSING_CALIBRATION");
        putValue (EnvMidName, "DTC_MISSING_CALIBRATION");
	  break;
	  case 0xA20697:
        putValue (EnvDtcName_2, "DTC_Temporary_blindness_failure");
        putValue (EnvMidName, "DTC_Temporary_blindness_failure");
	  break;
   case 0xD79083:
        putValue (EnvDtcName_2, "IMS_CRCCheck failure");
        putValue (EnvMidName, "IMS_CRCCheck_failure");
	  break;	
	case 0xD79082:
        putValue (EnvDtcName_2, "IMS_RollingCounter failure");
        putValue (EnvMidName, "IMS_RollingCounter failure");
	  break;		  
	//case 0xD79087:
      //putValue (EnvDtcName_2, "FAULT_ov_net_IMS_0x356_TO_Failure");
      //putValue (EnvMidName, "FAULT_ov_net_IMS_0x356_TO_Failure");
	  //break;
	case 0xD79687:
        putValue (EnvDtcName_2, "Lost Communication with IB");
        putValue (EnvMidName, "Lost Communication with IB");
	  break;
	case 0xD79987:
        putValue (EnvDtcName_2, "Lost Communication with CDC");
        putValue (EnvMidName, "Lost Communication with CDC");
	  break;
	case 0xD78987:
        putValue (EnvDtcName_2, "Lost Communication with VCU");
        putValue (EnvMidName, "Lost Communication with VCU");
	  break;
	case 0xD79583:
        putValue (EnvDtcName_2, "BCM_CRCCheck failure");
        putValue (EnvMidName, "BCM_CRCCheck failure");
	  break;
	case 0xD79683:
        putValue (EnvDtcName_2, "IB_CRCCheck Failure");
        putValue (EnvMidName, "IB_CRCCheck Failure");
	  break;
	case 0xD79983:
        putValue (EnvDtcName_2, "CDC_CRCCheck failure");
        putValue (EnvMidName, "CDC_CRCCheck failure");
	  break;
	case 0xD78983:
        putValue (EnvDtcName_2, "VCU_CRCCheck Failure");
        putValue (EnvMidName, "VCU_CRCCheck Failure");
	  break;
	case 0xD78286:
        putValue (EnvDtcName_2, "SAS DLC Failure");
        putValue (EnvMidName, "SAS DLC Failure");
	  break;
	case 0xD79582:
        putValue (EnvDtcName_2, "BCM_Rollingcounter failure");
        putValue (EnvMidName, "BCM_Rollingcounter failure");
	  break;
	case 0xD79682:
        putValue (EnvDtcName_2, "IB_Rollingcounter failure");
        putValue (EnvMidName, "IB_Rollingcounter failure");
	  break;
	case 0xD79982:
        putValue (EnvDtcName_2, "CDC_Rollingcounter failure");
        putValue (EnvMidName, "CDC_Rollingcounter failure");
	  break;
	case 0xD78982:
        putValue (EnvDtcName_2, "VCU_Rollingcounter failure");
        putValue (EnvMidName, "VCU_Rollingcounter failure");
	  break;
	default:
        putValue (EnvDtcName_2, "No DTC Mapping");
		    putValue (EnvMidName, "No DTC Mapping");
    break;
   
}
}

on busOff
{
   resetcan(); 
}

/*on envVar Env_MPC3_Manual_Calibration
{
	if(getValue(this)){
		putvalue(Env_MPC3_Manual_Calibration,0);
		seq = 0;
		setTimer(Tm_RBEOL_manual_write,10);
    }
}*/
on envVar ENV_Dump_EEPROM_1
{
  if(getValue(this)){
    char reqCharBuffer[128];
    transmintRemainBytes = 0x100000;
    snprintf(reqCharBuffer,elcount(reqCharBuffer),"350044%.8X%.8x",1,transmintRemainBytes);
    TxLength = str2byte1(reqCharBuffer,TxDataBuffer);
    CurrentDiagServ = DUMPEEPROMSEQ;
    //TxLength = str2byte1("3500440000000100100000",TxDataBuffer);
    TxLength = str2byte1(reqCharBuffer,TxDataBuffer);
    TransmitTxBuffer();
    //OSEKTL_DataReq(TxDataBuffer,TxLength);
  }
  
}

//on timer Tm_RBEOL_manual_write
//{
//    switch (seq)
//	{
//		case 0:
//			putvalue(EnvDirectSend_2,"1001");//default session
//            write("in case 0");
//			setTimer(Tm_RBEOL_manual_write,500); 
//			seq++;
//        write("seq=%x",seq);
//		break;
//        
//		case 1:
//         write("in case 1");
//			putvalue(EnvRBEOL_1,1);//RBEOL
//			setTimer(Tm_RBEOL_manual_write,1000); 
//			seq++;
//        write("seq=%x",seq);
//		break;
//        
//	
//		case 2:
//        write("in case 3");
//			putvalue(Env_MPC3_EOL_unlock_1,1);         //RBEOL unlock
//			setTimer(Tm_RBEOL_manual_write,1000); 
//			seq++;
//             write("seq=%x",seq);
//		break;
//        case 3:
//         write("in case 3");
//			putvalue(Env_MPC3_EOL_unlock_1,0);         //RBEOL unlock
//			setTimer(Tm_RBEOL_manual_write,5000); 
//			seq++;
//             write("seq=%x",seq);
//		break;
//        case 4:
//        write("in case 4");
//			 putvalue(EnvDirectSend_2,"3D22201f000101");//Windshield selection
//        setTimer(Tm_RBEOL_manual_write,2000); 
//			seq++;
//             write("seq=%x",seq);
//		break;
//     case 5:
//        write("in case 5");
//			 putvalue(EnvDirectSend_2,"3D222021000101");//dataset selection
//        setTimer(Tm_RBEOL_manual_write,2000); 
//			seq++;
//             write("seq=%x",seq);
//		break;
//		case 6:
//        write("in case 6");
//			 putvalue(EnvDirectSend_2,"3D22200F002005010307050d331737000000670000008fc2753cf4fd54Bc96438b3ccdccac3f");//manual calibration
//       setTimer(Tm_RBEOL_manual_write,2000); 
//			seq++;
//             write("seq=%x",seq);
//		break;
//  
//       
//
//  }                   
//
//	
//}